<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022CKS安全认证模拟题</title>
    <url>/posts/3e9a887b/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>版本：<strong><strong>Kubernetes 1.23</strong></strong></li>
<li>系统：ubuntu20.04</li>
</ul>
<h2 id="Question-1-Contexts"><a href="#Question-1-Contexts" class="headerlink" title="Question 1 | Contexts"></a><strong><strong>Question 1 | Contexts</strong></strong></h2><blockquote>
<p><em>Task weight: 1%</em></p>
</blockquote>
<p>You have access to multiple clusters from your main terminal through <code>kubectl</code> contexts. Write all context names into <code>/opt/course/1/contexts</code>, one per line.</p>
<p>From the kubeconfig extract the certificate of user <code>restricted@infra-prod</code> and write it decoded to <code>/opt/course/1/cert</code>.</p>
<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.很简单获取所有集群的上下文名称</span></span><br><span class="line">kubectl config get-contexts  --no-headers  | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> &gt; /opt/course/1/contexts</span><br><span class="line"><span class="comment"># 2.使用(kubectl config view --raw --help)可以查询到该命令</span></span><br><span class="line"><span class="comment"># 显示合并的kubecconfig设置和原始证书数据</span></span><br><span class="line">kubectl config view --raw -ojsonpath=<span class="string">&quot;&#123;.users[2].user.client-certificate-data&#125;&quot;</span> | base64 -d &gt; /opt/course/1/cert</span><br></pre></td></tr></table></figure>

<h2 id="Question-2-Runtime-Security-with-Falco"><a href="#Question-2-Runtime-Security-with-Falco" class="headerlink" title="Question 2 | Runtime Security with Falco"></a><strong><strong>Question 2 | Runtime Security with Falco</strong></strong></h2><blockquote>
<p><em>Task weight: 4%</em></p>
</blockquote>
<p>Falco is installed with default configuration on node <code>cluster1-worker1</code>. Connect using <code>ssh cluster1-worker1</code>. Use it to:</p>
<ol>
<li>Find a <em>Pod</em> running image <code>nginx</code> which creates unwanted package management processes inside its container.</li>
<li>Find a <em>Pod</em> running image <code>httpd</code> which modifies <code>/etc/passwd</code>.</li>
</ol>
<p>Save the Falco logs for case 1 under <code>/opt/course/2/falco.log</code> in format:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">time-with-nanosconds,container-id,container-name,user-name</span></span><br></pre></td></tr></table></figure>

<p>No other information should be in any line. Collect the logs for at least 30 seconds.</p>
<p>Afterwards remove the threads (both 1 and 2) by scaling the replicas of the <em>Deployments</em> that control the offending <em>Pods</em> down to 0.</p>
<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先检查calico服务是否启动，并检查默认配置是否将日志写入了syslog</span></span><br><span class="line">service falco status</span><br><span class="line">cat /etc/falco/falco.yaml</span><br><span class="line">...</span><br><span class="line">syslog_output:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 1.查找镜像是nginx的pod,它在容器中创建了不需要的包管理进程。</span></span><br><span class="line">cat /var/<span class="built_in">log</span>/syslog | grep falco | grep nginx | grep process</span><br><span class="line"><span class="comment"># 2.找到一个Pod运行的镜像httpd，修改/etc/passwd。</span></span><br><span class="line">cat /var/<span class="built_in">log</span>/syslog | grep falco | grep httpd | grep passwd</span><br><span class="line"><span class="comment"># 将对应的deployment副本数调0,方法：</span></span><br><span class="line"><span class="comment"># 只需要根据上面获取到的container_id，查找到对应的Pod ID，再根据pod id 获取pod名称，最后通过kubectl获取deployment</span></span><br><span class="line">crictl ps | grep 7a5ea6a080d1</span><br><span class="line">7a5ea6a080d1b       6f715d38cfe0e      nginx       ...         7a864406b9794</span><br><span class="line">crictl pods ls | grep 7a864406b9794</span><br><span class="line">7a864406b9794       ...          webapi-6cfddcd6f4-ftxg4          team-blue        ...</span><br><span class="line">kubectl get pod -A | grep webapi</span><br><span class="line">team-blue              webapi-6cfddcd6f4-ftxg4                      1/1     Running</span><br><span class="line"><span class="comment"># 最后将查询到实例副本调0 ,这里只记录一个，另外一个同理。</span></span><br><span class="line">kubectl -n team-blue scale deploy webapi --replicas 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.保存第一个pod日志到 /opt/course/2/falco.log，按照预定的格式来配置。（根据第一个pod可以看到是在容器中创建了不需要的包管理进程。）</span></span><br><span class="line"><span class="comment"># 这里修改配置文件</span></span><br><span class="line"><span class="built_in">cd</span> /etc/falco/</span><br><span class="line">cp falco_rules.yaml falco_rules.yaml_ori</span><br><span class="line">vim falco_rules.yaml</span><br><span class="line"><span class="comment"># 搜索关键字：Launch Package Management Process in Container</span></span><br><span class="line">- rule: Launch Package Management Process <span class="keyword">in</span> Container</span><br><span class="line">  desc: Package management process ran inside container</span><br><span class="line">...</span><br><span class="line">output: &gt;</span><br><span class="line">    Package management process launched <span class="keyword">in</span> container %evt.time,%container.id,%container.name,%user.name</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 重启falco</span></span><br><span class="line">service falco restart</span><br><span class="line"><span class="comment"># 收集日志30s,过滤其他日志并输出文件到/opt/course/2/falco.log</span></span><br><span class="line">sleep 35s ; falco | grep <span class="string">&quot;Package management&quot;</span> &gt; /tmp/falco.log</span><br><span class="line">06:38:28.077150666: Error Package management process launched <span class="keyword">in</span> container 06:38:28.077150666,090aad374a0a,nginx,root</span><br><span class="line">06:38:33.058263010: Error Package management process launched <span class="keyword">in</span> container 06:38:33.058263010,090aad374a0a,nginx,root</span><br><span class="line">06:38:38.068693625: Error Package management process launched <span class="keyword">in</span> container 06:38:38.068693625,090aad374a0a,nginx,root</span><br><span class="line">06:38:43.066159360: Error Package management process launched <span class="keyword">in</span> container 06:38:43.066159360,090aad374a0a,nginx,root</span><br><span class="line">06:38:48.059792139: Error Package management process launched <span class="keyword">in</span> container 06:38:48.059792139,090aad374a0a,nginx,root</span><br><span class="line">06:38:53.063328933: Error Package management process launched <span class="keyword">in</span> container 06:38:53.063328933,090aad374a0a,nginx,root</span><br><span class="line"><span class="comment"># 截取日志，去除其他多余字段信息。</span></span><br><span class="line">cat /tmp/falco.log | cut -d<span class="string">&quot; &quot;</span> -f 9 &gt; /opt/course/2/falco.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志输出格式falco参考:</span></span><br><span class="line">&lt;https://falco.org/docs/reference/rules/supported-fields/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Question-3-Apiserver-Security"><a href="#Question-3-Apiserver-Security" class="headerlink" title="Question 3 | Apiserver Security"></a><strong><strong>Question 3 | Apiserver Security</strong></strong></h2><blockquote>
<p><em>Task weight: 3%</em></p>
</blockquote>
<p>You received a list from the DevSecOps team which performed a security investigation of the k8s cluster1 (<code>workload-prod</code>). The list states the following about the apiserver setup:</p>
<ul>
<li>Accessible through a NodePort <em>Service</em></li>
</ul>
<p>Change the apiserver setup so that:</p>
<ul>
<li>Only accessible through a ClusterIP <em>Service</em></li>
</ul>
<blockquote>
<p>参考: <a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/"></a><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/">https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/</a></p>
</blockquote>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解题思路：修改APIserver的配置，--kubernetes-service-node-port=0，或者删除该配置参数，删除API的service</span></span><br><span class="line"><span class="comment"># 1.找到静态pod配置，并设置参数为0</span></span><br><span class="line">vim /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line">...</span><br><span class="line">- --kubernetes-service-node-port=0   <span class="comment"># delete or set to 0</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 2.查看pod，并删除APIserver的service</span></span><br><span class="line">kubectl -n kube-system get pod | grep apiserver</span><br><span class="line">kubectl delete svc kubernetes</span><br><span class="line">kubectl get svc</span><br></pre></td></tr></table></figure>

<h2 id="Question-4-Pod-Security-Policies"><a href="#Question-4-Pod-Security-Policies" class="headerlink" title="Question 4 | Pod Security Policies"></a><strong><strong>Question 4 | Pod Security Policies</strong></strong></h2><blockquote>
<p><em>Task weight: 8%</em></p>
</blockquote>
<p>There is <em>Deployment</em> <code>container-host-hacker</code> in <em>Namespace</em> <code>team-red</code> which mounts <code>/run/containerd</code> as a hostPath volume on the <em>Node</em> where its running. This means that the <em>Pod</em> can access various data about other containers running on the same  <em>Node</em> .</p>
<p>You’re asked to forbid this behavior by:</p>
<ol>
<li>Enabling Admission Plugin <code>PodSecurityPolicy</code> in the apiserver</li>
<li>Creating a <em>PodSecurityPolicy</em> named <code>psp-mount</code> which allows hostPath volumes only for directory <code>/tmp</code></li>
<li>Creating a <em>ClusterRole</em> named <code>psp-mount</code> which allows to use the new <em>PSP</em></li>
<li>Creating a <em>RoleBinding</em> named <code>psp-mount</code> in <em>Namespace</em> <code>team-red</code> which binds the new <em>ClusterRole</em> to all <em>ServiceAccounts</em> in the <em>Namespace</em> <code>team-red</code></li>
</ol>
<p>Restart the <em>Pod</em> of <em>Deployment</em> <code>container-host-hacker</code> afterwards to verify new creation is prevented.</p>
<blockquote>
<p>NOTE: PSPs can affect the whole cluster. Should you encounter issues you can always disable the Admission Plugin again.</p>
</blockquote>
<p>解答</p>
<blockquote>
<p>注意：PodSecurityPolicy (PSP) 在 Kubernetes 1.21 中被弃用，在<em>Kubernetes v1.25彻底移除。</em></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.kube-apiserver 开启PSP</span></span><br><span class="line">cp /etc/kubernetes/manifests/kube-apiserver.yaml&#123;,.bak&#125;</span><br><span class="line">vi /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line">- --enable-admission-plugins=NodeRestriction,PodSecurityPolicy      <span class="comment"># 增加PodSecurityPolicy参数</span></span><br><span class="line"><span class="comment"># 2.从k8s官方复制一个psp配置文件进行修改</span></span><br><span class="line">vim 4_psp.yaml</span><br><span class="line">apiVersion: policy/v1beta1</span><br><span class="line">kind: PodSecurityPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: psp-mount</span><br><span class="line">spec:</span><br><span class="line">  privileged: <span class="literal">true</span></span><br><span class="line">  seLinux:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  supplementalGroups:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  runAsUser:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  fsGroup:</span><br><span class="line">    rule: RunAsAny</span><br><span class="line">  volumes:</span><br><span class="line">  - <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  allowedHostPaths:             <span class="comment"># task requirement</span></span><br><span class="line">    - pathPrefix: <span class="string">&quot;/tmp&quot;</span>        <span class="comment"># task requirement</span></span><br><span class="line">kubectl apply -f 4_psp.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.授予 Pods ServiceAccounts 使用它的 RBAC 权限，创建clusterrole</span></span><br><span class="line">kubectl -n team-red create clusterrole psp-mount --verb=use \\</span><br><span class="line">--resource=podsecuritypolicies --resource-name=psp-mount</span><br><span class="line"><span class="comment"># 要添加*RoleBingding，并绑定到*team-red 名称空间下左右serviceaccounts</span></span><br><span class="line">kubectl -n team-red create rolebinding psp-mount --clusterrole=psp-mount --group system:serviceaccounts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试PSP,重启发现会报错，需要修改deployment</span></span><br><span class="line">kubectl -n team-red rollout restart deploy container-host-hacker</span><br><span class="line">kubectl -n team-red edit deploy container-host-hacker</span><br><span class="line">...</span><br><span class="line">      volumes:</span><br><span class="line">      - hostPath:</span><br><span class="line">          path: /tmp                         <span class="comment"># change</span></span><br><span class="line">          <span class="built_in">type</span>: <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Question-5-CIS-Benchmark"><a href="#Question-5-CIS-Benchmark" class="headerlink" title="Question 5 | CIS Benchmark"></a><strong><strong>Question 5 | CIS Benchmark</strong></strong></h2><blockquote>
<p><em>Task weight: 3%</em></p>
</blockquote>
<p>You’re ask to evaluate specific settings of cluster2 against the CIS Benchmark recommendations. Use the tool <code>kube-bench</code> which is already installed on the nodes.</p>
<p>Connect using <code>ssh cluster2-master1</code> and <code>ssh cluster2-worker1</code>.</p>
<p>On the master node ensure (correct if necessary) that the CIS recommendations are set for:</p>
<ol>
<li>The <code>-profiling</code> argument of the kube-controller-manager</li>
<li>The ownership of directory <code>/var/lib/etcd</code></li>
</ol>
<p>On the worker node ensure (correct if necessary) that the CIS recommendations are set for:</p>
<ol>
<li>The permissions of the kubelet configuration <code>/var/lib/kubelet/config.yaml</code></li>
<li>The <code>-client-ca-file</code> argument of the kubelet</li>
</ol>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master 配置</span></span><br><span class="line"><span class="comment"># 1.查找kube-controller-manager</span></span><br><span class="line">kube-bench run --targets=master | grep kube-controller -A 3</span><br><span class="line">1.3.2 Edit the Controller Manager pod specification file /etc/kubernetes/manifests/kube-controller-manager.yaml</span><br><span class="line">on the master node and <span class="built_in">set</span> the below parameter.</span><br><span class="line">--profiling=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 根据修改建议添加参数：--profiling=false</span></span><br><span class="line">vim /etc/kubernetes/manifests/kube-controller-manager.yaml</span><br><span class="line">- --profiling=<span class="literal">false</span>            <span class="comment"># add</span></span><br><span class="line"><span class="comment"># 重启再扫一次发现合规了。</span></span><br><span class="line"><span class="comment"># 2.etcd数据目录权限设置</span></span><br><span class="line">ls -lh /var/lib | grep etcd </span><br><span class="line">drwx------  3 root      root      4.0K Sep 11 20:08 etcd</span><br><span class="line">kube-bench run --targets=master | grep <span class="string">&quot;/var/lib/etcd&quot;</span> -B5</span><br><span class="line">ps -ef | grep etcd</span><br><span class="line">Run the below <span class="built_in">command</span> (based on the etcd data directory found above).</span><br><span class="line">For example, chown etcd:etcd /var/lib/etcd</span><br><span class="line"><span class="comment"># 设置权限</span></span><br><span class="line">chown etcd:etcd /var/lib/etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># work node配置</span></span><br><span class="line"><span class="comment"># 1.设置kubelet配置文件权限</span></span><br><span class="line">kube-bench run --targets=node | grep /var/lib/kubelet/config.yaml -B2</span><br><span class="line">4.1.9 Run the following <span class="built_in">command</span> (using the config file location identified <span class="keyword">in</span> the Audit step)</span><br><span class="line">chmod 644 /var/lib/kubelet/config.yaml  <span class="comment"># 执行该命令即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.配置kubelet client-ca-file参数，发现该参数是通过的忽略</span></span><br><span class="line">kube-bench run --targets=node | grep client-ca-file</span><br><span class="line">[PASS] 4.2.3 Ensure that the --client-ca-file argument is <span class="built_in">set</span> as appropriate (Automated)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Question-6-Verify-Platform-Binaries"><a href="#Question-6-Verify-Platform-Binaries" class="headerlink" title="Question 6 | Verify Platform Binaries"></a><strong><strong>Question 6 | Verify Platform Binaries</strong></strong></h2><blockquote>
<p><em>Task weight: 2%</em></p>
</blockquote>
<p>There are four Kubernetes server binaries located at <code>/opt/course/6/binaries</code>. You’re provided with the following verified sha512 values for these:</p>
<p><strong>kube-apiserver</strong> <code>f417c0555bc0167355589dd1afe23be9bf909bf98312b1025f12015d1b58a1c62c9908c0067a7764fa35efdac7016a9efa8711a44425dd6692906a7c283f032c</code></p>
<p><strong>kube-controller-manager</strong> <code>60100cc725e91fe1a949e1b2d0474237844b5862556e25c2c655a33boa8225855ec5ee22fa4927e6c46a60d43a7c4403a27268f96fbb726307d1608b44f38a60</code></p>
<p><strong>kube-proxy</strong> <code>52f9d8ad045f8eee1d689619ef8ceef2d86d50c75a6a332653240d7ba5b2a114aca056d9e513984ade24358c9662714973c1960c62a5cb37dd375631c8a614c6</code></p>
<p><strong>kubelet</strong> <code>4be40f2440619e990897cf956c32800dc96c2c983bf64519854a3309fa5aa21827991559f9c44595098e27e6f2ee4d64a3fdec6baba8a177881f20e3ec61e26c</code></p>
<p>Delete those binaries that don’t match with the sha512 values above.</p>
<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /opt/course/6/binaries</span><br><span class="line">kube-apiserver  kube-controller-manager  kube-proxy  kubelet</span><br><span class="line"><span class="comment"># 这个题目很简单，使用到sha512sum 命令，先获取所有二进制的指纹存在compare，再将上面放入compare1</span></span><br><span class="line">ls /opt/course/6/binaries | xarges sha512sum &gt;&gt; /tmp/compare</span><br><span class="line">vim /tmp/compare1 <span class="comment"># 按顺复制</span></span><br><span class="line">diff /tmp/compare /tmp/compare1</span><br><span class="line">diff compare1 compare</span><br><span class="line">1,2c1,2</span><br><span class="line">&lt; a9d60ae18eef79754d1a085e29e00b54b90b6ce42e05d1c452b81491092a02aeee00ce240573440c5b6e75344a4aa356155c55342fe2dc3b98f805c62d60afc8  kubelet</span><br><span class="line">&lt; 03ad459d28dd2c762b7f522f0d6a4c5d4e23b9cca83e6850b89ca92d81ec917e917dc6f74bf821dc5c61526a714dec45fdde3d54ad0039f05e4dad590bfa5861  kube-controller-manager</span><br><span class="line">---</span><br><span class="line">&gt; f417c0555bc0167355589dd1afe23be9bf909bf98312b1025f12015d1b58a1c62c9908c0067a7764fa35efdac7016a9efa8711a44425dd6692906a7c283f032c kubelet</span><br><span class="line">&gt; f417c0555bc0167355589dd1afe23be9bf909bf98312b1025f12015d1b58a1c62c9908c0067a7764fa35efdac7016a9efa8711a44425dd6692906a7c283f032c kube-controller-manager</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里比对出 kubelet kube-controller-manager 文件指纹不同将其删除</span></span><br><span class="line">rm kubelet kube-controller-manager</span><br></pre></td></tr></table></figure>

<h2 id="Question-7-Open-Policy-Agent"><a href="#Question-7-Open-Policy-Agent" class="headerlink" title="Question 7 | Open Policy Agent"></a><strong><strong>Question 7 | Open Policy Agent</strong></strong></h2><blockquote>
<p><em>Task weight: 6%</em></p>
</blockquote>
<p>The Open Policy Agent and Gatekeeper have been installed to, among other things, enforce blacklisting of certain image registries. Alter the existing constraint and/or template to also blacklist images from <code>very-bad-registry.com</code>.</p>
<p>Test it by creating a single <em>Pod</em> using image <code>very-bad-registry.com/image</code> in <em>Namespace</em> <code>default</code>, it shouldn’t work.</p>
<p>You can also verify your changes by looking at the existing <em>Deployment</em> <code>untrusted</code> in <em>Namespace</em> <code>default</code>, it uses an image from the new untrusted source. The OPA contraint should throw violation messages for this one.</p>
<blockquote>
<p>参考：****<a href="https://kubernetes.io/zh-cn/blog/2019/08/06/opa-gatekeeper-policy-and-governance-for-kubernetes/">OPA Gatekeeper</a>****</p>
</blockquote>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.查看OPA资源</span></span><br><span class="line"><span class="comment"># 查看 约束</span></span><br><span class="line">kubectl get constraint</span><br><span class="line">NAME                                                           AGE</span><br><span class="line">blacklistimages.constraints.gatekeeper.sh/pod-trusted-images   10m</span><br><span class="line"><span class="comment"># 查看blacklistimages 资源</span></span><br><span class="line">kubectl get blacklistimages pod-trusted-images -o yaml | less</span><br><span class="line"><span class="comment"># 查看约束模板，并修改镜像黑名单，并添加very-bad-registry.com</span></span><br><span class="line">constrainttemplates blacklistimages</span><br><span class="line">apiVersion: templates.gatekeeper.sh/v1beta1</span><br><span class="line">kind: ConstraintTemplate</span><br><span class="line">metadata:</span><br><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  crd:</span><br><span class="line">    spec:</span><br><span class="line">      names:</span><br><span class="line">        kind: BlacklistImages</span><br><span class="line">  targets:</span><br><span class="line">  - rego: |</span><br><span class="line">      package k8strustedimages</span><br><span class="line"></span><br><span class="line">      images &#123;</span><br><span class="line">        image := input.review.object.spec.containers[_].image</span><br><span class="line">        not startswith(image, <span class="string">&quot;docker-fake.io/&quot;</span>)</span><br><span class="line">        not startswith(image, <span class="string">&quot;google-gcr-fake.com/&quot;</span>)</span><br><span class="line">        not startswith(image, <span class="string">&quot;very-bad-registry.com/&quot;</span>) <span class="comment"># 添加这行</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      violation[&#123;<span class="string">&quot;msg&quot;</span>: msg&#125;] &#123;</span><br><span class="line">        not images</span><br><span class="line">        msg := <span class="string">&quot;not trusted image!&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    target: admission.k8s.gatekeeper.sh</span><br><span class="line"><span class="comment"># 创建pod测试验证是否生效</span></span><br><span class="line">kubectl run opa-test --image=very-bad-registry.com/image</span><br><span class="line">Error from server ([denied by pod-trusted-images] not trusted image!): admission webhook <span class="string">&quot;validation.gatekeeper.sh&quot;</span> denied the request: [denied by pod-trusted-images] not trusted image!</span><br></pre></td></tr></table></figure>

<h2 id="Question-8-Secure-Kubernetes-Dashboard"><a href="#Question-8-Secure-Kubernetes-Dashboard" class="headerlink" title="Question 8 | Secure Kubernetes Dashboard"></a><strong><strong>Question 8 | Secure Kubernetes Dashboard</strong></strong></h2><blockquote>
<p><em>Task weight: 3%</em></p>
</blockquote>
<p>The Kubernetes Dashboard is installed in <em>Namespace</em> <code>kubernetes-dashboard</code> and is configured to:</p>
<ol>
<li>Allow users to “skip login”</li>
<li>Allow insecure access (HTTP without authentication)</li>
<li>Allow basic authentication</li>
<li>Allow access from outside the cluster</li>
</ol>
<p>You are asked to make it more secure by:</p>
<ol>
<li>Deny users to “skip login”</li>
<li>Deny insecure access, enforce HTTPS (self signed certificates are ok for now)</li>
<li>Add the <code>-auto-generate-certificates</code> argument</li>
<li>Enforce authentication using a token (with possibility to use RBAC)</li>
<li>Allow only cluster internal access</li>
</ol>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看dashboard信息</span></span><br><span class="line">kubect -n kubernetes-dashboard get pod,svc</span><br><span class="line">NAME                                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/dashboard-metrics-scraper-7b59f7d4df-fbpd9   1/1     Running   0          24m</span><br><span class="line">pod/kubernetes-dashboard-6d8cd5dd84-w7wr2        1/1     Running   0          24m</span><br><span class="line">NAME                                TYPE        ...   PORT(S)                        AGE</span><br><span class="line">service/dashboard-metrics-scraper   ClusterIP   ...   8000/TCP                       24m</span><br><span class="line">service/kubernetes-dashboard        NodePort    ...   9090:32520/TCP,443:31206/TCP   24m</span><br><span class="line"><span class="comment"># 获取dashboard deployment配置，按要求修改配置</span></span><br><span class="line"><span class="comment"># 备份配置</span></span><br><span class="line">kubectl -n kubernetes-dashboard get deploy kubernetes-dashboard -oyaml &gt; 8_deploy_kubernetes-dashboard.yaml</span><br><span class="line"><span class="comment"># 直接修改</span></span><br><span class="line">kubectl -n kubernetes-dashboard edit deploy kubernetes-dashboard</span><br><span class="line">template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - args:</span><br><span class="line">        - --namespace=kubernetes-dashboard  </span><br><span class="line">        - --authentication-mode=token        <span class="comment"># 修改认证模式为&quot;token&quot; ，或者直接删除该行，默认是token认证模式</span></span><br><span class="line">        - --auto-generate-certificates       <span class="comment"># 增加该行，自动生成证书</span></span><br><span class="line">        <span class="comment">#- --enable-skip-login=true          # 删除该行，取消跳过登录</span></span><br><span class="line">        <span class="comment">#- --enable-insecure-login           # 删除该行，取消安全认证</span></span><br><span class="line">        image: kubernetesui/dashboard:v2.0.3</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改service模式为集群内部访问，即将nodePort模式改成ClusterIP</span></span><br><span class="line">kubectl -n kubernetes-dashboard edit svc kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: 10.107.176.19</span><br><span class="line">  externalTrafficPolicy: Cluster   <span class="comment"># 删除</span></span><br><span class="line">  internalTrafficPolicy: Cluster</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    nodePort: 32513                <span class="comment"># 删除</span></span><br><span class="line">    port: 9090</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 9090</span><br><span class="line">  - name: https</span><br><span class="line">    nodePort: 32441                <span class="comment"># 删除</span></span><br><span class="line">    port: 443</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  <span class="built_in">type</span>: ClusterIP                  <span class="comment"># 修改成ClusterIP,或直接删除</span></span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">kubectl -n kubernetes-dashboard get svc</span><br><span class="line">NAME                        TYPE        CLUSTER-IP       ...   PORT(S)</span><br><span class="line">dashboard-metrics-scraper   ClusterIP   10.111.171.247   ...   8000/TCP</span><br><span class="line">kubernetes-dashboard        ClusterIP   10.100.118.128   ...   9090/TCP,443/TCP</span><br><span class="line">curl &lt;http://192.168.100.11:32520&gt; <span class="comment"># 发现原来的nodePort端口访问不了。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Question-9-AppArmor-Profile"><a href="#Question-9-AppArmor-Profile" class="headerlink" title="Question 9 | AppArmor Profile"></a><strong><strong>Question 9 | AppArmor Profile</strong></strong></h2><blockquote>
<p><em>Task weight: 3%</em></p>
</blockquote>
<p>Some containers need to run more secure and restricted. There is an existing AppArmor profile located at <code>/opt/course/9/profile</code> for this.</p>
<ol>
<li><p>Install the AppArmor profile on <em>Node</em> <code>cluster1-worker1</code>. Connect using <code>ssh cluster1-worker1</code>.</p>
</li>
<li><p>Add label <code>security=apparmor</code> to the <em>Node</em></p>
</li>
<li><p>Create a <em>Deployment</em> named <code>apparmor</code> in <em>Namespace</em> <code>default</code> with:</p>
<ul>
<li>One replica of image <code>nginx:1.19.2</code></li>
<li>NodeSelector for <code>security=apparmor</code></li>
<li>Single container named <code>c1</code> with the AppArmor profile enabled</li>
</ul>
<p>The <em>Pod</em> might not run properly with the profile enabled. Write the logs of the <em>Pod</em> into <code>/opt/course/9/logs</code> so another team can work on getting the application running.</p>
</li>
</ol>
<p>参考</p>
<blockquote>
<p><strong><strong><a href="https://kubernetes.io/zh-cn/docs/tutorials/security/apparmor/">使用 AppArmor 限制容器对资源的访问</a></strong></strong></p>
</blockquote>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 1.拷贝profile文件到cluster1-worker1</span></span><br><span class="line">scp /opt/course/9/profile cluster1-worker1:~/</span><br><span class="line"><span class="comment"># 登录cluster1-worker1，加载配置</span></span><br><span class="line">apparmor_parser -q ./profile </span><br><span class="line"><span class="comment"># 2.给node添加标签</span></span><br><span class="line">kubectl label node cluster1-worker1 security=apparmor</span><br><span class="line"><span class="comment"># 3.创建deploy</span></span><br><span class="line">kubectl create deploy apparmor --image=nginx:1.19.2 --dry-run=cilent &gt; 9_deploy.yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    app: apparmor</span><br><span class="line">  name: apparmor</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: apparmor</span><br><span class="line">  strategy: &#123;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: apparmor</span><br><span class="line">      annotations:                                                                 <span class="comment"># 增加配置，参考官网：&lt;https://kubernetes.io/zh-cn/docs/tutorials/security/apparmor/&gt;</span></span><br><span class="line">        container.apparmor.security.beta.kubernetes.io/c1: localhost/very-secure   <span class="comment"># 增加配置</span></span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:                    <span class="comment"># 增加标签</span></span><br><span class="line">        security: apparmor             <span class="comment"># 增加标签</span></span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx:1.19.2</span><br><span class="line">        name: c1                       <span class="comment"># 修改容器名字为c1</span></span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line"><span class="comment"># 创建deploy,并写入日志。</span></span><br><span class="line">kubectl apply -f  9_deploy.yaml</span><br><span class="line">kubectl get pod -owide | grep apparmor</span><br><span class="line">kubectl logs apparmor-85c65645dc-w852p &gt; /opt/course/9/logs <span class="comment"># 将日志写入/opt/course/9/logs</span></span><br><span class="line">/docker-entrypoint.sh: 13: /docker-entrypoint.sh: cannot create /dev/null: Permission denied</span><br><span class="line">/docker-entrypoint.sh: No files found <span class="keyword">in</span> /docker-entrypoint.d/, skipping configuration</span><br><span class="line">2021/09/15 11:51:57 [emerg] 1<span class="comment">#1: mkdir() &quot;/var/cache/nginx/client_temp&quot; failed (13: Permission denied)</span></span><br><span class="line">nginx: [emerg] mkdir() <span class="string">&quot;/var/cache/nginx/client_temp&quot;</span> failed (13: Permission denied)</span><br></pre></td></tr></table></figure>

<h2 id="Question-10-Container-Runtime-Sandbox-gVisor"><a href="#Question-10-Container-Runtime-Sandbox-gVisor" class="headerlink" title="Question 10 | Container Runtime Sandbox gVisor"></a><strong>Question 10 | Container Runtime Sandbox <a href="https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/">gVisor</a></strong></h2><blockquote>
<p><em>Task weight: 4%</em></p>
</blockquote>
<p>Team purple wants to run some of their workloads more secure. Worker node <code>cluster1-worker2</code> has container engine containerd already installed and its configured to support the runsc/gvisor runtime.</p>
<p>Create a <em>RuntimeClass</em> named <code>gvisor</code> with handler <code>runsc</code>.</p>
<p>Create a <em>Pod</em> that uses the  <em>RuntimeClass</em> . The <em>Pod</em> should be in <em>Namespace</em> <code>team-purple</code>, named <code>gvisor-test</code> and of image <code>nginx:1.19.2</code>. Make sure the <em>Pod</em> runs on <code>cluster1-worker2</code>.</p>
<p>Write the <code>dmesg</code> output of the successfully started <em>Pod</em> into <code>/opt/course/10/gvisor-test-dmesg</code>.</p>
<p>参考</p>
<blockquote>
<p><strong><strong><a href="https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/">容器运行时类</a></strong></strong></p>
</blockquote>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、创建一个运行时类</span></span><br><span class="line">cat 10_runtimeclass.yaml</span><br><span class="line"><span class="comment"># RuntimeClass 定义于 node.k8s.io API 组</span></span><br><span class="line">apiVersion: node.k8s.io/v1</span><br><span class="line">kind: RuntimeClass</span><br><span class="line">metadata:</span><br><span class="line">  <span class="comment"># 用来引用 RuntimeClass 的名字</span></span><br><span class="line">  <span class="comment"># RuntimeClass 是一个集群层面的资源</span></span><br><span class="line">  name: gvisor</span><br><span class="line"><span class="comment"># 对应的 CRI 配置的名称</span></span><br><span class="line">handler: runsc</span><br><span class="line"></span><br><span class="line">kubectl -n team-purple apply -f 10_runtimeclass.yaml</span><br><span class="line"><span class="comment"># 2、创建一个pod 使用gvisor runtimeClass</span></span><br><span class="line">kubectl -n team-purple run gvisor-test --image=nginx:1.19.2 --dry-run=client -o yaml &gt; 10_gvisor-test.yaml</span><br><span class="line">vim 10_gvisor-test.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    run: gvisor-test</span><br><span class="line">  name: gvisor-test</span><br><span class="line">  namespace: team-purple</span><br><span class="line">spec:</span><br><span class="line">  runtimeClassName: gvisor  <span class="comment">#增加这行</span></span><br><span class="line">  nodeName: cluster1-worker2 <span class="comment">#指定node节点</span></span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx:1.19.2</span><br><span class="line">    name: gvisor-test</span><br><span class="line">    resources: &#123;&#125;</span><br><span class="line">  dnsPolicy: ClusterFirst</span><br><span class="line">  restartPolicy: Always</span><br><span class="line">status: &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、写日志到/opt/course/10/gvisor-test-dmesg</span></span><br><span class="line">kubectl -n team-purple <span class="built_in">exec</span> gvisor-test -- dmesg &gt; /opt/course/10/gvisor-test-dmesg</span><br><span class="line">[    0.000000] Starting gVisor...</span><br><span class="line">[    0.417740] Checking naughty and nice process list...</span><br><span class="line">[    0.623721] Waiting <span class="keyword">for</span> children...</span><br><span class="line">[    0.902192] Gathering forks...</span><br><span class="line">[    1.258087] Committing treasure map to memory...</span><br><span class="line">[    1.653149] Generating random numbers by fair dice roll...</span><br><span class="line">[    1.918386] Creating cloned children...</span><br><span class="line">[    2.137450] Digging up root...</span><br><span class="line">[    2.369841] Forking spaghetti code...</span><br><span class="line">[    2.840216] Rewriting operating system <span class="keyword">in</span> Javascript...</span><br><span class="line">[    2.956226] Creating bureaucratic processes...</span><br><span class="line">[    3.329981] Ready!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Question-11-Secrets-in-ETCD"><a href="#Question-11-Secrets-in-ETCD" class="headerlink" title="Question 11 | Secrets in ETCD"></a><strong><strong>Question 11 | Secrets in ETCD</strong></strong></h2><blockquote>
<p><em>Task weight: 7%</em></p>
</blockquote>
<p>There is an existing <em>Secret</em> called <code>database-access</code> in <em>Namespace</em> <code>team-green</code>.</p>
<p>Read the complete <em>Secret</em> content directly from ETCD (using <code>etcdctl</code>) and store it into <code>/opt/course/11/etcd-secret-content</code>. Write the plain and decoded <em>Secret’s</em> value of key “pass” into <code>/opt/course/11/database-password</code>.</p>
<p>参考</p>
<blockquote>
<p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/encrypt-data/">静态加密Secret数据</a></p>
</blockquote>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里只需要找到etcd的秘钥，通过命令重定向即可。</span></span><br><span class="line">ETCDCTL_API=3 etcdctl \\</span><br><span class="line">   --cacert=/opt/course/11/etcd-secret-contenca.crt   \\</span><br><span class="line">   --cert=/opt/course/11/etcd-secret-contenserver.crt \\</span><br><span class="line">   --key=/opt/course/11/etcd-secret-contenserver.key  \\</span><br><span class="line">   get /registry/secrets/team-green/database-access &gt; /opt/course/11/etcd-secret-content</span><br><span class="line"><span class="comment"># /opt/course/11/etcd-secret-content</span></span><br><span class="line">/registry/secrets/team-green/database-access</span><br><span class="line">k8s</span><br><span class="line"></span><br><span class="line">v1Secret</span><br><span class="line"></span><br><span class="line">database-access</span><br><span class="line">team-green<span class="string">&quot;*<span class="variable">$3e0acd78</span>-709d-4f07-bdac-d5193d0f2aa32bB</span></span><br><span class="line"><span class="string">0kubectl.kubernetes.io/last-applied-configuration&#123;&quot;</span>apiVersion<span class="string">&quot;:&quot;</span>v1<span class="string">&quot;,&quot;</span>data<span class="string">&quot;:&#123;&quot;</span>pass<span class="string">&quot;:&quot;</span>Y29uZmlkZW50aWFs<span class="string">&quot;&#125;,&quot;</span>kind<span class="string">&quot;:&quot;</span>Secret<span class="string">&quot;,&quot;</span>metadata<span class="string">&quot;:&#123;&quot;</span>annotations<span class="string">&quot;:&#123;&#125;,&quot;</span>name<span class="string">&quot;:&quot;</span>database-access<span class="string">&quot;,&quot;</span>namespace<span class="string">&quot;:&quot;</span>team-green<span class="string">&quot;&#125;&#125;</span></span><br><span class="line"><span class="string">z</span></span><br><span class="line"><span class="string">kubectl-client-side-applyUpdatevFieldsV1:</span></span><br><span class="line"><span class="string">&#123;&quot;</span>f:data<span class="string">&quot;:&#123;&quot;</span>.<span class="string">&quot;:&#123;&#125;,&quot;</span>f:pass<span class="string">&quot;:&#123;&#125;&#125;,&quot;</span>f:metadata<span class="string">&quot;:&#123;&quot;</span>f:annotations<span class="string">&quot;:&#123;&quot;</span>.<span class="string">&quot;:&#123;&#125;,&quot;</span>f:kubectl.kubernetes.io/last-applied-configuration<span class="string">&quot;:&#123;&#125;&#125;&#125;,&quot;</span>f:<span class="built_in">type</span><span class="string">&quot;:&#123;&#125;&#125;</span></span><br><span class="line"><span class="string">pass</span></span><br><span class="line"><span class="string">    confidentialOpaque&quot;</span></span><br><span class="line"><span class="comment"># 解密pass明文写入</span></span><br><span class="line"><span class="built_in">echo</span> Y29uZmlkZW50aWFs | base64 -d &gt; /opt/course/11/database-password</span><br></pre></td></tr></table></figure>

<h2 id="Question-12-Hack-Secrets"><a href="#Question-12-Hack-Secrets" class="headerlink" title="Question 12 | Hack Secrets"></a><strong><strong>Question 12 | Hack Secrets</strong></strong></h2><blockquote>
<p><em>Task weight: 8%</em></p>
</blockquote>
<p>You’re asked to investigate a possible permission escape in <em>Namespace</em> <code>restricted</code>. The context authenticates as user <code>restricted</code> which has only limited permissions and shouldn’t be able to read <em>Secret</em> values.</p>
<p>Try to find the password-key values of the <em>Secrets</em> <code>secret1</code>, <code>secret2</code> and <code>secret3</code> in <em>Namespace</em> <code>restricted</code>. Write the decoded plaintext values into files <code>/opt/course/12/secret1</code>, <code>/opt/course/12/secret2</code> and <code>/opt/course/12/secret3</code>.</p>
<p>参考</p>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这道就是查找泄漏的秘钥</span></span><br><span class="line"><span class="comment"># 秘钥1，通过查看所有pod过滤secret</span></span><br><span class="line">kubectl -n restricted get pod -o yaml | grep -i secret</span><br><span class="line">kubectl -n restricted <span class="built_in">exec</span> pod1-fd5d64b9c-pcx6q -- cat /etc/secret-volume/password &gt; /opt/course/12/secret1 </span><br><span class="line"><span class="comment"># 秘钥2 通过查看所有pod env 过滤PASS</span></span><br><span class="line">kubectl -n restricted <span class="built_in">exec</span> pod2-6494f7699b-4hks5 -- env | grep PASS</span><br><span class="line">PASSWORD=an-amazing</span><br><span class="line"><span class="built_in">echo</span> an-amazing &gt; /opt/course/12/secret2</span><br><span class="line"><span class="comment"># 秘钥3 尝试了是否有挂在了ServiceAccount，通过默认引用的证书文件访问API获取secret</span></span><br><span class="line">kubectl -n restricted <span class="built_in">exec</span> -it pod3-748b48594-24s76 -- sh</span><br><span class="line"></span><br><span class="line">mount | grep serviceaccount</span><br><span class="line">tmpfs on /run/secrets/kubernetes.io/serviceaccount <span class="built_in">type</span> tmpfs (ro,relatime)</span><br><span class="line">ls /run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">ca.crt     namespace  token</span><br><span class="line"><span class="comment"># curl 接口查询restricted命名空间的秘钥</span></span><br><span class="line"><span class="comment"># 这里参考API访问集群：&lt;https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/access-cluster-api/&gt;</span></span><br><span class="line"><span class="comment"># 另外参考了静态加密secret数据：&lt;https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/encrypt-data/&gt;</span></span><br><span class="line">curl &lt;https://kubernetes.default/api/v1/namespaces/restricted/secrets&gt; -H <span class="string">&quot;Authorization: Bearer <span class="subst">$(cat /run/secrets/kubernetes.io/serviceaccount/token)</span>&quot;</span> -k</span><br><span class="line">...</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;secret3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;restricted&quot;</span>,</span><br><span class="line">...</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: <span class="string">&quot;cEVuRXRSYVRpT24tdEVzVGVSCg==&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Opaque&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 看到密码字段进行解密</span></span><br><span class="line"><span class="built_in">echo</span> cEVuRXRSYVRpT24tdEVzVGVSCg== | base64 -d &gt; /opt/course/12/secret3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Question-13-Restrict-access-to-Metadata-Server"><a href="#Question-13-Restrict-access-to-Metadata-Server" class="headerlink" title="Question 13 | Restrict access to Metadata Server"></a><strong><strong>Question 13 | Restrict access to Metadata Server</strong></strong></h2><blockquote>
<p><em>Task weight: 7%</em></p>
</blockquote>
<p>There is a metadata service available at <code>http://192.168.100.21:32000</code> on which <em>Nodes</em> can reach sensitive data, like cloud credentials for initialisation. By default, all <em>Pods</em> in the cluster also have access to this endpoint. The DevSecOps team has asked you to restrict access to this metadata server.</p>
<p>In <em>Namespace</em> <code>metadata-access</code>:</p>
<ul>
<li>Create a <em>NetworkPolicy</em> named <code>metadata-deny</code> which prevents egress to <code>192.168.100.21</code> for all <em>Pods</em> but still allows access to everything else</li>
<li>Create a <em>NetworkPolicy</em> named <code>metadata-allow</code> which allows <em>Pods</em> having label <code>role: metadata-accessor</code> to access endpoint <code>192.168.100.21</code></li>
</ul>
<p>There are existing <em>Pods</em> in the target <em>Namespace</em> with which you can test your policies, but don’t change their labels.</p>
<p>参考</p>
<blockquote>
<p><strong><strong><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#default-deny-all-egress-traffic">网络策略</a></strong></strong></p>
</blockquote>
<p>解答</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">vim</span> <span class="string">13_metadata-deny.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metadata-deny</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metadata-access</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">            <span class="attr">cidr:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/0</span></span><br><span class="line">            <span class="attr">except:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.21</span><span class="string">/32</span></span><br><span class="line"></span><br><span class="line"><span class="string">vim</span> <span class="string">13_metadata-allow.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">metadata-allow</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">metadata-access</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">metadata-accessor</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">            <span class="attr">cidr:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.21</span><span class="string">/32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用如上2个配置文件即可</span></span><br></pre></td></tr></table></figure>

<h2 id="Question-14-Syscall-Activity"><a href="#Question-14-Syscall-Activity" class="headerlink" title="Question 14 | Syscall Activity"></a><strong><strong>Question 14 | Syscall Activity</strong></strong></h2><blockquote>
<p><em>Task weight: 4%</em></p>
</blockquote>
<p>There are <em>Pods</em> in <em>Namespace</em> <code>team-yellow</code>. A security investigation noticed that some processes running in these <em>Pods</em> are using the Syscall <code>kill</code>, which is forbidden by a Team Yellow internal policy.</p>
<p>Find the offending <em>Pod(s)</em> and remove these by reducing the replicas of the parent <em>Deployment</em> to 0.</p>
<p>解答</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为容器进程限制这些是有意义的，Docker/Containerd 已经默认限制了一些，比如reboot系统调用。甚至可以限制更多，例如使用 Seccomp 或 AppArmor</span></span><br><span class="line"><span class="comment"># 该题目只要找到名称空间下pod所在主机，登录主机,使用crictl 查看容器信息过滤出来程序PID，然后strace 查看系统调用</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">-n</span> <span class="string">team-yellow</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-owide</span></span><br><span class="line"><span class="string">NAME</span>                                 <span class="string">...</span>   <span class="string">NODE</span>               <span class="string">NOMINATED</span> <span class="string">NODE</span>   <span class="string">...</span></span><br><span class="line"><span class="string">collector1-7585cc58cb-n5rtd</span>   <span class="number">1</span><span class="string">/1</span>    <span class="string">...</span>   <span class="string">cluster1-worker1</span>   <span class="string">&lt;none&gt;</span>           <span class="string">...</span></span><br><span class="line"><span class="string">collector1-7585cc58cb-vdlp9</span>   <span class="number">1</span><span class="string">/1</span>    <span class="string">...</span>   <span class="string">cluster1-worker1</span>   <span class="string">&lt;none&gt;</span>           <span class="string">...</span></span><br><span class="line"><span class="string">collector2-8556679d96-z7g7c</span>   <span class="number">1</span><span class="string">/1</span>    <span class="string">...</span>   <span class="string">cluster1-worker1</span>   <span class="string">&lt;none&gt;</span>           <span class="string">...</span></span><br><span class="line"><span class="string">collector3-8b58fdc88-pjg24</span>    <span class="number">1</span><span class="string">/1</span>    <span class="string">...</span>   <span class="string">cluster1-worker1</span>   <span class="string">&lt;none&gt;</span>           <span class="string">...</span></span><br><span class="line"><span class="string">collector3-8b58fdc88-s9ltc</span>    <span class="number">1</span><span class="string">/1</span>    <span class="string">...</span>   <span class="string">cluster1-worker1</span>   <span class="string">&lt;none&gt;</span>           <span class="string">...</span></span><br><span class="line"><span class="comment"># 登录主机</span></span><br><span class="line"><span class="string">ssh</span> <span class="string">cluster1-worker1</span></span><br><span class="line"><span class="string">crictl</span> <span class="string">pods</span> <span class="string">ls</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">collector1</span></span><br><span class="line"><span class="string">POD</span> <span class="string">ID</span>              <span class="string">CREATED</span>             <span class="string">STATE</span>        <span class="string">NAME</span>                          <span class="string">...</span></span><br><span class="line"><span class="string">21aacb8f4ca8d</span>       <span class="number">17</span> <span class="string">minutes</span> <span class="string">ago</span>      <span class="string">Ready</span>        <span class="string">collector1-7585cc58cb-vdlp9</span>   <span class="string">...</span></span><br><span class="line"><span class="string">186631e40104d</span>       <span class="number">17</span> <span class="string">minutes</span> <span class="string">ago</span>      <span class="string">Ready</span>        <span class="string">collector1-7585cc58cb-n5rtd</span>   <span class="string">...</span></span><br><span class="line"><span class="string">crictl</span> <span class="string">ps</span>  <span class="string">|</span> <span class="string">grep</span> <span class="string">21aacb8f4ca8d</span></span><br><span class="line"><span class="string">CONTAINER</span> <span class="string">ID</span>        <span class="string">IMAGE</span>               <span class="string">CREATED</span>          <span class="string">...</span>       <span class="string">POD</span> <span class="string">ID</span></span><br><span class="line"><span class="string">9ea02422f8660</span>       <span class="string">5d867958e04e1</span>       <span class="number">12</span> <span class="string">minutes</span> <span class="string">ago</span>   <span class="string">...</span>       <span class="string">21aacb8f4ca8d</span></span><br><span class="line"><span class="comment"># crictl 查看具体的程序名，或可以找到PID</span></span><br><span class="line"><span class="string">crictl</span> <span class="string">inspect</span> <span class="string">9ea02422f8660</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">args</span> <span class="string">-A1</span></span><br><span class="line">        <span class="attr">&quot;args&quot;:</span> [</span><br><span class="line">          <span class="string">&quot;./collector1-process&quot;</span></span><br><span class="line"><span class="comment"># ps 过滤进程PID</span></span><br><span class="line"><span class="string">ps</span> <span class="string">aux</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">collector1-process</span></span><br><span class="line"><span class="string">root</span>       <span class="number">35039</span>  <span class="number">0.0</span>  <span class="number">0.1</span> <span class="number">702208</span>  <span class="number">1044</span> <span class="string">?</span>        <span class="string">Ssl</span>  <span class="number">13</span><span class="string">:37</span>   <span class="number">0</span><span class="string">:00</span> <span class="string">./collector1-process</span></span><br><span class="line"><span class="string">root</span>       <span class="number">35059</span>  <span class="number">0.0</span>  <span class="number">0.1</span> <span class="number">702208</span>  <span class="number">1044</span> <span class="string">?</span>        <span class="string">Ssl</span>  <span class="number">13</span><span class="string">:37</span>   <span class="number">0</span><span class="string">:00</span> <span class="string">./collector1-process</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用strace 查看调用</span></span><br><span class="line"><span class="attr">strace:</span> <span class="string">Process</span> <span class="number">35039</span> <span class="string">attached</span></span><br><span class="line"><span class="string">futex(0x4d7e68</span>, <span class="string">FUTEX_WAIT_PRIVATE</span>, <span class="number">0</span>, <span class="literal">NULL</span><span class="string">)</span> <span class="string">=</span> <span class="number">0</span></span><br><span class="line"><span class="string">kill(666</span>, <span class="string">SIGTERM)</span>                      <span class="string">=</span> <span class="number">-1</span> <span class="string">ESRCH</span> <span class="string">(No</span> <span class="string">such</span> <span class="string">process)</span></span><br><span class="line"><span class="string">epoll_pwait(3</span>, [], <span class="number">128</span>, <span class="number">999</span>, <span class="literal">NULL</span>, <span class="number">1</span><span class="string">)</span>   <span class="string">=</span> <span class="number">0</span></span><br><span class="line"><span class="string">kill(666</span>, <span class="string">SIGTERM)</span>                      <span class="string">=</span> <span class="number">-1</span> <span class="string">ESRCH</span> <span class="string">(No</span> <span class="string">such</span> <span class="string">process)</span></span><br><span class="line"><span class="string">epoll_pwait(3</span>, [], <span class="number">128</span>, <span class="number">999</span>, <span class="literal">NULL</span>, <span class="number">1</span><span class="string">)</span>   <span class="string">=</span> <span class="number">0</span></span><br><span class="line"><span class="string">kill(666</span>, <span class="string">SIGTERM)</span>                      <span class="string">=</span> <span class="number">-1</span> <span class="string">ESRCH</span> <span class="string">(No</span> <span class="string">such</span> <span class="string">process)</span></span><br><span class="line"><span class="string">epoll_pwait(3</span>, <span class="string">^Cstrace:</span> <span class="string">Process</span> <span class="number">35039</span> <span class="string">detached</span></span><br><span class="line"> <span class="string">&lt;detached</span> <span class="string">...&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># 可以看到 kill(666, SIGTERM)  所以collector1有违规系统调用</span></span><br><span class="line"><span class="comment"># 同样的方式检测 collector2、collector3，只发现collector1存在，所以副本调0</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">-n</span> <span class="string">team-yellow</span> <span class="string">scale</span> <span class="string">deploy</span> <span class="string">collector1</span> <span class="string">--replicas</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="Question-15-Configure-TLS-on-Ingress"><a href="#Question-15-Configure-TLS-on-Ingress" class="headerlink" title="Question 15 | Configure TLS on Ingress"></a><strong><strong>Question 15 | Configure TLS on Ingress</strong></strong></h2><blockquote>
<p><em>Task weight: 4%</em></p>
</blockquote>
<p>In <em>Namespace</em> <code>team-pink</code> there is an existing Nginx <em>Ingress</em> resources named <code>secure</code> which accepts two paths <code>/app</code> and <code>/api</code> which point to different ClusterIP  <em>Services</em> .</p>
<p>From your main terminal you can connect to it using for example:</p>
<ul>
<li>HTTP: <code>curl -v &lt;http://secure-ingress.test:31080/app</code>&gt;</li>
<li>HTTPS: <code>curl -kv &lt;https://secure-ingress.test:31443/app</code>&gt;</li>
</ul>
<p>Right now it uses a default generated TLS certificate by the Nginx Ingress Controller.</p>
<p>You’re asked to instead use the key and certificate provided at <code>/opt/course/15/tls.key</code> and <code>/opt/course/15/tls.crt</code>. As it’s a self-signed certificate you need to use <code>curl -k</code> when connecting to it.</p>
<p>参考</p>
<blockquote>
<p><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">ingress配置</a>，里面的TLS配置</p>
</blockquote>
<p>解答</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这道题很简单，主要是想考nginx-ingress SSL证书配置</span></span><br><span class="line"><span class="comment"># 首先使用题目给的证书创建一个secret秘钥</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">-n</span> <span class="string">team-pink</span> <span class="string">create</span> <span class="string">secret</span> <span class="string">tls</span> <span class="string">tls-secret</span> <span class="string">--key</span> <span class="string">tls.key</span> <span class="string">--cert</span> <span class="string">tls.crt</span></span><br><span class="line"><span class="string">secret/tls-secret</span> <span class="string">created</span></span><br><span class="line"><span class="comment"># 查看ingress配置</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">-n</span> <span class="string">team-pink</span> <span class="string">edit</span> <span class="string">ing</span> <span class="string">secure</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secure</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">team-pink</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span>                            <span class="comment"># 增加</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span>                      <span class="comment"># 增加</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secure-ingress.test</span>       <span class="comment"># 增加</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-secret</span>      <span class="comment"># 增加</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">secure-ingress.test</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">secure-app</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/app</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">ImplementationSpecific</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">secure-api</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/api</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">ImplementationSpecific</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试验证</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">-n</span> <span class="string">team-pink</span> <span class="string">get</span> <span class="string">ing</span></span><br><span class="line"><span class="string">NAME</span>     <span class="string">CLASS</span>    <span class="string">HOSTS</span>                 <span class="string">ADDRESS</span>          <span class="string">PORTS</span>     <span class="string">AGE</span></span><br><span class="line"><span class="string">secure</span>   <span class="string">&lt;none&gt;</span>   <span class="string">secure-ingress.test</span>   <span class="number">192.168</span><span class="number">.100</span><span class="number">.12</span>   <span class="number">80</span><span class="string">,</span> <span class="number">443</span>   <span class="string">25m</span></span><br><span class="line"><span class="string">curl</span> <span class="string">-k</span> <span class="string">&lt;https://secure-ingress.test:31443/api&gt;</span></span><br><span class="line"><span class="string">curl</span> <span class="string">-kv</span> <span class="string">&lt;https://secure-ingress.test:31443/api&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">*</span> <span class="attr">Server certificate:</span></span><br><span class="line"><span class="string">*</span>  <span class="attr">subject:</span> <span class="string">CN=secure-ingress.test;</span> <span class="string">O=secure-ingress.test</span></span><br><span class="line"><span class="string">*</span>  <span class="attr">start date:</span> <span class="string">Sep</span> <span class="number">25</span> <span class="number">18</span><span class="string">:22:10</span> <span class="number">2020 </span><span class="string">GMT</span></span><br><span class="line"><span class="string">*</span>  <span class="attr">expire date:</span> <span class="string">Sep</span> <span class="number">20</span> <span class="number">18</span><span class="string">:22:10</span> <span class="number">2040 </span><span class="string">GMT</span></span><br><span class="line"><span class="string">*</span>  <span class="attr">issuer:</span> <span class="string">CN=secure-ingress.test;</span> <span class="string">O=secure-ingress.test</span></span><br><span class="line"><span class="string">*</span>  <span class="attr">SSL certificate verify result:</span> <span class="string">self</span> <span class="string">signed</span> <span class="string">certificate</span> <span class="string">(18),</span> <span class="string">continuing</span> <span class="string">anyway.</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Question-16-Docker-Image-Attack-Surface"><a href="#Question-16-Docker-Image-Attack-Surface" class="headerlink" title="Question 16 | Docker Image Attack Surface"></a><strong><strong>Question 16 | Docker Image Attack Surface</strong></strong></h2><blockquote>
<p><em>Task weight: 7%</em></p>
</blockquote>
<p>There is a <em>Deployment</em> <code>image-verify</code> in <em>Namespace</em> <code>team-blue</code> which runs image <code>registry.killer.sh:5000/image-verify:v1</code>. DevSecOps has asked you to improve this image by:</p>
<ol>
<li>Changing the base image to <code>alpine:3.12</code></li>
<li>Not installing <code>curl</code></li>
<li>Updating <code>nginx</code> to use the version constraint <code>&gt;=1.18.0</code></li>
<li>Running the main process as user <code>myuser</code></li>
</ol>
<p><strong>Do not</strong> add any new lines to the Dockerfile, just edit existing ones. The file is located at <code>/opt/course/16/image/Dockerfile</code>.</p>
<p>Tag your version as <code>v2</code>. You can build, tag and push using:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/course/16/imagepodman build -t registry.killer.sh:5000/image-verify:v2 .podman run registry.killer.sh:5000/image-verify:v2 <span class="comment"># to test your changespodman push registry.killer.sh:5000/image-verify:v2</span></span><br></pre></td></tr></table></figure>

<p>Make the <em>Deployment</em> use your updated image tag <code>v2</code>.</p>
<p>解答</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按要求修改基础镜像</span></span><br><span class="line"><span class="comment"># /opt/course/16/image/Dockerfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改基础镜像版本</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">alpine:3.12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改nginx版本</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">apk</span> <span class="string">update</span> <span class="string">&amp;&amp;</span> <span class="string">apk</span> <span class="string">add</span> <span class="string">vim</span> <span class="string">nginx&gt;=1.18.0</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">addgroup</span> <span class="string">-S</span> <span class="string">myuser</span> <span class="string">&amp;&amp;</span> <span class="string">adduser</span> <span class="string">-S</span> <span class="string">myuser</span> <span class="string">-G</span> <span class="string">myuser</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">./run.sh</span> <span class="string">run.sh</span></span><br><span class="line"><span class="string">RUN</span> [<span class="string">&quot;chmod&quot;</span>, <span class="string">&quot;+x&quot;</span>, <span class="string">&quot;./run.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行进程的用户</span></span><br><span class="line"><span class="string">USER</span> <span class="string">myuser</span></span><br><span class="line"></span><br><span class="line"><span class="string">ENTRYPOINT</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;./run.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后的镜像，测试并push</span></span><br><span class="line"><span class="string">podman</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">registry.killer.sh:5000/image-verify:v2</span> <span class="string">.</span></span><br><span class="line"><span class="string">podman</span> <span class="string">push</span> <span class="string">registry.killer.sh:5000/image-verify:v2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改deployment中镜像名称</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">-n</span> <span class="string">team-blue</span> <span class="string">edit</span> <span class="string">deploy</span> <span class="string">image-verify</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">registry.killer.sh:5000/image-verify:v2</span> <span class="comment"># 修改镜像</span></span><br></pre></td></tr></table></figure>

<h2 id="Question-17-Audit-Log-Policy"><a href="#Question-17-Audit-Log-Policy" class="headerlink" title="Question 17 | Audit Log Policy"></a><strong><strong>Question 17 | Audit Log Policy</strong></strong></h2><blockquote>
<p><em>Task weight: 7%</em></p>
</blockquote>
<p>Audit Logging has been enabled in the cluster with an Audit <em>Policy</em> located at <code>/etc/kubernetes/audit/policy.yaml</code> on <code>cluster2-master1</code>.</p>
<p>Change the configuration so that only one backup of the logs is stored.</p>
<p>Alter the <em>Policy</em> in a way that it only stores logs:</p>
<ol>
<li>From <em>Secret</em> resources, level Metadata</li>
<li>From “system:nodes” userGroups, level RequestResponse</li>
</ol>
<p>After you altered the <em>Policy</em> make sure to empty the log file so it only contains entries according to your changes, like using <code>truncate -s 0 /etc/kubernetes/audit/logs/audit.log</code>.</p>
<blockquote>
<p>NOTE: You can use jq to render json more readable. cat data.json | jq</p>
</blockquote>
<p>参考</p>
<blockquote>
<p><a href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/audit/">审计</a></p>
</blockquote>
<p>解答</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这道题主要是修改审计配置,并保存审计日志</span></span><br><span class="line"><span class="comment"># 1.修改API审计配置保存最大备份数为1</span></span><br><span class="line"><span class="string">vim</span> <span class="string">/etc/kubernetes/manifests/kube-apiserver.yaml</span></span><br><span class="line"><span class="comment"># /etc/kubernetes/manifests/kube-apiserver.yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubeadm.kubernetes.io/kube-apiserver.advertise-address.endpoint:</span> <span class="number">192.168</span><span class="number">.100</span><span class="number">.21</span><span class="string">:6443</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">kube-apiserver</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">control-plane</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-apiserver</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kube-apiserver</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--audit-policy-file=/etc/kubernetes/audit/policy.yaml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--audit-log-path=/etc/kubernetes/audit/logs/audit.log</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--audit-log-maxsize=5</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--audit-log-maxbackup=1</span>                                    <span class="comment"># 修改</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--advertise-address=192.168.100.21</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--allow-privileged=true</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="comment"># 2.修改审计的policy配置文件</span></span><br><span class="line"><span class="comment"># /etc/kubernetes/audit/policy.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">audit.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Policy</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只记录secrets Metadata级别的日志</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">level:</span> <span class="string">Metadata</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">group:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只记录node用户组的RequestResponse日志</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">level:</span> <span class="string">RequestResponse</span></span><br><span class="line">  <span class="attr">userGroups:</span> [<span class="string">&quot;system:nodes&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了以上记录的日志其他日志均不记录</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">level:</span> <span class="string">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.保存好配置之后，清空日志，只保存修改配置以后的日志。</span></span><br><span class="line"><span class="string">cd</span> <span class="string">/etc/kubernetes/manifests/</span></span><br><span class="line"><span class="comment"># 先删除kube-apiserver的静态pod</span></span><br><span class="line"><span class="string">mv</span> <span class="string">kube-apiserver.yaml</span> <span class="string">..</span></span><br><span class="line"><span class="string">crictl</span> <span class="string">ps</span></span><br><span class="line"><span class="comment"># 清空日志</span></span><br><span class="line"><span class="string">truncate</span> <span class="string">-s</span> <span class="number">0</span> <span class="string">/etc/kubernetes/audit/logs/audit.log</span></span><br><span class="line"><span class="comment"># 再还原kube-apiserver配置</span></span><br><span class="line"><span class="comment"># 测试验证日志是否符合预期</span></span><br><span class="line"><span class="string">cat</span> <span class="string">audit.log</span> <span class="string">|</span> <span class="string">tail</span> <span class="string">|</span> <span class="string">jq</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<h2 id="Question-18-Investigate-Break-in-via-Audit-Log"><a href="#Question-18-Investigate-Break-in-via-Audit-Log" class="headerlink" title="Question 18 | Investigate Break-in via Audit Log"></a><strong><strong>Question 18 | Investigate Break-in via Audit Log</strong></strong></h2><blockquote>
<p><em>Task weight: 4%</em></p>
</blockquote>
<p><em>Namespace</em> <code>security</code> contains five <em>Secrets</em> of type Opaque which can be considered highly confidential. The latest Incident-Prevention-Investigation revealed that <em>ServiceAccount</em> <code>p.auster</code> had too broad access to the cluster for some time. This <em>SA</em> should’ve never had access to any <em>Secrets</em> in that  <em>Namespace</em> .</p>
<p>Find out which <em>Secrets</em> in <em>Namespace</em> <code>security</code> this <em>SA</em> did access by looking at the Audit Logs under <code>/opt/course/18/audit.log</code>.</p>
<p>Change the password to any new string of only those <em>Secrets</em> that were accessed by this  <em>SA</em> .</p>
<blockquote>
<p>NOTE: You can use jq to render json more readable. cat data.json | jq</p>
</blockquote>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该题目主要就是查找p.auster SA访问了哪些secret，并修改对应的secret密码</span></span><br><span class="line"><span class="comment"># 获取security下的secret</span></span><br><span class="line">kubectl -n security get secret | grep Opaque</span><br><span class="line">kubeadmin-token       Opaque                                1      37m</span><br><span class="line">mysql-admin           Opaque                                1      37m</span><br><span class="line">postgres001           Opaque                                1      37m</span><br><span class="line">postgres002           Opaque                                1      37m</span><br><span class="line">vault-token           Opaque                                1      37m</span><br><span class="line"><span class="comment"># 过滤p.auster 用户访问的Secret资源</span></span><br><span class="line">cat /opt/course/18/audit.log | grep <span class="string">&quot;p.auster&quot;</span> | grep Secret | wc -l</span><br><span class="line">2</span><br><span class="line"><span class="comment"># jq解析日志,可以看到p.auster SA访问了vault-token、mysql-admin 2个secret</span></span><br><span class="line">cat audit.log | grep <span class="string">&quot;p.auster&quot;</span> | grep Secret | grep get | jq</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Event&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;audit.k8s.io/v1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;level&quot;</span>: <span class="string">&quot;RequestResponse&quot;</span>,</span><br><span class="line">  <span class="string">&quot;auditID&quot;</span>: <span class="string">&quot;74fd9e03-abea-4df1-b3d0-9cfeff9ad97a&quot;</span>,</span><br><span class="line">  <span class="string">&quot;stage&quot;</span>: <span class="string">&quot;ResponseComplete&quot;</span>,</span><br><span class="line">  <span class="string">&quot;requestURI&quot;</span>: <span class="string">&quot;/api/v1/namespaces/security/secrets/vault-token&quot;</span>,</span><br><span class="line">  <span class="string">&quot;verb&quot;</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;system:serviceaccount:security:p.auster&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: <span class="string">&quot;29ecb107-c0e8-4f2d-816a-b16f4391999c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;groups&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;system:serviceaccounts&quot;</span>,</span><br><span class="line">      <span class="string">&quot;system:serviceaccounts:security&quot;</span>,</span><br><span class="line">      <span class="string">&quot;system:authenticated&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">  <span class="string">&quot;userAgent&quot;</span>: <span class="string">&quot;curl/7.64.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;objectRef&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;resource&quot;</span>: <span class="string">&quot;secrets&quot;</span>,</span><br><span class="line">    <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;security&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;vault-token&quot;</span>,</span><br><span class="line">    <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Event&quot;</span>,</span><br><span class="line">  <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;audit.k8s.io/v1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;level&quot;</span>: <span class="string">&quot;RequestResponse&quot;</span>,</span><br><span class="line">  <span class="string">&quot;auditID&quot;</span>: <span class="string">&quot;aed6caf9-5af0-4872-8f09-ad55974bb5e0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;stage&quot;</span>: <span class="string">&quot;ResponseComplete&quot;</span>,</span><br><span class="line">  <span class="string">&quot;requestURI&quot;</span>: <span class="string">&quot;/api/v1/namespaces/security/secrets/mysql-admin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;verb&quot;</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;system:serviceaccount:security:p.auster&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uid&quot;</span>: <span class="string">&quot;29ecb107-c0e8-4f2d-816a-b16f4391999c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;groups&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;system:serviceaccounts&quot;</span>,</span><br><span class="line">      <span class="string">&quot;system:serviceaccounts:security&quot;</span>,</span><br><span class="line">      <span class="string">&quot;system:authenticated&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">  <span class="string">&quot;userAgent&quot;</span>: <span class="string">&quot;curl/7.64.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;objectRef&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;resource&quot;</span>: <span class="string">&quot;secrets&quot;</span>,</span><br><span class="line">    <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;security&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;mysql-admin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改vault-token、mysql-admin的secret密码</span></span><br><span class="line"><span class="built_in">echo</span> new-vault-pass | base64</span><br><span class="line">bmV3LXZhdWx0LXBhc3MK</span><br><span class="line"></span><br><span class="line">kubectl -n security edit secret vault-token</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> new-mysql-pass | base64</span><br><span class="line">bmV3LW15c3FsLXBhc3MK</span><br><span class="line"></span><br><span class="line">kubectl -n security edit secret mysql-admin</span><br></pre></td></tr></table></figure>

<h2 id="Question-19-Immutable-Root-FileSystem"><a href="#Question-19-Immutable-Root-FileSystem" class="headerlink" title="Question 19 | Immutable Root FileSystem"></a><strong><strong>Question 19 | Immutable Root FileSystem</strong></strong></h2><blockquote>
<p><em>Task weight: 2%</em></p>
</blockquote>
<p>The <em>Deployment</em> <code>immutable-deployment</code> in <em>Namespace</em> <code>team-purple</code> should run immutable, it’s created from file <code>/opt/course/19/immutable-deployment.yaml</code>. Even after a successful break-in, it shouldn’t be possible for an attacker to modify the filesystem of the running container.</p>
<p>Modify the <em>Deployment</em> in a way that no processes inside the container can modify the local filesystem, only <code>/tmp</code> directory should be writeable. Don’t modify the Docker image.</p>
<p>Save the updated YAML under <code>/opt/course/19/immutable-deployment-new.yaml</code> and update the running  <em>Deployment</em> .</p>
<p>参考：</p>
<blockquote>
<p><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/">容器pod安全上下文</a></p>
</blockquote>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认情况下，容器中的进程可以写入本地文件系统。当非恶意进程被劫持时，</span></span><br><span class="line"><span class="comment"># 这会增加攻击面。阻止应用程序写入磁盘或只允许某些目录可以降低风险。</span></span><br><span class="line"><span class="comment"># 可以在 Docker 镜像本身或 Pod 声明中将根文件系统设置为只读</span></span><br><span class="line"><span class="comment"># /opt/course/19/immutable-deployment-new.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  namespace: team-purple</span><br><span class="line">  name: immutable-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: immutable-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: immutable-deployment</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: immutable-deployment</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: busybox:1.32.0</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;tail -f /dev/null&#x27;</span>]</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        name: busybox</span><br><span class="line">        securityContext:                  <span class="comment"># add</span></span><br><span class="line">          readOnlyRootFilesystem: <span class="literal">true</span>    <span class="comment"># add</span></span><br><span class="line">        volumeMounts:                     <span class="comment"># add</span></span><br><span class="line">        - mountPath: /tmp                 <span class="comment"># add</span></span><br><span class="line">          name: temp-vol                  <span class="comment"># add</span></span><br><span class="line">      volumes:                            <span class="comment"># add</span></span><br><span class="line">      - name: temp-vol                    <span class="comment"># add</span></span><br><span class="line">        emptyDir: &#123;&#125;                      <span class="comment"># add</span></span><br><span class="line">      restartPolicy: Always</span><br><span class="line"><span class="comment"># 应用</span></span><br><span class="line">kubectl apply -f /opt/course/19/immutable-deployment-new.yaml</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">kubectl -n team-purple <span class="built_in">exec</span> immutable-deployment-5b7ff8d464-j2nrj -- touch /abc.txt</span><br><span class="line">touch: /abc.txt: Read-only file system</span><br><span class="line"><span class="built_in">command</span> terminated with <span class="built_in">exit</span> code 1</span><br><span class="line">kubectl -n team-purple <span class="built_in">exec</span> immutable-deployment-5b7ff8d464-j2nrj -- touch /tmp/abc.txt</span><br></pre></td></tr></table></figure>

<h2 id="Question-20-Update-Kubernetes"><a href="#Question-20-Update-Kubernetes" class="headerlink" title="Question 20 | Update Kubernetes"></a><strong><strong>Question 20 | Update Kubernetes</strong></strong></h2><blockquote>
<p><em>Task weight: 8%</em></p>
</blockquote>
<p>The cluster is running Kubernetes <code>1.22.4</code>, update it to <code>1.23.1</code>.</p>
<p>Use <code>apt</code> package manager and <code>kubeadm</code> for this.</p>
<p>Use <code>ssh cluster3-master1</code> and <code>ssh cluster3-worker1</code> to connect to the instances.</p>
<p>参考</p>
<blockquote>
<p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">kubeadm upgrade 升级</a></p>
</blockquote>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升级集群，参考官方文档即可。</span></span><br><span class="line"><span class="comment"># 一台驱逐后升级后再做另一台</span></span><br><span class="line">kubectl get node</span><br><span class="line">NAME               STATUS   ROLES                  AGE   VERSION</span><br><span class="line">cluster3-master1   Ready    control-plane,master   58m   v1.22.4</span><br><span class="line">cluster3-worker1   Ready    &lt;none&gt;                 54m   v1.22.4</span><br><span class="line"><span class="comment"># 1.登录机器</span></span><br><span class="line">ssh cluster3-master1 </span><br><span class="line">kubectl drain cluster3-master1 --ignore-daemonsets</span><br><span class="line"><span class="comment"># 2.升级kubelet （replace x in 1.23.x-00 with the latest patch version）</span></span><br><span class="line">apt-mark unhold kubelet kubectl &amp;&amp; \\</span><br><span class="line">apt-get update &amp;&amp; apt-get install -y kubelet=1.23.1-00 kubectl=1.23.1-00 &amp;&amp; \\</span><br><span class="line">apt-mark hold kubelet kubectl</span><br><span class="line"><span class="comment"># 3.重启kubelet</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart kubelet</span><br><span class="line"><span class="comment"># 4.开启调度</span></span><br><span class="line">kubectl uncordon cluster3-master1</span><br><span class="line"><span class="comment"># 另一台操作步骤重复如上步骤（1、2、3、4）</span></span><br></pre></td></tr></table></figure>

<h2 id="Question-21-Image-Vulnerability-Scanning"><a href="#Question-21-Image-Vulnerability-Scanning" class="headerlink" title="Question 21 | Image Vulnerability Scanning"></a><strong><strong>Question 21 | Image Vulnerability Scanning</strong></strong></h2><blockquote>
<p><em>Task weight: 2%</em></p>
</blockquote>
<p>The Vulnerability Scanner <code>trivy</code> is installed on your main terminal. Use it to scan the following images for known CVEs:</p>
<ul>
<li><code>nginx:1.16.1-alpine</code></li>
<li><code>k8s.gcr.io/kube-apiserver:v1.18.0</code></li>
<li><code>k8s.gcr.io/kube-controller-manager:v1.18.0</code></li>
<li><code>docker.io/weaveworks/weave-kube:2.7.0</code></li>
</ul>
<p>Write all images that don’t contain the vulnerabilities <code>CVE-2020-10878</code> or <code>CVE-2020-1967</code> into <code>/opt/course/21/good-images</code>.</p>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过执行trivy命令获取CVE漏洞（CVE-2020-10878、CVE-2020-1967）,将不存在漏洞的镜像写入/opt/course/21/good-images</span></span><br><span class="line">trivy nginx:1.16.1-alpine | grep -E <span class="string">&#x27;CVE-2020-10878|CVE-2020-1967&#x27;</span></span><br><span class="line">| libcrypto1.1  | CVE-2020-1967    | MEDIUM   </span><br><span class="line">| libssl1.1     | CVE-2020-1967    |</span><br><span class="line">trivy k8s.gcr.io/kube-apiserver:v1.18.0 | grep -E <span class="string">&#x27;CVE-2020-10878|CVE-2020-1967&#x27;</span></span><br><span class="line">| perl-base     | CVE-2020-10878      | HIGH</span><br><span class="line">trivy k8s.gcr.io/kube-controller-manager:v1.18.0 | grep -E <span class="string">&#x27;CVE-2020-10878|CVE-2020-1967&#x27;</span></span><br><span class="line">| perl-base     | CVE-2020-10878      | HIGH</span><br><span class="line">trivy docker.io/weaveworks/weave-kube:2.7.0 | grep -E <span class="string">&#x27;CVE-2020-10878|CVE-2020-1967&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;docker.io/weaveworks/weave-kube:2.7.0&#x27;</span> &gt; /opt/course/21/good-images</span><br></pre></td></tr></table></figure>

<h2 id="Question-22-Manual-Static-Security-Analysis"><a href="#Question-22-Manual-Static-Security-Analysis" class="headerlink" title="Question 22 | Manual Static Security Analysis"></a><strong><strong>Question 22 | Manual Static Security Analysis</strong></strong></h2><blockquote>
<p><em>Task weight: 3%</em></p>
</blockquote>
<p>The Release Engineering Team has shared some YAML manifests and Dockerfiles with you to review. The files are located under <code>/opt/course/22/files</code>.</p>
<p>As a container security expert, you are asked to perform a manual static analysis and find out possible security issues with respect to unwanted credential exposure. Running processes as root is of no concern in this task.</p>
<p>Write the filenames which have issues into <code>/opt/course/22/security-issues</code>.</p>
<blockquote>
<p>NOTE: In the Dockerfile and YAML manifests, assume that the referred files, folders, secrets and volume mounts are present. Disregard syntax or logic errors.</p>
</blockquote>
<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该问题，主要就是分析清单中的文件是否存在安全风险，并将风险的文件写入到/opt/course/22/security-issues</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ls -la /opt/course/22/files</span></span><br><span class="line">total 48</span><br><span class="line">drwxr-xr-x 2 k8s k8s 4096 Sep 16 19:08 .</span><br><span class="line">drwxr-xr-x 3 k8s k8s 4096 Sep 16 19:08 ..</span><br><span class="line">-rw-r--r-- 1 k8s k8s  692 Sep 16 19:08 Dockerfile-go</span><br><span class="line">-rw-r--r-- 1 k8s k8s  897 Sep 16 19:08 Dockerfile-mysql</span><br><span class="line">-rw-r--r-- 1 k8s k8s  743 Sep 16 19:08 Dockerfile-py</span><br><span class="line">-rw-r--r-- 1 k8s k8s  341 Sep 16 19:08 deployment-nginx.yaml</span><br><span class="line">-rw-r--r-- 1 k8s k8s  705 Sep 16 19:08 deployment-redis.yaml</span><br><span class="line">-rw-r--r-- 1 k8s k8s  392 Sep 16 19:08 pod-nginx.yaml</span><br><span class="line">-rw-r--r-- 1 k8s k8s  228 Sep 16 19:08 pv-manual.yaml</span><br><span class="line">-rw-r--r-- 1 k8s k8s  188 Sep 16 19:08 pvc-manual.yaml</span><br><span class="line">-rw-r--r-- 1 k8s k8s  211 Sep 16 19:08 sc-local.yaml</span><br><span class="line">-rw-r--r-- 1 k8s k8s  902 Sep 16 19:08 statefulset-nginx.yaml</span><br><span class="line"><span class="comment"># 第一个文件，在X层复制，在Y层引用，Z层删除，看似正常，每个层都保留在映像中，即便删除它仍然包含在 X 层和 Y 层的图像中</span></span><br><span class="line">/opt/course/22/files/Dockerfile-mysql</span><br><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add MySQL configuration</span></span><br><span class="line">COPY my.cnf /etc/mysql/conf.d/my.cnf</span><br><span class="line">COPY mysqld_charset.cnf /etc/mysql/conf.d/mysqld_charset.cnf</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; \\</span><br><span class="line">    apt-get -yq install mysql-server-5.6 &amp;&amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add MySQL scripts</span></span><br><span class="line">COPY import_sql.sh /import_sql.sh</span><br><span class="line">COPY run.sh /run.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure credentials</span></span><br><span class="line">COPY secret-token .                                       <span class="comment"># LAYER X</span></span><br><span class="line">RUN /etc/register.sh ./secret-token                       <span class="comment"># LAYER Y</span></span><br><span class="line">RUN rm ./secret-token <span class="comment"># delete secret token again         # LATER Z</span></span><br><span class="line"></span><br><span class="line">EXPOSE 3306</span><br><span class="line">CMD [<span class="string">&quot;/run.sh&quot;</span>]</span><br><span class="line"><span class="comment"># echo Dockerfile-mysql &gt;&gt; /opt/course/22/security-issues</span></span><br><span class="line"><span class="comment"># 第二个文件，文件 deployment-redis.yaml 正在从名为 mysecret 的 Secret 中获取凭证并将其写入环境变量。</span></span><br><span class="line"><span class="comment"># /opt/course/22/files/deployment-redis.yaml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: mycontainer</span><br><span class="line">        image: redis</span><br><span class="line">        <span class="built_in">command</span>: [<span class="string">&quot;/bin/sh&quot;</span>]</span><br><span class="line">        args:</span><br><span class="line">        - <span class="string">&quot;-c&quot;</span></span><br><span class="line">        - <span class="string">&quot;echo <span class="variable">$SECRET_USERNAME</span> &amp;&amp; echo <span class="variable">$SECRET_PASSWORD</span> &amp;&amp; docker-entrypoint.sh&quot;</span> <span class="comment"># NOT GOOD</span></span><br><span class="line">        env:</span><br><span class="line">        - name: SECRET_USERNAME</span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: mysecret</span><br><span class="line">              key: username</span><br><span class="line">        - name: SECRET_PASSWORD</span><br><span class="line">          valueFrom:</span><br><span class="line">            secretKeyRef:</span><br><span class="line">              name: mysecret</span><br><span class="line">              key: password</span><br><span class="line"><span class="comment"># echo deployment-redis.yaml &gt;&gt; /opt/course/22/security-issues</span></span><br><span class="line"><span class="comment"># 第三个存在风险的文件如下，密码明文。</span></span><br><span class="line"><span class="comment"># /opt/course/22/files/statefulset-nginx.yaml</span></span><br><span class="line">...</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: StatefulSet</span><br><span class="line">metadata:</span><br><span class="line">  name: web</span><br><span class="line">spec:</span><br><span class="line">  serviceName: <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: k8s.gcr.io/nginx-slim:0.8</span><br><span class="line">        env:</span><br><span class="line">        - name: Username</span><br><span class="line">          value: Administrator</span><br><span class="line">        - name: Password</span><br><span class="line">          value: MyDiReCtP@sSw0rd               <span class="comment"># NOT GOOD</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">          name: web</span><br><span class="line">..</span><br><span class="line"><span class="comment"># echo statefulset-nginx.yaml &gt;&gt; /opt/course/22/security-issues</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装基于BPF的bcc-tools系统性能工具库</title>
    <url>/posts/f49f425d/</url>
    <content><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>OS版本：CentOS7.6.1810</li>
<li>内核版本：5.4.207-1.el7.elrepo.x86_64</li>
<li>依赖包：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#内核依赖包</span></span><br><span class="line">rpm -qa | grep kernel-lt</span><br><span class="line">kernel-lt-tools-5.4.207-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-tools-libs-5.4.207-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-devel-5.4.207-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-5.4.207-1.el7.elrepo.x86_64</span><br><span class="line">kernel-lt-headers-5.4.207-1.el7.elrepo.x86_64</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>内核必须升级到4.x版本以上，才可以使用。我的内核版本已经升级过，具体升级内核过程这里不展开，建议使用<a href="http://elrepo.org/tiki/HomePage">elrepo</a> 安装高版本内核。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装bcc-tools</span></span><br><span class="line">yum install -y bcc-tools</span><br><span class="line"><span class="comment">#添加环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/share/bcc/tools</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment">#cachestat</span></span><br><span class="line">    HITS   MISSES  DIRTIES HITRATIO   BUFFERS_MB  CACHED_MB</span><br><span class="line">   11224        0        0  100.00%            1      61258</span><br><span class="line">   10865        0        0  100.00%            1      61259</span><br><span class="line">    5021        0        0  100.00%            1      61259</span><br><span class="line">    4403        0        0  100.00%            1      61259</span><br><span class="line">   12214        0        0  100.00%            1      61259</span><br><span class="line">   26951        0        0  100.00%            1      61259</span><br></pre></td></tr></table></figure>

<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><p>1、安装后执行命令报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cachestat</span></span><br><span class="line">modprobe: FATAL: Module kheaders not found.</span><br><span class="line"><span class="built_in">chdir</span>(/lib/modules/5.4.207-1.el7.elrepo.x86_64/build): No such file or directory</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/share/bcc/tools/cachestat&quot;</span>, line 96, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    b = BPF(text=bpf_text)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python2.7/site-packages/bcc/__init__.py&quot;</span>, line 325, <span class="keyword">in</span> __init__</span><br><span class="line">    raise Exception(<span class="string">&quot;Failed to compile BPF text&quot;</span>)</span><br><span class="line">Exception: Failed to compile BPF text</span><br></pre></td></tr></table></figure>

<p>原因是由于kernel-devel 版本不一致导致的，建议下载跟操作系统内核版本对齐。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以yum安装</span></span><br><span class="line">yum install <span class="string">&quot;kernel-devel-<span class="subst">$(uname -r)</span>&quot;</span></span><br><span class="line"><span class="comment"># 或者下载对应内核版本rpm包安装</span></span><br><span class="line"><span class="comment"># 下载地址：http://mirrors.coreix.net/elrepo-archive-archive/kernel/el7/x86_64/RPMS/</span></span><br><span class="line">rpm -ivh kernel-lt-devel-5.4.207-1.el7.elrepo.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>2、执行命令报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In file included from /virtual/main.c:2:</span><br><span class="line">In file included from /lib/modules/5.4.207-1.el7.elrepo.x86_64/build/include/uapi/linux/ptrace.h:143:</span><br><span class="line">In file included from /lib/modules/5.4.207-1.el7.elrepo.x86_64/build/arch/x86/include/asm/ptrace.h:5:</span><br><span class="line">/lib/modules/5.4.207-1.el7.elrepo.x86_64/build/arch/x86/include/asm/segment.h:266:2: error: expected <span class="string">&#x27;(&#x27;</span> after <span class="string">&#x27;asm&#x27;</span></span><br><span class="line">        alternative_io (<span class="string">&quot;lsl %[seg],%[p]&quot;</span>,</span><br><span class="line">        ^</span><br><span class="line">/lib/modules/5.4.207-1.el7.elrepo.x86_64/build/arch/x86/include/asm/alternative.h:240:2: note: expanded from macro <span class="string">&#x27;alternative_io&#x27;</span></span><br><span class="line">        asm_inline volatile (ALTERNATIVE(oldinstr, newinstr, feature)   \</span><br><span class="line">        ^</span><br><span class="line">/lib/modules/5.4.207-1.el7.elrepo.x86_64/build/include/linux/compiler_types.h:214:24: note: expanded from macro <span class="string">&#x27;asm_inline&#x27;</span></span><br><span class="line"><span class="comment">#define asm_inline asm __inline</span></span><br><span class="line">                       ^</span><br><span class="line">1 error generated.</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/usr/share/bcc/tools/cachestat&quot;</span>, line 96, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    b = BPF(text=bpf_text)</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python2.7/site-packages/bcc/__init__.py&quot;</span>, line 325, <span class="keyword">in</span> __init__</span><br><span class="line">    raise Exception(<span class="string">&quot;Failed to compile BPF text&quot;</span>)</span><br><span class="line">Exception: Failed to compile BPF text</span><br></pre></td></tr></table></figure>

<p>这个是由于内核版本的原因，kernel-5.4.X之后才会出现该问题。内核头文件中用 asm 替换 asm_inline即可，具体参考BCC官方<a href="https://github.com/iovisor/bcc/issues/2546">issues</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> vim /lib/modules/5.4.207-1.el7.elrepo.x86_64/build/arch/x86/include/asm/segment.h 在最上新增如下配置</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef asm_inline</span></span><br><span class="line"><span class="comment">#undef asm_inline</span></span><br><span class="line"><span class="comment">#define asm_inline asm</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bcc</tag>
        <tag>bpf</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础之结构体</title>
    <url>/posts/e21ef27/</url>
    <content><![CDATA[<p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
<h1 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h1><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p>
<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将MyInt定义为int类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>通过<code>type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名是<code>Go1.9</code>版本添加的新功能。</p>
<p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure>

<p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure>

<h2 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a>类型定义和类型别名的区别</h2><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a NewInt</span><br><span class="line">	<span class="keyword">var</span> b MyInt</span><br><span class="line">	</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p>
<p>Go语言中通过<code>struct</code>来实现面向对象。</p>
<h2 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h2><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，具体代码格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段类型：表示结构体字段的具体类型。</li>
</ul>
<p>举个例子，我们定义一个<code>Person</code>（人）结构体，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样类型的字段也可以写在一行，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	name, city <span class="keyword">string</span></span><br><span class="line">	age        <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就拥有了一个<code>person</code>的自定义类型，它有<code>name</code>、<code>city</code>、<code>age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p>
<p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p>
<h2 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a>结构体实例化</h2><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p>
<p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 结构体实例 结构体类型</span><br></pre></td></tr></table></figure>

<h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h3><p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p1 person</span><br><span class="line">	p1.name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">	p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">	p1.age = <span class="number">18</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;p1=%v\n&quot;</span>, p1)  <span class="comment">//p1=&#123;沙河娜扎 北京 18&#125;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;p1=%#v\n&quot;</span>, p1) <span class="comment">//p1=main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过<code>.</code>来访问结构体的字段（成员变量）,例如<code>p1.name</code>和<code>p1.age</code>等。</p>
<h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>; Age <span class="keyword">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h3><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p2)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure>

<p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p>
<p>需要注意的是在Go语言中支持对结构体指针直接使用<code>.</code>来访问结构体的成员。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">p2.age = <span class="number">28</span></span><br><span class="line">p2.city = <span class="string">&quot;上海&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;上海&quot;, age:28&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">&quot;七米&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;七米&quot;, city:&quot;成都&quot;, age:30&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p>
<h2 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h2><p>没有初始化的结构体，其成员变量都是对应其类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> p4 person</span><br><span class="line">	fmt.Printf(<span class="string">&quot;p4=%#v\n&quot;</span>, p4) <span class="comment">//p4=main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a>使用键值对初始化</h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">	name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">	city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p5=%#v\n&quot;</span>, p5) <span class="comment">//p5=main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure>

<p>也可以对结构体指针进行键值对初始化，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">	name: <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">	city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p6=%#v\n&quot;</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure>

<p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">	city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p7=%#v\n&quot;</span>, p7) <span class="comment">//p7=&amp;main.person&#123;name:&quot;&quot;, city:&quot;北京&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a>使用值的列表初始化</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">	<span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">	<span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	<span class="number">28</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p8=%#v\n&quot;</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:28&#125;</span></span><br></pre></td></tr></table></figure>

<p>使用这种格式初始化时，需要注意：</p>
<ol>
<li>必须初始化结构体的所有字段。</li>
<li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li>
<li>该方式不能和键值初始化方式混用。</li>
</ol>
<h2 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a>结构体内存布局</h2><p>结构体占用一块连续的内存。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="keyword">int8</span></span><br><span class="line">	b <span class="keyword">int8</span></span><br><span class="line">	c <span class="keyword">int8</span></span><br><span class="line">	d <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.a %p\n&quot;</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.b %p\n&quot;</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.c %p\n&quot;</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.d %p\n&quot;</span>, &amp;n.d)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure>

<p>【进阶知识点】关于Go语言中的内存对齐推荐阅读:<a href="https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com">在 Go 中恰到好处的内存对齐</a></p>
<h3 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h3><p>空结构体是不占用空间的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(v))  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>请问下面代码的执行结果是什么？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">	stus := []student&#123;</span><br><span class="line">		&#123;name: <span class="string">&quot;小王子&quot;</span>, age: <span class="number">18</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;娜扎&quot;</span>, age: <span class="number">23</span>&#125;,</span><br><span class="line">		&#123;name: <span class="string">&quot;大王八&quot;</span>, age: <span class="number">9000</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">		m[stu.name] = &amp;stu</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, <span class="string">&quot;=&gt;&quot;</span>, v.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		city: city,</span><br><span class="line">		age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用构造函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p9 := newPerson(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;沙河&quot;</span>, <span class="number">90</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p9) <span class="comment">//&amp;main.person&#123;name:&quot;张三&quot;, city:&quot;沙河&quot;, age:90&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h2><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p>
<p>方法的定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收者变量 接收者类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">		name: name,</span><br><span class="line">		age:  age,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">	p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p>
<h3 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a>指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code>或者<code>self</code>。 例如我们为<code>Person</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetAge</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">	p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用该方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">	p1.SetAge(<span class="number">30</span>)</span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a>值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">	p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := NewPerson(<span class="string">&quot;小王子&quot;</span>, <span class="number">25</span>)</span><br><span class="line">	p1.Dream()</span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">	p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">	fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a>什么时候应该使用指针类型接收者</h3><ol>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝代价比较大的大对象</li>
<li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>
</ol>
<h2 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a>任意类型添加方法</h2><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m1 MyInt</span><br><span class="line">	m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">	m1 = <span class="number">100</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p>
<h2 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a>结构体的匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;</span><br><span class="line">		<span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">		<span class="number">18</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">//main.Person&#123;string:&quot;北京&quot;, int:18&#125;</span></span><br><span class="line">	fmt.Println(p1.<span class="keyword">string</span>, p1.<span class="keyword">int</span>) <span class="comment">//北京 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>
<h2 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h2><p>一个结构体中可以嵌套包 含另一个结构体或结构体指针，就像下面的示例代码那样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province <span class="keyword">string</span></span><br><span class="line">	City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Gender  <span class="keyword">string</span></span><br><span class="line">	Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	user1 := User&#123;</span><br><span class="line">		Name:   <span class="string">&quot;小王子&quot;</span>,</span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">		Address: Address&#123;</span><br><span class="line">			Province: <span class="string">&quot;山东&quot;</span>,</span><br><span class="line">			City:     <span class="string">&quot;威海&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套匿名字段"><a href="#嵌套匿名字段" class="headerlink" title="嵌套匿名字段"></a>嵌套匿名字段</h3><p>上面user结构体中嵌套的<code>Address</code>结构体也可以采用匿名字段的方式，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province <span class="keyword">string</span></span><br><span class="line">	City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span></span><br><span class="line">	Gender  <span class="keyword">string</span></span><br><span class="line">	Address <span class="comment">//匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user2 User</span><br><span class="line">	user2.Name = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">	user2.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">	user2.Address.Province = <span class="string">&quot;山东&quot;</span>    <span class="comment">// 匿名字段默认使用类型名作为字段名</span></span><br><span class="line">	user2.City = <span class="string">&quot;威海&quot;</span>                <span class="comment">// 匿名字段可以省略</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;user2=%#v\n&quot;</span>, user2) <span class="comment">//user2=main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。</p>
<h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Province   <span class="keyword">string</span></span><br><span class="line">	City       <span class="keyword">string</span></span><br><span class="line">	CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">	Account    <span class="keyword">string</span></span><br><span class="line">	CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Gender <span class="keyword">string</span></span><br><span class="line">	Address</span><br><span class="line">	Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> user3 User</span><br><span class="line">	user3.Name = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">	user3.Gender = <span class="string">&quot;男&quot;</span></span><br><span class="line">	<span class="comment">// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</span></span><br><span class="line">	user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">	user3.Email.CreateTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">//指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a>结构体的“继承”</h2><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给animal 实现一个移动方法’mothed‘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	Feet    <span class="keyword">int8</span></span><br><span class="line">	*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给狗实现一个汪汪的方法“method”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := &amp;Dog&#123;</span><br><span class="line">		Feet: <span class="number">4</span>,</span><br><span class="line">		Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">			name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">	d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h2><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p>
<h2 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a>结构体与JSON序列化</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p>
<blockquote>
<p>结构体与json</p>
<p>1.序列化: 把Go 语言中的结构体变量 – &gt; json 格式的字符串</p>
<p>2.反序列化: json 格式的字符串 – &gt; Go语言能够是别的结构体变量</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="keyword">int</span></span><br><span class="line">	Gender <span class="keyword">string</span></span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">	Title    <span class="keyword">string</span></span><br><span class="line">	Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := &amp;Class&#123;</span><br><span class="line">		Title:    <span class="string">&quot;101&quot;</span>,</span><br><span class="line">		Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		stu := &amp;Student&#123;</span><br><span class="line">			Name:   fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i),</span><br><span class="line">			Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">			ID:     i,</span><br><span class="line">		&#125;</span><br><span class="line">		c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">	data, err := json.Marshal(c)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json:%s\n&quot;</span>, data)</span><br><span class="line">	<span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">	str := <span class="string">`&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;`</span></span><br><span class="line">	c1 := &amp;Class&#123;&#125;</span><br><span class="line">	err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a>结构体标签（Tag）</h2><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`key1:<span class="string">&quot;value1&quot;</span> key2:<span class="string">&quot;value2&quot;</span>`</span><br></pre></td></tr></table></figure>

<p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p>
<p><strong>注意事项：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p>
<p>例如我们为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID     <span class="keyword">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">	Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">	name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := Student&#123;</span><br><span class="line">		ID:     <span class="number">1</span>,</span><br><span class="line">		Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">		name:   <span class="string">&quot;沙河娜扎&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	data, err := json.Marshal(s1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体和方法补充知识点"><a href="#结构体和方法补充知识点" class="headerlink" title="结构体和方法补充知识点"></a>结构体和方法补充知识点</h2><p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。我们来看下面的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	age    <span class="keyword">int8</span></span><br><span class="line">	dreams []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetDreams</span><span class="params">(dreams []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.dreams = dreams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p1 := Person&#123;name: <span class="string">&quot;小王子&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">	data := []<span class="keyword">string</span>&#123;<span class="string">&quot;吃饭&quot;</span>, <span class="string">&quot;睡觉&quot;</span>, <span class="string">&quot;打豆豆&quot;</span>&#125;</span><br><span class="line">	p1.SetDreams(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 你真的想要修改 p1.dreams 吗？</span></span><br><span class="line">	data[<span class="number">1</span>] = <span class="string">&quot;不睡觉&quot;</span></span><br><span class="line">	fmt.Println(p1.dreams)  <span class="comment">// ?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetDreams</span><span class="params">(dreams []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	p.dreams = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(dreams))</span><br><span class="line">	<span class="built_in">copy</span>(p.dreams, dreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题。</p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>使用“面向对象”的思维方式编写一个学生信息管理系统。<ol>
<li>学生有id、姓名、年龄、分数等信息</li>
<li>程序提供展示学生列表、添加学生、编辑学生信息、删除学生等功能</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Golang</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础之接口</title>
    <url>/posts/2ad2e944/</url>
    <content><![CDATA[<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p>
<p><code>interface</code>是一组<code>method</code>的集合，是<code>duck-type programming</code>的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。</p>
<p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。</p>
<h2 id="为什么要使用接口"><a href="#为什么要使用接口" class="headerlink" title="为什么要使用接口"></a>为什么要使用接口</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Say</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">&quot;喵喵喵&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Say</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">&quot;汪汪汪&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := Cat&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;猫:&quot;</span>, c.Say())</span><br><span class="line">	d := Dog&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;狗:&quot;</span>, d.Say())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？</p>
<p>像类似的例子在我们编程过程中会经常遇到：</p>
<p>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</p>
<p>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</p>
<p>比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？</p>
<p>Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。</p>
<span id="more"></span>

<h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><p>Go语言提倡面向接口编程。</p>
<p>每个接口由数个方法组成，接口的定义格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>接口名：使用<code>type</code>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有字符串功能的接口叫<code>Stringer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。<br>举个例子：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> writer <span class="keyword">interface</span>&#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。</p>
<h2 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h2><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个<strong>需要实现的方法列表</strong>。</p>
<p>我们来定义一个<code>Sayer</code>接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义<code>dog</code>和<code>cat</code>两个结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>Sayer</code>接口里只有一个<code>say</code>方法，所以我们只需要给<code>dog</code>和<code>cat </code>分别实现<code>say</code>方法就可以实现<code>Sayer</code>接口了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dog实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat实现了Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。</p>
<h2 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a>接口类型变量</h2><p>那实现了接口有什么用呢？</p>
<p>接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，<code>Sayer</code>类型的变量能够存储<code>dog</code>和<code>cat</code>类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Sayer <span class="comment">// 声明一个Sayer类型的变量x</span></span><br><span class="line">	a := cat&#123;&#125;  <span class="comment">// 实例化一个cat</span></span><br><span class="line">	b := dog&#123;&#125;  <span class="comment">// 实例化一个dog</span></span><br><span class="line">	x = a       <span class="comment">// 可以把cat实例直接赋值给x</span></span><br><span class="line">	x.say()     <span class="comment">// 喵喵喵</span></span><br><span class="line">	x = b       <span class="comment">// 可以把dog实例直接赋值给x</span></span><br><span class="line">	x.say()     <span class="comment">// 汪汪汪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Tips：</strong> 观察下面的代码，体味此处<code>_</code>的妙用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 摘自gin框架routergroup.go</span></span><br><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IRouter = &amp;RouterGroup&#123;&#125;  <span class="comment">// 确保RouterGroup实现了接口IRouter</span></span><br></pre></td></tr></table></figure>

<h2 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h2><p>使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p>
<p>我们有一个<code>Mover</code>接口和一个<code>dog</code>结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a>值接收者实现接口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时实现接口的是<code>dog</code>类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Mover</span><br><span class="line">	<span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">	x = wangcai         <span class="comment">// x可以接收dog类型</span></span><br><span class="line">	<span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">	x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">	x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针<code>fugui</code>内部会自动求值<code>*fugui</code>。</p>
<h3 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h3><p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;狗会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Mover</span><br><span class="line">	<span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">	x = wangcai         <span class="comment">// x不可以接收dog类型</span></span><br><span class="line">	<span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">	x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时实现<code>Mover</code>接口的是<code>*dog</code>类型，所以不能给<code>x</code>传入<code>dog</code>类型的wangcai，此时x只能存储<code>*dog</code>类型的值。</p>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p><strong>注意：</strong>这是一道你需要回答“能”或者“不能”的题！</p>
<p>首先请观察下面的这段代码，然后请回答这段代码能不能通过编译？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">	Speak(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span> <span class="title">Speak</span><span class="params">(think <span class="keyword">string</span>)</span> <span class="params">(talk <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> think == <span class="string">&quot;sb&quot;</span> &#123;</span><br><span class="line">		talk = <span class="string">&quot;你是个大帅比&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		talk = <span class="string">&quot;您好&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> peo People = Student&#123;&#125;</span><br><span class="line">	think := <span class="string">&quot;bitch&quot;</span></span><br><span class="line">	fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h2><h3 id="一个类型实现多个接口"><a href="#一个类型实现多个接口" class="headerlink" title="一个类型实现多个接口"></a>一个类型实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： <code>Mover</code>接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dog既可以实现Sayer接口，也可以实现Mover接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会叫汪汪汪\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会动\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Sayer</span><br><span class="line">	<span class="keyword">var</span> y Mover</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">	x = a</span><br><span class="line">	y = a</span><br><span class="line">	x.say()</span><br><span class="line">	y.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个类型实现同一接口"><a href="#多个类型实现同一接口" class="headerlink" title="多个类型实现同一接口"></a>多个类型实现同一接口</h3><p>Go语言中不同的类型还可以实现同一接口 首先我们定义一个<code>Mover</code>接口，它要求必须由一个<code>move</code>方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> car <span class="keyword">struct</span> &#123;</span><br><span class="line">	brand <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog类型实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会跑\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// car类型实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c car)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s速度70迈\n&quot;</span>, c.brand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的<code>move</code>方法就可以了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Mover</span><br><span class="line">	<span class="keyword">var</span> a = dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> b = car&#123;brand: <span class="string">&quot;保时捷&quot;</span>&#125;</span><br><span class="line">	x = a</span><br><span class="line">	x.move()</span><br><span class="line">	x = b</span><br><span class="line">	x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码执行结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">旺财会跑</span><br><span class="line">保时捷速度<span class="number">70</span>迈</span><br></pre></td></tr></table></figure>

<p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WashingMachine 洗衣机</span></span><br><span class="line"><span class="keyword">type</span> WashingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">	wash()</span><br><span class="line">	dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甩干器</span></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span> <span class="title">dry</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海尔洗衣机</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">	dryer <span class="comment">//嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span> <span class="title">wash</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>接口与接口间可以通过嵌套创造出新的接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	Sayer</span><br><span class="line">	Mover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;喵喵喵&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;猫会动&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x animal</span><br><span class="line">	x = cat&#123;name: <span class="string">&quot;花花&quot;</span>&#125;</span><br><span class="line">	x.move()</span><br><span class="line">	x.say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><h3 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a>空接口的定义</h3><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p>
<p>空接口类型的变量可以存储任意类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个空接口x</span></span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	s := <span class="string">&quot;Hello 沙河&quot;</span></span><br><span class="line">	x = s</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">	i := <span class="number">100</span></span><br><span class="line">	x = i</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">	b := <span class="literal">true</span></span><br><span class="line">	x = b</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a>空接口的应用</h3><h4 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a>空接口作为函数的参数</h4><p>使用空接口实现可以接收任意类型的函数参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空接口作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="空接口作为map的值"><a href="#空接口作为map的值" class="headerlink" title="空接口作为map的值"></a>空接口作为map的值</h4><p>使用空接口实现可以保存任意值的字典。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line">	<span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	studentInfo[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;沙河娜扎&quot;</span></span><br><span class="line">	studentInfo[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">	studentInfo[<span class="string">&quot;married&quot;</span>] = <span class="literal">false</span></span><br><span class="line">	fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？</p>
<h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><p>一个接口的值（简称接口值）是由<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的。这两部分分别称为接口的<code>动态类型</code>和<code>动态值</code>。</p>
<p>我们来看一个具体的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>请看下图分解：<img src="https://liwenzhou.com/images/Go/interface/interface.png" alt="接口值图解"></p>
<p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>x：表示类型为<code>interface&#123;&#125;</code>的变量</li>
<li>T：表示断言<code>x</code>可能是的类型。</li>
</ul>
<p>该语法返回两个参数，第一个参数是<code>x</code>转化为<code>T</code>类型后的变量，第二个值是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	x = <span class="string">&quot;Hello 沙河&quot;</span></span><br><span class="line">	v, ok := x.(<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例中如果要断言多次就需要写多个<code>if</code>判断，这个时候我们可以使用<code>switch</code>语句来实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;x is a string，value is %v\n&quot;</span>, v)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;x is a int is %v\n&quot;</span>, v)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;x is a bool is %v\n&quot;</span>, v)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;unsupport type！&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。</p>
<p>关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p>使用接口的方式实现一个既可以往终端写日志也可以往文件写日志的简易日志库。</p>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Golang</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 分类和标签</title>
    <url>/posts/dccf6045/</url>
    <content><![CDATA[<h3 id="一、主题配置打开"><a href="#一、主题配置打开" class="headerlink" title="一、主题配置打开"></a><strong>一、主题配置打开</strong></h3><p>打开 <code>themes/next/_config.yml</code> <strong>主题配置文件</strong> 找到 <code>Menu Settings</code> ，把 <code>categories</code> 和 <code>tags</code> 取消注释。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tags: /tags/ || fa fa-tags</span><br><span class="line">categories: /categories/ || fa fa-th</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="二、添加分类模块"><a href="#二、添加分类模块" class="headerlink" title="二、添加分类模块"></a>二、添加分类模块</h2><p>新建一个分类页面。<br><code>$ hexo new page categories</code><br>你会发现你的source文件夹下有了categories[index.md](<a href="http://index.md/)%EF%BC%8C%E6%89%93%E5%BC%80index.md%E6%96%87%E4%BB%B6%E5%B0%86">http://index.md/)，打开index.md文件将</a> title 设置为title: 分类</p>
<p>把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中</p>
<h2 id="三、添加标签模块"><a href="#三、添加标签模块" class="headerlink" title="三、添加标签模块"></a>三、添加标签模块</h2><p>新建一个标签页面 。<br><code>$ hexo new page tags</code><br>你会发现你的source文件夹下有了tags[index.md](<a href="http://index.md/)%EF%BC%8C%E6%89%93%E5%BC%80index.md%E6%96%87%E4%BB%B6%E5%B0%86">http://index.md/)，打开index.md文件将</a> title 设置为title: 标签<br>把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中</p>
<h2 id="四、修改-index-md-文件"><a href="#四、修改-index-md-文件" class="headerlink" title="四、修改 index.md 文件"></a><strong>四、修改 <a href="http://index.md/">index.md</a> 文件</strong></h2><p>打开 <code>categories</code> 文件夹下的 <code>index.md</code> ，在最下面一行加一行文字就行，注意中间有空格。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2021-11-08 10:47:33</span><br><span class="line"><span class="built_in">type</span>: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>同理，<code>tags</code> 也是如此。</p>
<h2 id="五、效果展示"><a href="#五、效果展示" class="headerlink" title="五、效果展示"></a><strong>五、效果展示</strong></h2><p><img src="/posts/dccf6045/1677584124277.png" alt="1677584124277"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基础之map</title>
    <url>/posts/d6a720ce/</url>
    <content><![CDATA[<p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p>
<h2 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h2><p>Go语言中 <code>map</code>的定义语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[KeyType]ValueType</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>KeyType:表示键的类型。</li>
<li>ValueType:表示键对应的值的类型。</li>
</ul>
<p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, [<span class="built_in">cap</span>])</span><br></pre></td></tr></table></figure>

<p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p>
<h2 id="map基本使用"><a href="#map基本使用" class="headerlink" title="map基本使用"></a>map基本使用</h2><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line">	scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">	scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">	fmt.Println(scoreMap)</span><br><span class="line">	fmt.Println(scoreMap[<span class="string">&quot;小明&quot;</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">map[小明:100 张三:90]</span><br><span class="line">100</span><br><span class="line"><span class="built_in">type</span> of a:map[string]int</span><br></pre></td></tr></table></figure>

<p>map也支持在声明的时候填充元素，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	userInfo := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;username&quot;</span>: <span class="string">&quot;沙河小王子&quot;</span>,</span><br><span class="line">		<span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(userInfo) <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">	scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">	<span class="comment">// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span></span><br><span class="line">	v, ok := scoreMap[<span class="string">&quot;张三&quot;</span>]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;查无此人&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><p>Go语言中使用<code>for range</code>遍历map。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">	scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">	scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但我们只想遍历key的时候，可以按下面的写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">	scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">	scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">		fmt.Println(k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p>
<h2 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h2><p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(<span class="keyword">map</span>, key)</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li>map:表示要删除键值对的map</li>
<li>key:表示要删除的键值对的键</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	scoreMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">	scoreMap[<span class="string">&quot;张三&quot;</span>] = <span class="number">90</span></span><br><span class="line">	scoreMap[<span class="string">&quot;小明&quot;</span>] = <span class="number">100</span></span><br><span class="line">	scoreMap[<span class="string">&quot;娜扎&quot;</span>] = <span class="number">60</span></span><br><span class="line">	<span class="built_in">delete</span>(scoreMap, <span class="string">&quot;小明&quot;</span>)<span class="comment">//将小明:100从map中删除</span></span><br><span class="line">	<span class="keyword">for</span> k,v := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano()) <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> scoreMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		key := fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i) <span class="comment">//生成stu开头的字符串</span></span><br><span class="line">		value := rand.Intn(<span class="number">100</span>)          <span class="comment">//生成0~99的随机整数</span></span><br><span class="line">		scoreMap[key] = value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出map中的所有key存入切片keys</span></span><br><span class="line">	<span class="keyword">var</span> keys = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">200</span>)</span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> scoreMap &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对切片进行排序</span></span><br><span class="line">	sort.Strings(keys)</span><br><span class="line">	<span class="comment">//按照排序后的key遍历map</span></span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		fmt.Println(key, scoreMap[key])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h2><p>下面的代码演示了切片中的元素为map类型时的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mapSlice = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">	<span class="comment">// 对切片中的map元素进行初始化</span></span><br><span class="line">	mapSlice[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">	mapSlice[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;小王子&quot;</span></span><br><span class="line">	mapSlice[<span class="number">0</span>][<span class="string">&quot;password&quot;</span>] = <span class="string">&quot;123456&quot;</span></span><br><span class="line">	mapSlice[<span class="number">0</span>][<span class="string">&quot;address&quot;</span>] = <span class="string">&quot;沙河&quot;</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> mapSlice &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index:%d value:%v\n&quot;</span>, index, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h2><p>下面的代码演示了map中值为切片类型的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sliceMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">	fmt.Println(sliceMap)</span><br><span class="line">	fmt.Println(<span class="string">&quot;after init&quot;</span>)</span><br><span class="line">	key := <span class="string">&quot;中国&quot;</span></span><br><span class="line">	value, ok := sliceMap[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		value = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	value = <span class="built_in">append</span>(value, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>)</span><br><span class="line">	sliceMap[key] = value</span><br><span class="line">	fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol>
<li>写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how=1 do=2 you=1。</li>
<li>观察下面代码，写出最终的打印结果。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">int</span></span><br><span class="line">	m := <span class="built_in">make</span>(Map)</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line">	m[<span class="string">&quot;q1mi&quot;</span>] = s</span><br><span class="line">	s = <span class="built_in">append</span>(s[:<span class="number">1</span>], s[<span class="number">2</span>:]...)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, s)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, m[<span class="string">&quot;q1mi&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Go</tag>
        <tag>Golang</tag>
        <tag>Go学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetets CPU绑核配置</title>
    <url>/posts/19c6e9f2/</url>
    <content><![CDATA[<h1 id="CPU绑核配置"><a href="#CPU绑核配置" class="headerlink" title="CPU绑核配置"></a>CPU绑核配置</h1><p>默认情况下，kubelet 使用 <a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html">CFS 配额</a> 来执行 Pod 的 CPU 约束。 当节点上运行了很多 CPU 密集的 Pod 时，工作负载可能会迁移到不同的 CPU 核， 这取决于调度时 Pod 是否被扼制，以及哪些 CPU 核是可用的。许多应用对这种迁移不敏感，因此无需任何干预即可正常工作。有些应用对CPU敏感，CPU敏感型应用有如下特点。</p>
<ul>
<li>对CPU throttling 敏感</li>
<li>对上下文切换敏感</li>
<li>对处理器缓存未命中敏感</li>
<li>对跨socket内存访问敏感</li>
<li>期望运行在同一物理CPU的超线程</li>
</ul>
<p>如果您的应用有以上其中一个特点，可以利用kubernetes中提供的绑核策略去给应用绑核，提升应用性能，减少应用的调度延迟。cpu manager会优先在一个Socket上分配资源，也会优先分配完整的物理核，避免一些干扰。</p>
<h1 id="如何为Pod绑核"><a href="#如何为Pod绑核" class="headerlink" title="如何为Pod绑核"></a><strong>如何为Pod绑核</strong></h1><p>想要让Pod能够绑核，有如下几点要求：</p>
<ul>
<li>节点上开启静态绑核策略。</li>
<li>Pod的定义里都要设置request和limits，request和limits要一致。</li>
<li>对于要绑核的容器，request值必须是整数。</li>
<li>如果有init container希望进行绑核的话，init container的request最好与业务容器设置的request一致（避免业务容器未继承init container的cpu分配结果，导致cpu manager多预留一部分cpu）。更多信息请参见<a href="https://github.com/kubernetes/kubernetes/issues/94220#issuecomment-868489201">App Containers can&#39;t inherit Init Containers CPUs - CPU Manager Static Policy</a>。</li>
</ul>
<p>在使用时您可以利用<a href="https://support.huaweicloud.com/usermanual-cce/cce_10_0232.html">调度策略（亲和与反亲和）</a>将如上配置的Pod调度到开启静态绑核策略的节点上，这样就能够达到绑核的效果。</p>
<h3 id="开启CPU管理策略"><a href="#开启CPU管理策略" class="headerlink" title="开启CPU管理策略"></a><strong>开启CPU管理策略</strong></h3><p><a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/cpu-management-policies/">CPU 管理策略</a>通过 kubelet 参数 –cpu-manager-policy 来指定。支持两种策略：</p>
<ul>
<li>关闭（none）：默认策略，显式地启用现有的默认 CPU 亲和方案，不提供操作系统调度器默认行为之外的亲和性策略。</li>
<li>开启（static）：针对具有整数型 CPU requests 的 Guaranteed Pod ，它允许该类 Pod 中的容器访问节点上的独占 CPU 资源（绑核）。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先驱逐节点，停止kubeket</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">stop</span> <span class="string">kubelet</span></span><br><span class="line"><span class="comment"># 修改kubelet启动配置</span></span><br><span class="line"><span class="string">--cpu-manager-policy=&quot;static&quot;</span> <span class="comment"># 新版本已经废弃该用--config方式</span></span><br><span class="line"><span class="comment"># v1.19以后新版本在config.yml配置中新增</span></span><br><span class="line"><span class="attr">cpuManagerPolicy:</span> <span class="string">static</span></span><br><span class="line"><span class="comment"># 另外，需要配置 kubeReserved预留否则会报错</span></span><br><span class="line"><span class="attr">kubeReserved:</span></span><br><span class="line">  <span class="attr">cpu:</span> <span class="string">2000m</span></span><br><span class="line"><span class="comment"># 删除配置</span></span><br><span class="line"><span class="string">mv</span>  <span class="string">/var/lib/kubelet/cpu_manager_state&#123;,.bak&#125;</span></span><br><span class="line"><span class="comment"># 重启kubelet</span></span><br><span class="line"><span class="string">systemctl</span> <span class="string">daemon-reload</span> <span class="string">&amp;&amp;</span> <span class="string">systemctl</span> <span class="string">restart</span> <span class="string">kubelet</span></span><br></pre></td></tr></table></figure>

<h2 id="Pod资源配置"><a href="#Pod资源配置" class="headerlink" title="Pod资源配置"></a><strong><strong>Pod资源配置</strong></strong></h2><p>Pod的resources中cpu的request值需为整数，且request和limits要一致。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个pod</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">-&lt;&lt;EOF</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nettools-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">      <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nettools-deploy</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nettools-deploy</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeName:</span> <span class="string">&quot;10.4.83.28&quot;</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nettools-deploy</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.XXXX.com/base/network-multitool:lastet</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nettools-deploy</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;200Mi&quot;</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;200Mi&quot;</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 验证绑核效果,可以看到容器实例帮核已经到2,34核心</span></span><br><span class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">/var/lib/kubelet/cpu_manager_state</span></span><br><span class="line">&#123;<span class="string">&quot;policyName&quot;</span><span class="string">:&quot;static&quot;</span>,<span class="string">&quot;defaultCpuSet&quot;</span><span class="string">:&quot;0-1</span>,<span class="number">3</span><span class="number">-33</span>,<span class="number">35</span><span class="number">-63</span><span class="string">&quot;,&quot;</span><span class="string">entries&quot;:</span>&#123;<span class="string">&quot;4378c1c9-7a86-48a0-8ad9-5a0d4ff4b3ac&quot;</span><span class="string">:</span>&#123;<span class="string">&quot;nettools-deploy&quot;</span><span class="string">:&quot;2</span>,<span class="number">34</span><span class="string">&quot;&#125;&#125;,&quot;</span><span class="string">checksum&quot;:239816225</span>&#125;</span><br><span class="line"><span class="comment"># 查找pod 对应的pid</span></span><br><span class="line"><span class="string">$</span> <span class="string">docker</span> <span class="string">ps</span> <span class="string">-a</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">nettools-deploy-7b4df69496-8rzn4</span> <span class="string">|</span> <span class="string">head</span> <span class="string">-n</span> <span class="number">1</span>  <span class="string">|</span> <span class="string">awk</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>  <span class="string">|</span> <span class="string">xargs</span> <span class="string">-i</span> <span class="string">docker</span> <span class="string">inspect</span> &#123;&#125; <span class="string">|grep</span> <span class="string">Pid</span></span><br><span class="line">            <span class="attr">&quot;Pid&quot;:</span> <span class="number">234293</span>,</span><br><span class="line">            <span class="attr">&quot;PidMode&quot;:</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;PidsLimit&quot;:</span> <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令查看帮核效果，跟kubelet记录一致</span></span><br><span class="line"><span class="string">$</span> <span class="string">taskset</span> <span class="string">-c</span> <span class="string">-p</span> <span class="number">234293</span></span><br><span class="line"><span class="string">pid</span> <span class="number">234293</span><span class="string">&#x27;s current affinity list: 2,34</span></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/cpu-management-policies/"></a><a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/cpu-management-policies/">https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/cpu-management-policies/</a></p>
<p><a href="https://support.huaweicloud.com/usermanual-cce/cce_10_0351.html"></a><a href="https://support.huaweicloud.com/usermanual-cce/cce_10_0351.html">https://support.huaweicloud.com/usermanual-cce/cce_10_0351.html</a></p>
<p><a href="https://imroc.cc/kubernetes/best-practices/performance-optimization/cpu.html"></a><a href="https://imroc.cc/kubernetes/best-practices/performance-optimization/cpu.html">https://imroc.cc/kubernetes/best-practices/performance-optimization/cpu.html</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1642977"></a><a href="https://cloud.tencent.com/developer/article/1642977">https://cloud.tencent.com/developer/article/1642977</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes容器网络</title>
    <url>/posts/484087c6/</url>
    <content><![CDATA[<h2 id="容器是什么"><a href="#容器是什么" class="headerlink" title="容器是什么"></a>容器是什么</h2><p>容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬到任何地方运行。对于大多数如Docker、RKT，等Linux容器，其实就是利用Linux Namespace技术创建隔离的进程空间、文件系统、网络命名空间、用户空间、主机名的一组进程。</p>
<p>所以说，容器，其实是一种特殊的进程而已。</p>
<p>一个“容器”，实际上是一个由 Linux Namespace、Linux Cgroups 和 rootfs 三种技术构建出来的进程的隔离环境。</p>
<h3 id="容器优势"><a href="#容器优势" class="headerlink" title="容器优势"></a>容器优势</h3><ul>
<li>开销更少，无需像虚拟化一样虚拟完整的内核以及初始化环境，和启动一些多余的系统进程。</li>
<li>可移植性强，容器可以轻松在不同平台移植，如直接运行<code>docker run -d --name nginx -p 80:80 nginx</code></li>
<li>高效率，开发打完包构建容器后，可以更快部署，发布</li>
<li>敏捷开发，更快的移植，无需担心依赖的环境不一致的问题</li>
<li>….</li>
</ul>
<h3 id="Kebernetes"><a href="#Kebernetes" class="headerlink" title="Kebernetes"></a>Kebernetes</h3><p>k8s 是什么？为什么要引入 k8s，kubernetes 其实是google公司开源，和Redhat公司一起开发的一个容器编排项目。</p>
<ul>
<li><p>k8s 是什么，为什么要引入k8s：<a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/</a></p>
</li>
<li><p>k8s 组件有哪些：<a href="https://kubernetes.io/zh/docs/concepts/overview/components/">https://kubernetes.io/zh/docs/concepts/overview/components/</a> </p>
</li>
</ul>
<h2 id="容器网络模型"><a href="#容器网络模型" class="headerlink" title="容器网络模型"></a>容器网络模型</h2><h3 id="docker-的三种网络模式"><a href="#docker-的三种网络模式" class="headerlink" title="docker 的三种网络模式"></a>docker 的三种网络模式</h3><p>在将容器网络之前先讲一下docker 的网络模式，<code>docker network ls</code>  可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">7152832275d0        bridge              bridge              local</span><br><span class="line">bfc2647e9b0b        host                host                local</span><br><span class="line">00ed57db3efb        none                null                local</span><br></pre></td></tr></table></figure>

<ul>
<li><p>bridge 借助虚拟网桥设备为容器建立网络连接</p>
</li>
<li><p>host 设置容器直接共享当前节点主机的网络名称空间</p>
</li>
<li><p>none 对于此容器，禁用所有网络。通常与自定义网络驱动程序结合使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每个容器都有自己的独立的&#x27;网络栈&#x27;，如果你想要实现两台主机之间的通信，最直接的办法，就是把它们用一根网线连接起来；而如果你想要实现多台主机之间的通信，那就需要用网线，把它们连接在一台交换机上，即网桥（Bridge）。它是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上</span></span><br><span class="line"><span class="comment"># 在容器中，Docker安装完成时会创建一个名为docker0的linux bridge，不指定网络时，创建的网络默认为桥接网络，都会桥接到docker0上。</span></span><br><span class="line"><span class="comment"># 如何把容器连接到这个docker0 网桥上呢？这个时候就需要 Veth Pair 的虚拟设备了，该设备一般是成对的出现，并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242f2caa77e       no</span><br><span class="line">pan1            8000.000000000000       no</span><br><span class="line">$ docker run -d -u daemon  --name <span class="string">&#x27;net-bridge&#x27;</span> busybox top </span><br><span class="line">$ docker <span class="built_in">exec</span> -ti net-bridge  /bin/sh</span><br><span class="line"><span class="comment"># Veth Pair虚拟网卡设备eth0@if62</span></span><br><span class="line">/ $ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">61: eth0@if62: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">/ $ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"><span class="comment"># 宿主机上查看接口信息,启动了一个虚拟网卡设备 vethaf3497b@if61</span></span><br><span class="line">$ ip a | tail -4</span><br><span class="line">62: vethaf3497b@if61: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link/ether ca:2f:b0:6a:a1:28 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::c82f:b0ff:fe6a:a128/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># brctl show 可以看到docker0 设备上多了一个接口 vethf29b81e 即刚才启动容器的虚拟网卡</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242f2caa77e       no              vethaf3497b</span><br><span class="line">pan1            8000.000000000000       no</span><br><span class="line"></span><br><span class="line"><span class="comment"># host网络，就是和host主机共享网络，会和host使用一样的网络，host网络的性能比较高，但也会不可避免地引入共享网络资源的问题，比如端口冲突，比如隔离性问题。</span></span><br><span class="line"></span><br><span class="line">$ docker run --net=host busybox ifconfig</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:F2:CA:A7:7E</span><br><span class="line">          inet addr:172.17.0.1  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:f2ff:feca:a77e/64 Scope:Link</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:274096 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:323190 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:13525456 (12.8 MiB)  TX bytes:1664281006 (1.5 GiB)</span><br><span class="line"></span><br><span class="line">enp0s31f6 Link encap:Ethernet  HWaddr 54:E1:AD:08:B4:21</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line">          Interrupt:16 Memory:f2200000-f2220000</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1850471 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1850471 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:1186483790 (1.1 GiB)  TX bytes:1186483790 (1.1 GiB)</span><br><span class="line"></span><br><span class="line">pan1      Link encap:Ethernet  HWaddr 12:AA:30:13:D7:A4</span><br><span class="line">          inet addr:10.6.207.1  Bcast:10.6.207.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::10aa:30ff:fe13:d7a4/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:14194 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:2916067 (2.7 MiB)</span><br><span class="line">wlp3s0    Link encap:Ethernet  HWaddr F8:59:71:8E:3F:55</span><br><span class="line">          inet addr:10.10.134.147  Bcast:10.10.143.255  Mask:255.255.240.0</span><br><span class="line">          inet6 addr: fe80::54ce:44cc:368:d288/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:16914279 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4101535 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:7919534294 (7.3 GiB)  TX bytes:2673781183 (2.4 GiB)          </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment"># none网络，在该网络下的容器仅有lo网卡，属于封闭式网络，通常用于对安全性要求较高并且不需要联网的应用</span></span><br><span class="line">docker run --rm -it --network=none busybox ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ul>
<p>接下来以docker 两种通信方式来介绍容器通信模式：</p>
<h3 id="单机容器通信"><a href="#单机容器通信" class="headerlink" title="单机容器通信"></a>单机容器通信</h3><p>同一个宿主机上的不同容器通过 docker0 网桥进行通信的流程如图：</p>
<p><img src="https://i.loli.net/2021/07/14/VutyxR1TczBPSpv.png" alt="image-20210713104524840"></p>
<p>如图说所示，在容器中，通过docker0网桥，凡是连接到docker0的容器，就可以通过它来进行通信。要想容器能够连接到docker0网桥，我们需要类似网线的虚拟设备Veth Pair来把容器连接到网桥上。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动一个container1 </span></span><br><span class="line">$ docker run -d --name <span class="string">&#x27;container1&#x27;</span> nginx</span><br><span class="line">$ dockrer <span class="built_in">exec</span> -ti container1  /bin/sh</span><br><span class="line">$ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">65: eth0@if66: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">$ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个container2</span></span><br><span class="line">$ docker run -d --name <span class="string">&#x27;container2&#x27;</span> nginx</span><br><span class="line">$ dockrer <span class="built_in">exec</span> -ti container2  /bin/sh</span><br><span class="line">$ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">63: eth0@if64: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看宿主机上的虚拟设备Veth Pair, veth182b3a5@if63 和 container2 的eth0@if64 是一对，container1 同理。</span></span><br><span class="line">$ ip a | tail -8</span><br><span class="line">64: veth182b3a5@if63: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link/ether 76:97:8e:fe:a9:c7 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::7497:8eff:fefe:a9c7/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">66: veth877c7d8@if65: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link/ether 12:7e:d0:0f:ae:99 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::107e:d0ff:fe0f:ae99/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># container1 ping container2 测试</span></span><br><span class="line"><span class="comment"># ping 172.17.0.3</span></span><br><span class="line">PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.091 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.034 ms</span><br><span class="line"><span class="comment"># 可以看到同一宿主机容器默认都是通的，是因为他们默认网关都是docker0 这块网卡。 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="跨主机容器通信"><a href="#跨主机容器通信" class="headerlink" title="跨主机容器通信"></a>跨主机容器通信</h3><p>跨主机通信方案有以下几种方案：</p>
<ul>
<li>NAT方式<br>NAT就是传统的docker网络，利用宿主机的IP和Iptables来达到容器，主机之间的通信。容器对外IP都是宿主机的IP，NAT的性能损耗比较大。但只要宿主机之间三层IP可达，容器之间就可以通信，比较普适。</li>
<li>Tunnel（overlay）方式，VPN，ipip，VXLAN等都是tunnel技术，简单讲就是在容器的数据包间封装一层或多层其他的数据协议头，达到连通的效果。这种方式一般也是只需要三层可达，容器就能互通，比较普适。</li>
<li>Routing方式<br>路由方案主要是通过路由设置的方式让容器对容器，容器对宿主机之间相通信。例如：calico的BGP路由方案（非IPIP）。这种方式一般适用于单个数据中心，最常见的是同一个vlan中使用，如果不是，需要设置路由规则。路由方案性能损耗少，和主机网络性能比较接近。</li>
</ul>
<p>先介绍下NAT方式，所有接入到该桥接设备上的容器都会被NAT隐藏，它们发往Docker主机外部的所有流量都会经过源地址转换后发出(SNAT)，并且默认是无法直接接受节点之外的其他主机发来的请求。当需要接入Docker主机外部流量，就需要进行目标地址转换(DNAT)甚至端口转换将其暴露在外部网络当中。大致的流程图：</p>
<p><img src="https://i.loli.net/2021/07/14/scPfALv6ibqEMWI.png" alt="image-20210713111835432"></p>
<p>容器内的属于私有地址，需要在左侧的主机上的eth0上进行源地址转换，而右侧的地址需要被访问，就需要将eth0的地址进行NAT转换。SNAT—-&gt;DNAT。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#具体方案在2个主机上通过主机路由和iptables 地址伪装来实现跨主机容器的互通，这里就不做过多解释</span><br></pre></td></tr></table></figure>

<h2 id="Kubernetes-容器网络CNI插件"><a href="#Kubernetes-容器网络CNI插件" class="headerlink" title="Kubernetes 容器网络CNI插件"></a>Kubernetes 容器网络CNI插件</h2><p>这里介绍完docker的网络方案之后，我们来聊聊kubernetes的容器间网络的通信方案。</p>
<p>官网中文doc：<a href="https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/">https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/</a></p>
<p>那么什么是CNI（container network interface）容器网络接口，k8s为了更好的控制网络的接入，推出了CNI即容器网络的API接口。CNI维护了一个单独的网桥来代替 docker0。这个网桥的名字就叫作：CNI 网桥，它在宿主机上的设备名称默认是：cni0。</p>
<p>CNI主要解决Pod间的通信，目前流行的CNI插件如：calico, cilium, flannel, kube-ovn, kube-router</p>
<h2 id="Flannel-插件跨主机通信原理"><a href="#Flannel-插件跨主机通信原理" class="headerlink" title="Flannel 插件跨主机通信原理"></a>Flannel 插件跨主机通信原理</h2><p>Flannel 项目是 CoreOS 公司主推的容器网络方案。事实上，Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现。目前，Flannel 支持三种后端实现，分别是：</p>
<ul>
<li>UDP</li>
<li>VXLAN</li>
<li>host-gw</li>
</ul>
<h3 id="udp模式"><a href="#udp模式" class="headerlink" title="udp模式"></a>udp模式</h3><p><img src="https://i.loli.net/2021/07/14/zSH467pZwVF1LBg.png" alt="image-20210713190907679"></p>
<p>可以看到，Flannel UDP 模式提供的其实是一个三层的 Overlay 网络，即：它首先对发出端的 IP 包进行 UDP 封装，然后在接收端进行解封装拿到原始的 IP 包，进而把这个 IP 包转发给目标容器。这就好比，Flannel 在不同宿主机上的两个容器之间打通了一条“隧道”，使得这两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况。</p>
<p>但是UDP 模式有严重的性能问题，基本已经上被废弃了。</p>
<p>基于 Flannel UDP 模式的容器通信多了一个额外的步骤，即 flanneld 的处理过程。而这个过程，由于使用到了 flannel0 这个 TUN 设备，仅在发出 IP 包的过程中，就需要经过三次用户态与内核态之间的数据拷贝，其性能可想而知。</p>
<h3 id="VXLAN模式"><a href="#VXLAN模式" class="headerlink" title="VXLAN模式"></a>VXLAN模式</h3><p>VXLAN，即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络虚似化技术。所以说，VXLAN 可以完全在内核态实现上述封装和解封装的工作，从而通过与前面相似的“隧道”机制，构建出覆盖网络（Overlay Network）</p>
<p><img src="https://i.loli.net/2021/07/14/Kqv7ULZscznIGFC.png" alt="image-20210713191114467"></p>
<p>VXLAN 模式组建的覆盖网络，其实就是一个由不同宿主机上的 VTEP 设备，也就是 flannel.1 设备组成的虚拟二层网络。对于 VTEP 设备来说，它发出的“内部数据帧”就仿佛是一直在这个虚拟的二层网络上流动。这，也正是覆盖网络的含义,具体就不展开了。</p>
<h2 id="Kubernetes-三层网络方案"><a href="#Kubernetes-三层网络方案" class="headerlink" title="Kubernetes 三层网络方案"></a>Kubernetes 三层网络方案</h2><p>讲了以上flannel 的以上2种方案，我们接下来讲一下纯三层的网络方案，如于 Flannel 的 host-gw 模式和 Calico BGP</p>
<h3 id="Flannel-的-host-gw-模式"><a href="#Flannel-的-host-gw-模式" class="headerlink" title="Flannel 的 host-gw 模式"></a>Flannel 的 host-gw 模式</h3><p><img src="https://i.loli.net/2021/07/14/xp64BmUif5PMXsl.png" alt="image-20210714221235728"></p>
<p>假设现在，Node 1 上的 Infra-container-1，要访问 Node 2 上的 Infra-container-2。</p>
<p>当你设置 Flannel 使用 host-gw 模式之后，flanneld 会在宿主机上创建这样一条规则，以 Node 1 为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ip route</span><br><span class="line">...</span><br><span class="line">10.244.1.0/24 via 10.168.0.3 dev eth0</span><br></pre></td></tr></table></figure>

<p>这条路由规则的含义是：目的 IP 地址属于 10.244.1.0/24 网段的 IP 包，应该经过本机的 eth0 设备发出去（即：dev eth0）；并且，它下一跳地址（next-hop）是 10.168.0.3（即：via 10.168.0.3）。</p>
<p>如图所示这个下一跳地址对应的，正是我们的目的宿主机 Node 2。</p>
<p>一旦配置了下一跳地址，那么接下来，当 IP 包从网络层进入链路层封装成帧的时候，eth0 设备就会使用下一跳地址对应的 MAC 地址，作为该数据帧的目的 MAC 地址。显然，这个 MAC 地址，正是 Node 2 的 MAC 地址。这样，这个数据帧就会从 Node 1 通过宿主机的二层网络顺利到达 Node 2 上。</p>
<p>而 Node 2 的内核网络栈从二层数据帧里拿到 IP 包后，会“看到”这个 IP 包的目的 IP 地址是 10.244.1.3，即 Infra-container-2 的 IP 地址。这时候，根据 Node 2 上的路由表，该目的地址会匹配到第二条路由规则（也就是 10.244.1.0 对应的路由规则），从而进入 cni0 网桥，进而进入到 Infra-container-2 当中。</p>
<p>host-gw 模式的工作原理，其实就是将每个 Flannel 子网（Flannel Subnet，比如：10.244.1.0/24）的“下一跳”，设置成了该子网对应的宿主机的 IP 地址。所以宿主机充当了“网关”的角色，即顾名思义“host-gw”</p>
<h3 id="Calico"><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h3><p>Calico 是一套开源的网络和网络安全方案，用于容器、虚拟机、宿主机之前的网络连接，可以用在kubernetes、OpenShift、DockerEE、OpenStrack等PaaS或IaaS平台上。</p>
<p>首先看下calico 架构图</p>
<p><img src="https://i.loli.net/2021/07/14/t4dhz5sQkFiPWcl.png" alt="image-20210713170229021"></p>
<ul>
<li><code>Felix</code>：<code>calico</code>的核心组件，运行在每个节点上。主要的功能有接口管理、路由规则、ACL规则和状态报告</li>
<li><code>Etcd</code>：保证数据一致性的数据库，存储集群中节点的所有路由信息。为保证数据的可靠和容错建议至少三个以上etcd节点。</li>
<li><code>Bird</code>：BGP客户端，<code>Calico</code>在每个节点上的都会部署一个BGP客户端（利用Daemonset方式部署），它的作用是将Felix的路由信息读入内核，并通过BGP协议在集群中分发。当Felix将路由插入到Linux内核FIB中时，BGP客户端将获取这些路由并将它们分发到部署中的其他节点。这可以确保在部署时有效地路由流量。</li>
<li><code>BGP Router Reflector</code>：使用 BGP client 形成 mesh 全网互联的方案就会导致规模限制，所有节点需要 N^2 个连接，为了解决这个规模问题，BGP 的 <code>Router Reflector</code>的方法，使所有 BGP Client 仅与特定 RR 节点互联并做路由同步，从而大大减少连接数。</li>
</ul>
<h4 id="Calico-网络模式"><a href="#Calico-网络模式" class="headerlink" title="Calico 网络模式"></a>Calico 网络模式</h4><ul>
<li> IPIP模式，把 IP 层封装到 IP 层的一个 tunnel。作用其实基本上就相当于一个基于IP层的网桥！一般来说，普通的网桥是基于mac层的，根本不需 IP，而这个 ipip 则是通过两端的路由做一个 tunnel，把两个本来不通的网络通过点对点连接起来。</li>
<li>Router Reflector 模式（RR），Calico 维护的网络在默认是（Node-to-Node Mesh）全互联模式，Calico集群中的节点之间都会相互建立连接，用于路由交换。但是随着集群规模的扩大，mesh模式将形成一个巨大服务网格，连接数成倍增加。这时就需要使用 Route Reflector（路由器反射）模式解决这个问题。</li>
</ul>
<h4 id="BGP-协议"><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h4><p><code>BGP（border gateway protocol）是外部路由协议（边界网关路由协议）</code>，用来在AS之间传递路由信息是一种增强的距离矢量路由协议（应用场景），基本功能是在自治系统间自动交换无环路的路由信息，通过交换带有自治系统号序列属性的路径可达信息，来构造自治系统的拓扑图，从而消除路由环路并实施用户配置的路由策略。<strong>只要记住BGP简单理解其实就是实现大规模网络中节点路由信息同步共享的一种协议</strong>。</p>
<blockquote>
<p>实际上，Calico 项目提供的 <code>BGP</code> 网络解决方案，与 <code>Flannel</code> 的 <code>host-gw</code> 模式几乎一样。也就是说，Calico也是基于路由表实现容器数据包转发，但不同于Flannel使用flanneld进程来维护路由信息的做法，而Calico项目使用BGP协议来自动维护整个集群的路由信息。</p>
</blockquote>
<p>BGP模式</p>
<ul>
<li><code>全互联模式</code>（node-to-node mesh） 每一个BGP Speaker都需要和其他BGP Speaker建立BGP连接，这样BGP连接总数就是N^2，如果数量过大会消耗大量连接。如果集群数量超过100台官方不建议使用此种模式。</li>
<li>RR模式（Router Reflection），会指定一个或多个BGP Speaker为RouterReflection，它与网络中其他Speaker建立连接，每个Speaker只要与Router Reflection建立BGP就可以获得全网的路由信息。在calico中可以通过<code>Global Peer</code>实现RR模式。</li>
</ul>
<h4 id="Calico-IPIP"><a href="#Calico-IPIP" class="headerlink" title="Calico IPIP"></a>Calico IPIP</h4><p><img src="https://i.loli.net/2021/07/14/dtF9w1YTnsIZ4Ek.png" alt="image-20210714210320203"></p>
<p>IPIP 是linux内核的驱动程序，可以对数据包进行隧道，上图可以看到两个不同的网络 vlan1 和 vlan2。基于现有的以太网将原始包中的原始IP进行一次封装，通过tunl0解包，这个tunl0类似于ipip模块，和Flannel vxlan的veth很类似。</p>
<p>Pod1 访问 Pod2 流程如下：</p>
<ol>
<li><p>数据包从 Pod1 出到达Veth Pair另一端（宿主机上，以cali前缀开头）。</p>
</li>
<li><p>进入IP隧道设备（tunl0），由Linux内核IPIP驱动封装，把源容器ip换成源宿主机ip，目的容器ip换成目的主机ip，这样就封装成 Node1 到 Node2 的数据包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">此时包的类型：</span><br><span class="line">  原始IP包：</span><br><span class="line">  源IP：10.244.1.10</span><br><span class="line">  目的IP：10.244.2.10</span><br><span class="line"></span><br><span class="line">   TCP：</span><br><span class="line">   源IP: 192.168.31.62</span><br><span class="line">   目的iP：192.168.32.63</span><br></pre></td></tr></table></figure></li>
<li><p>数据包经过路由器三层转发到 Node2</p>
</li>
<li><p>Node2 收到数据包后，网络协议栈会使用IPIP驱动进行解包，从中拿到原始IP包。</p>
</li>
<li><p>然后根据路由规则，将数据包转发给cali设备，从而到达 Pod2。</p>
</li>
</ol>
<p>通过如上步骤可以看出，当 Calico 使用 IPIP 模式的时候，集群的网络性能会因为额外的封包和解包工作而下降。所以建议你将所有宿主机节点放在一个子网里，避免使用 IPIP。<strong>不过这里可以利用IPIP模式的CrossSubnet来突破node不能跨VALN的问题，这个目前已经测试通过。</strong></p>
<h4 id="Calico-BGP-RR"><a href="#Calico-BGP-RR" class="headerlink" title="Calico BGP RR"></a>Calico BGP RR</h4><p>calico还和flannel host-gw不同之处在于，它不会创建网桥设备，而是通过路由表来维护每个pod的通信，如下图：</p>
<p><img src="https://i.loli.net/2021/07/14/2nKSBwmRChpUqgD.png" alt="image-20210714200920896"></p>
<p>Pod1 访问 Pod2大致流程如下：</p>
<ul>
<li>数据包从Pod1出到达Veth Pair另一端（宿主机上，以cali前缀开头）</li>
<li>宿主机根据路由规则，将数据包转发给下一跳（网关）</li>
<li>到达Node2，根据路由规则将数据包转发给cali设备，从而到达Pod2</li>
</ul>
<p>实际例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.启动2个容器</span><br><span class="line">kubectl create -f -&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: nettools-deploy</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  replicas: 2</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nettools-deploy</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nettools-deploy</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">        - name: nettools-deploy</span></span><br><span class="line"><span class="string">          image: registry.XXX.com/base/network-multitool:lastet</span></span><br><span class="line"><span class="string">          imagePullPolicy: IfNotPresent     </span></span><br><span class="line"><span class="string">          ports:</span></span><br><span class="line"><span class="string">            - containerPort: 80</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">2.查看2个pod 目前所在的node节点</span><br><span class="line">kubectl get pod -owide</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE    IP             NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nettools-deploy-68b646bdfb-2ckgt   1/1     Running   0          113s   10.5.231.54    10.4.83.14   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nettools-deploy-68b646bdfb-xbpwd   1/1     Running   0          113s   10.5.228.128   10.4.83.11   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">3.查看pod中的路由和网卡信息，可以看到路由指向的是一个不存在的网关地址169.254.1.1，这个主要利用了ARP代理欺骗的技术来把pod 所有数据流导到宿主机的 cali70d877f367d@if3 网卡上</span><br><span class="line">kubectl <span class="built_in">exec</span> -ti nettools-deploy-68b646bdfb-2ckgt  /bin/sh</span><br><span class="line">ip r</span><br><span class="line">default via 169.254.1.1 dev eth0</span><br><span class="line">169.254.1.1 dev eth0 scope link</span><br><span class="line">/ <span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth0@if9431: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether be:11:81:9a:9b:d4 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.5.231.54/32 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4.可以登录node 查看Veth Pair 设备和路由信息，这里可以看到网卡的编号和pod 中的网卡名是一样的。所以称之为虚拟网卡对(Veth Pair)，有了这个cali70d877f367d@if3 设备那么容器发出的IP包就会通过veth pair设备到达宿主机</span><br><span class="line">ip r  | grep 10.5.231.54</span><br><span class="line">10.5.231.54 dev cali70d877f367d scope link</span><br><span class="line"></span><br><span class="line">ip a | grep -A 4  9431</span><br><span class="line">9431: cali70d877f367d@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 7</span><br><span class="line">    inet6 fe80::ecee:eeff:feee:eeee/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">5.pod1要想跟其他主机pod2通信那么检查node上是否存在相应的路由，然后到达目标宿主机，再到达目标容器</span><br><span class="line">ip r | grep 10.5.228.128</span><br><span class="line">10.5.228.128/26 via 10.4.83.11 dev bond0 proto bird</span><br></pre></td></tr></table></figure>

<p>其中，这里最核心的 下一跳 路由规则，就是由 Calico 的 Felix 进程负责维护的。这些路由规则信息，则是通过 BGP Client 中 BIRD 组件，使用 BGP 协议来传输。</p>
<p>不难发现，Calico 项目实际上将集群里的所有节点，都当作是边界路由器来处理，它们一起组成了一个全连通的网络，互相之间通过 BGP 协议交换路由规则。这些节点，我们称为 BGP Peer。</p>
<p>需要注意的是calico 维护网络的默认模式是 node-to-node mesh ,这种模式下，每台宿主机的BGP client都会跟集群所有的节点BGP client进行通信交换路由。这样一来，随着节点规模数量N的增加，连接会以N的2次方增长，会集群网络本身带来巨大压力，在集群规模比较大时，官方建议是使用BGP-RR 如下是我们使用网络硬件设备作为RR</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">calicoctl node status</span><br><span class="line">Calico process is running.</span><br><span class="line"></span><br><span class="line">IPv4 BGP status</span><br><span class="line">+--------------+-----------+-------+------------+-------------+</span><br><span class="line">| PEER ADDRESS | PEER TYPE | STATE |   SINCE    |    INFO     |</span><br><span class="line">+--------------+-----------+-------+------------+-------------+</span><br><span class="line">| 10.4.36.250  | global    | up    | 2021-05-11 | Established |</span><br><span class="line">| 10.4.36.251  | global    | up    | 2021-05-11 | Established |</span><br><span class="line">+--------------+-----------+-------+------------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="目前calico架构图"><a href="#目前calico架构图" class="headerlink" title="目前calico架构图"></a>目前calico架构图</h4><p><img src="https://i.loli.net/2021/07/14/cOREUpCYqS5omPI.png" alt="image-20210714205042267"></p>
<p>现在的架构考虑到了冗余，隔离，性能</p>
<ul>
<li>网络隔离，所有的bgp 学习在一组交换机内，不向上通报，避免容器的bgp 影响到我们sdn 的bgp，带来的排障的麻烦，这是隔离。</li>
<li>性能方面，现在集群 bgp 关闭full mesh，改为global，降低因容器集群规模变大，导致路由过多的问题。</li>
<li>冗余方面，现在每台机器2条线，接2个交换机，bgp 跟2个交换机互联，实现了冗余，所有流量通过 交换机交换，满足了性能跟冗余的要求。</li>
</ul>
<h4 id="Calico-优劣势"><a href="#Calico-优劣势" class="headerlink" title="Calico 优劣势"></a>Calico 优劣势</h4><p>优势</p>
<ul>
<li>BGP RR没有封包和解包过程，完全基于两端宿主机的路由表进行转发</li>
<li>可以配合使用 <code>Network Policy</code> 做 pod 和 pod 之前的访问控制</li>
</ul>
<p>劣势</p>
<ul>
<li>要求宿主机处于同一个2层网络下，也就是连在一台交换机上，但也可以突破</li>
<li>每个node上会设置大量（大量)的iptables规则、路由，运维、排障难度大</li>
<li>安全策略隔离上也略显不足</li>
</ul>
<h3 id="CNI插件性能比较"><a href="#CNI插件性能比较" class="headerlink" title="CNI插件性能比较"></a>CNI插件性能比较</h3><p>基于flannel解包包的路由和转发的操作都是在CPU上进行的，这样就造成了计算资源的浪费。下图是从网上找的各种开源网络组件的性能对比。可以看出，无论是带宽还是网络延迟，性能都和calico主机差不多。</p>
<p><img src="https://i.loli.net/2021/07/14/5r1QBLDSUpcR7Hk.png" alt="image-20210714212457115"></p>
<h2 id="Kubernetes-Service-NodePort-和Ingress"><a href="#Kubernetes-Service-NodePort-和Ingress" class="headerlink" title="Kubernetes Service NodePort 和Ingress"></a>Kubernetes Service NodePort 和Ingress</h2><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>Service 这个 Kubernetes 里重要的服务对象。而 Kubernetes 之所以需要 Service，</p>
<ul>
<li><p>一方面是因为 Pod 的 IP 不是固定的</p>
</li>
<li><p>另一方面则是因为一组 Pod 实例之间总会有负载均衡的需求</p>
</li>
</ul>
<p>实际上，Service 是由 kube-proxy 组件，加上 iptables 来共同实现的。</p>
<blockquote>
<p>并且现在还支持IPVS的模式，kube-proxy 通过 iptables 处理 Service 的过程，其实需要在宿主机上设置相当多的 iptables 规则。而且，kube-proxy 还需要在控制循环里不断地刷新这些规则来确保它们始终是正确的。当pod数量巨大时，成百上千条 iptables 规则不断地被刷新，会大量占用该宿主机的 CPU 资源，甚至会让宿主机“卡”在这个过程中。所以说，一直以来，基于 iptables 的 Service 实现，都是制约 Kubernetes 项目承载更多量级的 Pod 的主要障碍。我们知道IPVS跟IPtables都是工作基于内核的Netfilter 的 NAT 模式工作的，IPVS 并不需要在宿主机上为每个 Pod 设置 iptables 规则，而是把对这些“规则”的处理放到了内核态，从而极大地降低了维护这些规则的代价。所以当集群规模比较大的时候，可以使用ipvs 来提高性能。</p>
</blockquote>
<p>ClusterIP 服务是默认的 Kubernetes Service。它为您提供集群内的服务，集群内的其他应用程序可以访问该服务,默认外部无法访问改地址。如图所示</p>
<p><img src="https://i.loli.net/2021/07/14/5VXtAYkF86OxiNH.png" alt="image-20210714223846542"></p>
<h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><p> NodePort服务是将外部流量直接发送到您的服务的最原始方式。NodePort，顾名思义，在所有节点（VM）上打开一个特定的端口，发送到这个端口的任何流量都会转发到服务，如图所示。</p>
<p><img src="https://i.loli.net/2021/07/14/w8H4RvuPsiJnDzN.png" alt="image-20210714224044599"></p>
<h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><p>Ingress 实际上不是一种服务。相反，它位于多个服务的前面，充当“智能路由器”或集群的入口点。</p>
<p>Ingress 的功能其实很容易理解：所谓 Ingress，就是 Service 的“Service”，如图所示：</p>
<p><img src="https://i.loli.net/2021/07/14/hgznYwIPp87KHJF.png" alt="image-20210714224239095"></p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol>
<li>为什么要用calico </li>
<li>cilium 取代calico</li>
<li>….</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>CKS真题2023</title>
    <url>/posts/afd2cd6e/</url>
    <content><![CDATA[<h2 id="考试心得"><a href="#考试心得" class="headerlink" title="考试心得"></a>考试心得</h2><p>我是去年3月份考的CKA，5月份考了2次都没有过CKS，主要还是因为个人没有复习好，刷题太少，2次考试都没有过。后来又重新找了几篇2023年最新的真题，针对的进行练习。我几次考CKS经验来看，如果考试题目不熟练的话，时间大概率不够的。由于2022年7月份之后考试PSI系统进行了升级，所有操作都要在ubuntu20.04主机上进行，包括浏览器。</p>
<p><img src="/posts/afd2cd6e/1687848678281.png" alt="1687848678281"></p>
<h2 id="第一题-kube-bench-修复不安全项"><a href="#第一题-kube-bench-修复不安全项" class="headerlink" title="第一题 kube-bench 修复不安全项"></a>第一题 kube-bench 修复不安全项</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Context</span><br><span class="line">针对kubeadm创建的cluster运行CIS基准测试工具时，发现了多个必须立即解决的问题。</span><br><span class="line">Task</span><br><span class="line">通过配置修复所有问题并重新启动受影响的组件以确保新的设置生效。</span><br><span class="line">修复针对API服务器发现的所有以下违规行为：</span><br><span class="line">1.2.7 Ensure that the --authorization-mode argument is not <span class="built_in">set</span> to AlwaysAllow FAIL</span><br><span class="line">1.2.8 Ensure that the --authorization-mode argument includes Node             FAIL</span><br><span class="line">1.2.9 Ensure that the --authorization-mode argument includes RBAC             FAIL</span><br><span class="line">1.2.18 Ensure that the --insecure-bind-address argument is not <span class="built_in">set</span>            FAIL (1.23中这项题目没给出，但最好也检查一下，模拟环境里需要改)</span><br><span class="line">1.2.19 Ensure that theinsecure-port argument is <span class="built_in">set</span> te 0                       FAIL(1.23中这项题目没给出，不需要再修改了)</span><br><span class="line">修复针对kubelet发现的所有以下违规行为：</span><br><span class="line">Fix all of the following violations that were found against the kubelet: </span><br><span class="line">4.2.1 Ensure that the anonymous-auth argument is <span class="built_in">set</span> to <span class="literal">false</span>                 FAIL</span><br><span class="line">4.2.2 Ensure that the --authorization-mode argument is not <span class="built_in">set</span> to AlwaysAllow FAIL</span><br><span class="line">注意：尽可能使用Webhook身份验证/授权。</span><br><span class="line"></span><br><span class="line">修复针对etcd发现的所有以下违规行为：</span><br><span class="line">Fix all of the following violations that were found against etcd: </span><br><span class="line">2.2 Ensure that the --client-cert-auth argument is <span class="built_in">set</span> to <span class="literal">true</span>                FAIL</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、先备份kube-apiserver.yaml,etcd.yaml,config.yaml三个文件；</span><br><span class="line">2、修改kube-apiserver.yaml文件，执行vim /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line">   - --authorization-mode=Node,RBAC   <span class="comment">#修改成Node,RBAC</span></span><br><span class="line">   - --insecure-bind-address=0.0.0.0  <span class="comment">#删除这行</span></span><br><span class="line">3、修改config.yaml文件，执行vim /var/lib/kubelet/config.yaml</span><br><span class="line">   authentication:</span><br><span class="line">      anonymous:</span><br><span class="line">        enabled: <span class="literal">false</span>     <span class="comment">#true修改成false</span></span><br><span class="line">   ...</span><br><span class="line">   authorization:</span><br><span class="line">      mode: Webhook        <span class="comment">#把AlwaysAllow修改成Webhook</span></span><br><span class="line">4、修改etcd.yaml文件, vim /etc/kubernetes/manifests/etcd.yaml</span><br><span class="line">   - --client-cert-auth=<span class="literal">true</span>   <span class="comment">#修改成true</span></span><br><span class="line">5、重启kubelet服务</span><br><span class="line">[root@k8s-master manifests]<span class="comment"># systemctl daemon-reload </span></span><br><span class="line">[root@k8s-master manifests]<span class="comment"># systemctl restart kubelet</span></span><br></pre></td></tr></table></figure>

<h2 id="第二题-Pod-指定-ServiceAccount"><a href="#第二题-Pod-指定-ServiceAccount" class="headerlink" title="第二题 Pod 指定 ServiceAccount"></a>第二题 Pod 指定 ServiceAccount</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Context</span><br><span class="line">您组织的安全策略包括：</span><br><span class="line">- ServiceAccount不得自动挂载API凭据</span><br><span class="line">- ServiceAccount名称必须以<span class="string">&quot;-sa&quot;</span>结尾</span><br><span class="line"></span><br><span class="line">清单文件/cks/sa/pod1.yaml中指定的Pod由于ServiceAccount指定错误而无法调度。</span><br><span class="line">请完成一下项目：</span><br><span class="line"></span><br><span class="line">Task</span><br><span class="line">1.在现有namespace ga中创建一个名为backend-sa的新ServiceAccount,</span><br><span class="line">确保此ServiceAccount不自动挂载API凭据。</span><br><span class="line">2.使用/cks/sa/pod1.yaml中的清单文件来创建一个Pod。</span><br><span class="line">3.最后，清理namespace ga中任何未使用的ServiceAccount。</span><br></pre></td></tr></table></figure>

<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参考：&lt;https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/service-accounts-admin/&gt;</span></span><br><span class="line">1、创建sa</span><br><span class="line"><span class="comment"># kubectl create ns qa</span></span><br><span class="line"><span class="comment"># vim sa.yaml </span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: backend-sa</span><br><span class="line">  namespace: qa</span><br><span class="line">automountServiceAccountToken: <span class="literal">false</span>               <span class="comment">#该行是重点，注意事项</span></span><br><span class="line"></span><br><span class="line">2、创建pod</span><br><span class="line"><span class="comment"># cat pod1.yaml </span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: backend</span><br><span class="line">  namespace: qa</span><br><span class="line">spec:</span><br><span class="line">  serviceAccountName: backend-sa                  <span class="comment">#给pod配置serviceaccount</span></span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx:alpine</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: backend</span><br><span class="line"><span class="comment"># kubectl create -f pod1.yaml </span></span><br><span class="line"></span><br><span class="line">3、删除没有使用的sa</span><br><span class="line"><span class="comment"># kubectl -n qa get sa</span></span><br><span class="line"><span class="comment"># kubectl -n qa delete sa test01</span></span><br></pre></td></tr></table></figure>

<h2 id="第三题-默认网络策略"><a href="#第三题-默认网络策略" class="headerlink" title="第三题 默认网络策略"></a>第三题 默认网络策略</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Context</span><br><span class="line">一个默认拒绝(default-deny)的NetworkPolicy可避免在未定义任何其他NetworkPolicy的namespace中意外公开Pod。</span><br><span class="line">Task</span><br><span class="line">为所有类型为Ingress-+Egress的流量在namespace testing中创建一个名为denypolicy的新默认拒绝NetworkPolicy。</span><br><span class="line">此新的NetworkPolicy必须拒绝namespace testing中的所有的Ingress+Egress流量。</span><br><span class="line">将新创建的默认拒绝NetworkPolicy应用与在namespace testing中运行的所有Pod。</span><br><span class="line"></span><br><span class="line">你可以在/cks/net/p1,yaml找到一个模板清单文件。</span><br></pre></td></tr></table></figure>

<p>解答：<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/">网络策略</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、创建默认网络策略</span><br><span class="line"><span class="comment"># kubectl create ns testing</span></span><br><span class="line"><span class="comment"># cat networkpolicy.yaml </span></span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: denypolicy</span><br><span class="line">  namespace: testing</span><br><span class="line">spec:</span><br><span class="line">  podSelector: &#123;&#125;                        <span class="comment">#拒绝所有pod</span></span><br><span class="line">  policyTypes:</span><br><span class="line">    - Ingress</span><br><span class="line">    - Egress</span><br><span class="line">  </span><br><span class="line"><span class="comment"># kubectl apply -f networkpolicy.yaml</span></span><br><span class="line"></span><br><span class="line">2、检查</span><br><span class="line"><span class="comment"># kubectl -n testing describe netpol denypolicy </span></span><br><span class="line">Name:         denypolicy</span><br><span class="line">Namespace:    testing</span><br><span class="line">Created on:   2022-12-28 15:18:22 +0800 CST</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Spec:</span><br><span class="line">  PodSelector:     &lt;none&gt; (Allowing the specific traffic to all pods <span class="keyword">in</span> this namespace)</span><br><span class="line">  Allowing ingress traffic:</span><br><span class="line">    &lt;none&gt; (Selected pods are isolated <span class="keyword">for</span> ingress connectivity)</span><br><span class="line">  Allowing egress traffic:</span><br><span class="line">    &lt;none&gt; (Selected pods are isolated <span class="keyword">for</span> egress connectivity)</span><br><span class="line">  Policy Types: Ingress, Egress</span><br></pre></td></tr></table></figure>

<h2 id="第四题-RBAC-RoleBingding"><a href="#第四题-RBAC-RoleBingding" class="headerlink" title="第四题 RBAC - RoleBingding"></a>第四题 RBAC - RoleBingding</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Context</span><br><span class="line">绑定到Pod的ServiceAccount的Role授予过度宽松的权限。完成以下项目以减少权限集。</span><br><span class="line">Task</span><br><span class="line">一个名为web-pod的现有Pod已在namespace db中运行。</span><br><span class="line">编辑绑定到Pod的ServiceAccount service-account-web的现有Role,仅允许只对services类型的资源执行get操作。</span><br><span class="line">在namespace db中创建一个名为role-2,并仅允许只对namespaces类型的资源执行delete操作的新Role。</span><br><span class="line">创建一个名为role-2-binding的新RoleBinding,将新创建的Role绑定到Pod的ServiceAccount。</span><br><span class="line">注意：请勿删除现有的RoleBinding。</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、本地测试环境</span><br><span class="line"><span class="comment"># kubectl create ns db</span></span><br><span class="line"><span class="comment"># kubectl -n db create sa service-account-web</span></span><br><span class="line"><span class="comment"># kubectl -n db create role role-1</span></span><br><span class="line"><span class="comment"># kubectl -n db create role role-1 --verb=get,list,watch --resource=&#x27;*&#x27;</span></span><br><span class="line"><span class="comment"># kubectl -n db create rolebinding role-1-binding --role=&#x27;role-1&#x27; --serviceaccount=&#x27;db:service-account-web&#x27;</span></span><br><span class="line"><span class="comment"># cat pod1.yaml </span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: web-pod</span><br><span class="line">  namespace: db</span><br><span class="line">spec:</span><br><span class="line">  serviceAccountName: service-account-web</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx:alpine</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: web-pod</span><br><span class="line">2、答题</span><br><span class="line"><span class="comment"># kubectl -n db edit role role-1</span></span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2022-12-28T07:48:59Z&quot;</span></span><br><span class="line">  name: role-1</span><br><span class="line">  namespace: db</span><br><span class="line">  resourceVersion: <span class="string">&quot;224470&quot;</span></span><br><span class="line">  uid: 3406bbfb-25aa-4930-ab29-9abad1e1de77</span><br><span class="line">rules:</span><br><span class="line">- apiGroups:</span><br><span class="line">  - <span class="string">&quot;&quot;</span></span><br><span class="line">  resources:</span><br><span class="line">  - services                        <span class="comment">#按题目要求修改此处</span></span><br><span class="line">  verbs:</span><br><span class="line">  - get                             <span class="comment">#按题目要求修改此处</span></span><br><span class="line"></span><br><span class="line">检查</span><br><span class="line"><span class="comment"># kubectl -n db describe role role-1</span></span><br><span class="line">Name:         role-1</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources  Non-Resource URLs  Resource Names  Verbs</span><br><span class="line">  ---------  -----------------  --------------  -----</span><br><span class="line">  services   []                 []              [get]</span><br><span class="line"></span><br><span class="line">创建role-2</span><br><span class="line"><span class="comment"># kubectl -n db create role role-2 --resource=&#x27;namespace&#x27; --verb=&#x27;delete&#x27; </span></span><br><span class="line">role.rbac.authorization.k8s.io/role-2 created</span><br><span class="line"><span class="comment"># kubectl -n db describe role role-2 </span></span><br><span class="line">Name:         role-2</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources   Non-Resource URLs  Resource Names  Verbs</span><br><span class="line">  ---------   -----------------  --------------  -----</span><br><span class="line">  namespaces  []                 []              [delete]</span><br><span class="line"></span><br><span class="line">创建新rolebinding</span><br><span class="line"><span class="comment"># kubectl -n db create rolebinding role-2-binding --role=&#x27;role-2&#x27; --serviceaccount=&#x27;db:service-account-web&#x27;</span></span><br><span class="line"><span class="comment"># kubectl -n db describe rolebindings.rbac.authorization.k8s.io role-2-binding </span></span><br><span class="line">Name:         role-2-binding</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Role:</span><br><span class="line">  Kind:  Role</span><br><span class="line">  Name:  role-2</span><br><span class="line">Subjects:</span><br><span class="line">  Kind            Name                 Namespace</span><br><span class="line">  ----            ----                 ---------</span><br><span class="line">  ServiceAccount  service-account-web  db</span><br></pre></td></tr></table></figure>

<h2 id="第五题-日志审计-log-audit-（建议最后做，比较耗时，易错题）"><a href="#第五题-日志审计-log-audit-（建议最后做，比较耗时，易错题）" class="headerlink" title="第五题 日志审计 log audit （建议最后做，比较耗时，易错题）"></a>第五题 日志审计 log audit （建议最后做，比较耗时，易错题）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在cluster中启用审计日志。为此，请启用日志后端，并确保：</span><br><span class="line">- 日志存储在 /var/<span class="built_in">log</span>/kubernetes/.audit-logs.txt</span><br><span class="line">- 日志文件能保留10天</span><br><span class="line">- 最多保留2个旧审计日志文件</span><br><span class="line"></span><br><span class="line">/etc/kubernetes/logpolicy/sample-policy.yaml提供了基本策略。它仅指定不记录的内容。</span><br><span class="line">注意：基本策略位于cluster的master节点上。</span><br><span class="line"></span><br><span class="line">编辑和扩展基本策略以记录：</span><br><span class="line">- RequestResponse 级别的 persistentvolumes更改</span><br><span class="line">- namespace front-apps 中 configmaps 更改的请求体</span><br><span class="line">- Metadata 级别的所有 namespace 中的 ConfigMap 和 Secret 的更改</span><br><span class="line">此外，添加一个全方位的规则以在Metadata级别记录所有其他请求。</span><br><span class="line">注意：不要忘记应用修改后的策略。</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 准备环境</span></span><br><span class="line"><span class="comment"># kubectl create ns front-apps</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1.官网文档搜索：audit，可以找到对应策略policy文件模板，并根据要求进行修改生产如下配置文件</span></span><br><span class="line"><span class="comment"># cat /etc/kubernetes/logpolicy/sample-policy.yaml </span></span><br><span class="line"></span><br><span class="line">apiVersion: audit.k8s.io/v1 </span><br><span class="line">kind: Policy</span><br><span class="line">omitStages:</span><br><span class="line">  - <span class="string">&quot;RequestReceived&quot;</span></span><br><span class="line">rules:</span><br><span class="line">  - level: RequestResponse</span><br><span class="line">    resources:</span><br><span class="line">    - group: <span class="string">&quot;&quot;</span></span><br><span class="line">      resources: [<span class="string">&quot;persistentvolumes&quot;</span>]</span><br><span class="line"></span><br><span class="line">  - level: Request</span><br><span class="line">    resources:</span><br><span class="line">    - group: <span class="string">&quot;&quot;</span> </span><br><span class="line">      resources: [<span class="string">&quot;configmaps&quot;</span>]</span><br><span class="line">    namespaces: [<span class="string">&quot;front-apps&quot;</span>]</span><br><span class="line"></span><br><span class="line">  - level: Metadata</span><br><span class="line">    resources:</span><br><span class="line">    - group: <span class="string">&quot;&quot;</span> </span><br><span class="line">      resources: [<span class="string">&quot;secrets&quot;</span>, <span class="string">&quot;configmaps&quot;</span>]</span><br><span class="line"></span><br><span class="line">  - level: Metadata</span><br><span class="line">    omitStages:</span><br><span class="line">      - <span class="string">&quot;RequestReceived&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.备份kube-apiserver.yaml文件，然后修改/etc/kubernetes/manifests/kube-apiserver.yaml，增加如下内容：</span></span><br><span class="line">    - --audit-log-path=/var/<span class="built_in">log</span>/kubernetes/audit-log.txt</span><br><span class="line">    - --audit-log-maxage=10</span><br><span class="line">    - --audit-log-maxbackup=2</span><br><span class="line">    - --audit-policy-file=/etc/kube</span><br><span class="line">    ...</span><br><span class="line">    volumeMounts:</span><br><span class="line">      - mountPath: /var/<span class="built_in">log</span>/kubernetes</span><br><span class="line">        name: audit-log</span><br><span class="line">        readOnly: <span class="literal">false</span></span><br><span class="line">      - mountPath: /etc/kubernetes/logpolicy</span><br><span class="line">        name: audit</span><br><span class="line">        readOnly: <span class="literal">true</span></span><br><span class="line">    volumes:</span><br><span class="line">      - hostPath:</span><br><span class="line">          path: /var/<span class="built_in">log</span>/kubernetes</span><br><span class="line">          <span class="built_in">type</span>: DirectoryOrCreate</span><br><span class="line">        name: audit-log</span><br><span class="line">      - hostPath:</span><br><span class="line">          path: /etc/kubernetes/logpolicy</span><br><span class="line">          <span class="built_in">type</span>: DirectoryOrCreate</span><br><span class="line">        name: audit</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3.重启kubelet</span></span><br><span class="line"><span class="comment"># systemctl daemon-reload </span></span><br><span class="line"><span class="comment"># systemctl restart kubelet</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.检查</span></span><br><span class="line"><span class="comment"># tail -f /var/log/kubernetes/audit-log.txt</span></span><br></pre></td></tr></table></figure>

<h2 id="第六题-创建Secret"><a href="#第六题-创建Secret" class="headerlink" title="第六题 创建Secret"></a>第六题 创建Secret</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Task</span><br><span class="line">在namespace istio-system中获取名为db1-test的现有secret的内容</span><br><span class="line"></span><br><span class="line">将username字段存储在名为/cks/sec/user.txt的文件中，并将password字段存储在名为/cks/sec/pass.txt的文件中。</span><br><span class="line">注意：你必须创建以上两个文件，他们还不存在。</span><br><span class="line"></span><br><span class="line">注意：不要在以下步骤中使用/修改先前创建的文件，如果需要，可以创建新的临时文件。</span><br><span class="line"></span><br><span class="line">在istio-system namespace中创建一个名为db2-test的新secret,内容如下：</span><br><span class="line">username:production-instance</span><br><span class="line">password KvLftKgs4aVH</span><br><span class="line"></span><br><span class="line">最后，创建一个新的Pod,它可以通过卷访问secret db2-test:</span><br><span class="line">Pod名称secret-pod</span><br><span class="line">Namespace istio-system</span><br><span class="line">容器名dev-container</span><br><span class="line">镜像 nginx</span><br><span class="line">卷名secret-volume</span><br><span class="line">挂载路径/etc/secret</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#环境准备</span></span><br><span class="line"><span class="comment"># kubectl create ns istio-system </span></span><br><span class="line"><span class="comment"># kubectl -n istio-system create secret generic db1-test --from-literal=username=db1 --from-literal=password=hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.查看secret</span></span><br><span class="line"><span class="comment"># kubectl -n istio-system get  secrets db1-test -o yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  password: aGVsbG8=</span><br><span class="line">  username: ZGIx</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2022-12-29T08:24:22Z&quot;</span></span><br><span class="line">  name: db1-test</span><br><span class="line">  namespace: istio-system</span><br><span class="line">  resourceVersion: <span class="string">&quot;252538&quot;</span></span><br><span class="line">  uid: 1821cc24-a8a1-4a81-ab80-a1a4ad787ccf</span><br><span class="line"><span class="built_in">type</span>: Opaque</span><br><span class="line"><span class="comment"># mkdir -p /cks/sec</span></span><br><span class="line"><span class="comment"># echo &quot;ZGIx&quot; |base64 -d &gt; /cks/sec/user.txt</span></span><br><span class="line"><span class="comment"># echo &quot;aGVsbG8=&quot; |base64 -d &gt; /cks/sec/pass.txt</span></span><br><span class="line"><span class="comment"># kubectl -n istio-system create secret generic db2-test --from-literal=username=production-instance --from-literal=password=KvLftKgs4aVH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.创建pod引用secret</span></span><br><span class="line"><span class="comment"># 在官网文档搜secret关键字，参考文档创建pod</span></span><br><span class="line"><span class="comment"># cat pod.yaml </span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: secret-pod</span><br><span class="line">  namespace: istio-system</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: dev-container</span><br><span class="line">    image: nginx</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: secret-volume</span><br><span class="line">      mountPath: <span class="string">&quot;/etc/secret&quot;</span></span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">  volumes:</span><br><span class="line">  - name: secret-volume</span><br><span class="line">    secret:</span><br><span class="line">      secretName: db2-test</span><br></pre></td></tr></table></figure>

<h2 id="第7题-dockerfile检测"><a href="#第7题-dockerfile检测" class="headerlink" title="第7题 dockerfile检测"></a>第7题 dockerfile检测</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Task</span><br><span class="line">分析和编辑给定的Dockerfile/cs/docken/Dockerfile(基于ubuntu:16.04镜像).</span><br><span class="line">并修复在文件中拥有的突出的安全/最佳实践问题的两个指令。</span><br><span class="line"></span><br><span class="line">分析和编辑给定的清单文件Icks/docker/.deploymentyaml,</span><br><span class="line">并修复在文件中拥有突出的安全/最佳实践问题的两个字段。</span><br><span class="line"></span><br><span class="line">注意：请勿添加或别除配置设置：只需修改现有的配置设置让以上两个配置设置都不再有安全/最佳实践问题。</span><br><span class="line"></span><br><span class="line">注意：如果您需要非特权用户来执行任何项目。</span><br><span class="line">2使用用户1D65535的用户nobody·</span><br><span class="line"></span><br><span class="line">只修改即可。不需要创建。</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、修改/cks/docker/Dockerfile文件，如上截图，vim /cks/docker/Dockerfile, 修改如下：</span></span><br><span class="line">USER root --》 USER nobody</span><br><span class="line">FROM ubuntu:last   --&gt;FROM ubuntn:16.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、修改/cks/docker/deployment.yaml文件，文件内容如下截图，vim /cks/docker/deployment.yaml，修改如下：</span></span><br><span class="line">在安全内容里删除<span class="string">&#x27;SYS_ADMIN&#x27;</span>；</span><br><span class="line"><span class="comment"># 注意，deployment.yaml 配置中template 中字段没有和上面metadata字段进行匹配。</span></span><br><span class="line">在template字段里把lables标签的run: couchdb 改成 app: couchdb，并增加一行：version: stable</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第8题-沙箱运行容器gVisor"><a href="#第8题-沙箱运行容器gVisor" class="headerlink" title="第8题 沙箱运行容器gVisor"></a>第8题 沙箱运行容器gVisor</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Context</span><br><span class="line">该cluster使用containerd作为CRl运行时。containerd的默认运行时处理程序是runc。</span><br><span class="line">containerd已准备好支持额外的运行时处理程序unsc(gVisor)。</span><br><span class="line">Task</span><br><span class="line">使用名为runsc的现有运行时处理程序，创建一个名为untrusted的RuntimeClass。</span><br><span class="line">更新namespace server中的所有Pod以在gVisor上运行。</span><br><span class="line">您可以在/cks/gVisor/rc.yaml中找到一个模版清单。</span><br></pre></td></tr></table></figure>

<p>解答：<a href="https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/">容器运行时类</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 环境准备</span></span><br><span class="line"><span class="comment"># kubectl create ns server</span></span><br><span class="line"><span class="comment"># kubectl -n server create deploy nginx-host --image=nginx:alpine --replicas=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建runtimeclass</span></span><br><span class="line"><span class="comment"># cat rc.yaml </span></span><br><span class="line">apiVersion: node.k8s.io/v1</span><br><span class="line">kind: RuntimeClass</span><br><span class="line">metadata:</span><br><span class="line">  name: untrusted</span><br><span class="line">handler: runsc</span><br><span class="line"><span class="comment"># kubectl apply -f rc.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.更新namespace server中的所有pod以在gvisor上运行</span></span><br><span class="line"><span class="comment"># kubectl -n server edit deploy nginx-host</span></span><br><span class="line">runtimeClassName: untrusted    <span class="comment"># 增加这一行</span></span><br></pre></td></tr></table></figure>

<h2 id="第9题-容器安全，删除特权-Pod-旧"><a href="#第9题-容器安全，删除特权-Pod-旧" class="headerlink" title="第9题 容器安全，删除特权 Pod (旧)"></a>第9题 容器安全，删除特权 Pod (旧)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Context</span><br><span class="line">最佳实践是将容器设计为无状态和不可变的。</span><br><span class="line">Task</span><br><span class="line">检查在namespace production中运行的Pod,并制除任何非无状态或非不可变的Pod。</span><br><span class="line">使用以下对无状态和不可变的严格解释：</span><br><span class="line">- 能够在容器内存储数据的Pod的容器必须被视为非无状态的。</span><br><span class="line">  注意：你不必担心数据是否实际上已经存储在容器中。</span><br><span class="line">- 被配置为任何形式的特权Pod必须被视为可能是非无状态和非不可变的。</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 环境准备</span></span><br><span class="line"><span class="comment"># kubectl create namespace production</span></span><br><span class="line"><span class="comment"># kubectl -n production run pri001 --image=nginx:alpine  --privileged=true</span></span><br><span class="line"><span class="comment"># kubectl -n production run pri002 --image=nginx:1.19  --privileged=true</span></span><br><span class="line"><span class="comment"># vim pod.yaml </span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pd</span><br><span class="line">  namespace: production</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx:alpine</span><br><span class="line">    name: test-container</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /test-pd</span><br><span class="line">      name: test-volume</span><br><span class="line">  volumes:</span><br><span class="line">  - name: test-volume</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /data</span><br><span class="line"><span class="comment"># kubecrl apply -f pod.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">[root@k8s-master 09]<span class="comment"># kubectl get pod -n production </span></span><br><span class="line">NAME      READY   STATUS    RESTARTS   AGE</span><br><span class="line">pri001    1/1     Running   0          28m</span><br><span class="line">pri002    1/1     Running   0          6m55s</span><br><span class="line">test-pd   1/1     Running   0          2m23s</span><br><span class="line">[root@k8s-master 09]<span class="comment"># kubectl -n production get pod pri001 -o yaml |grep -i &#x27;privileged: true&#x27;</span></span><br><span class="line">      privileged: <span class="literal">true</span></span><br><span class="line">[root@k8s-master 09]<span class="comment"># kubectl -n production delete pod pri001</span></span><br><span class="line">pod <span class="string">&quot;pri001&quot;</span> deleted</span><br><span class="line">[root@k8s-master 09]<span class="comment"># kubectl -n production get pod pri002 -o yaml |grep -i &#x27;privileged: true&#x27;</span></span><br><span class="line">      privileged: <span class="literal">true</span></span><br><span class="line">[root@k8s-master 09]<span class="comment"># kubectl -n production delete pod pri002</span></span><br><span class="line">pod <span class="string">&quot;pri002&quot;</span> deleted</span><br><span class="line">[root@k8s-master 09]<span class="comment"># kubectl -n production get pod test-pd -o yaml |grep -i &#x27;privileged: true&#x27;</span></span><br><span class="line">[root@k8s-master 09]<span class="comment"># kubectl -n production get pod test-pd -o yaml |grep -i &#x27;hostPath&#x27;</span></span><br><span class="line">      &#123;<span class="string">&quot;apiVersion&quot;</span>:<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;kind&quot;</span>:<span class="string">&quot;Pod&quot;</span>,<span class="string">&quot;metadata&quot;</span>:&#123;<span class="string">&quot;annotations&quot;</span>:&#123;&#125;,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;test-pd&quot;</span>,<span class="string">&quot;namespace&quot;</span>:<span class="string">&quot;production&quot;</span>&#125;,<span class="string">&quot;spec&quot;</span>:&#123;<span class="string">&quot;containers&quot;</span>:[&#123;<span class="string">&quot;image&quot;</span>:<span class="string">&quot;nginx:alpine&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;test-container&quot;</span>,<span class="string">&quot;volumeMounts&quot;</span>:[&#123;<span class="string">&quot;mountPath&quot;</span>:<span class="string">&quot;/test-pd&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;test-volume&quot;</span>&#125;]&#125;],<span class="string">&quot;volumes&quot;</span>:[&#123;<span class="string">&quot;hostPath&quot;</span>:&#123;<span class="string">&quot;path&quot;</span>:<span class="string">&quot;/data&quot;</span>&#125;,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;test-volume&quot;</span>&#125;]&#125;&#125;</span><br><span class="line">  - hostPath:</span><br><span class="line">[root@k8s-master 09]<span class="comment"># kubectl -n production delete pod test-pd </span></span><br><span class="line">pod <span class="string">&quot;test-pd&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h2 id="第9题-container-安全上下文（新）"><a href="#第9题-container-安全上下文（新）" class="headerlink" title="第9题 container 安全上下文（新）"></a>第9题 container 安全上下文（新）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Context</span><br><span class="line">Container Security Context应在特定namespace中修改Deployment。</span><br><span class="line">Task</span><br><span class="line">按照如下要求修改sec-ns命名空间里的Deployment secdep</span><br><span class="line">1、用ID为30000的用户启动容器（设置用户1D为：30000）</span><br><span class="line">2、不允许进程获得超出其父进程的特权（禁止allowPrivilegeEscalation)</span><br><span class="line">3、以只读方式加载容器的根文件系统（对根文件的只读权限）</span><br></pre></td></tr></table></figure>

<p>解答：<a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/">容器安全上下文</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl -n sec-ns edit deploy secdep  </span></span><br><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  securityContext:                        <span class="comment">#增加这两行完成任务1</span></span><br><span class="line">    runAsUser: 30000</span><br><span class="line">  ...</span><br><span class="line">  containers:               </span><br><span class="line">    securityContext:                      <span class="comment">#增加这三行完成任务2，3</span></span><br><span class="line">      allowPrivilegeEscalation: <span class="literal">false</span></span><br><span class="line">      readOnlyRootFilesystem: <span class="literal">true</span></span><br><span class="line">  ...</span><br><span class="line">  containers:                             <span class="comment">#如果有多个容器，每个容器都要增加这三行</span></span><br><span class="line">    securityContext:</span><br><span class="line">      allowPrivilegeEscalation: <span class="literal">false</span></span><br><span class="line">      readOnlyRootFilesystem: <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看状态是否都正常运行</span></span><br><span class="line"><span class="comment"># kubectl -n sec-ns get all</span></span><br></pre></td></tr></table></figure>

<h2 id="第10题-网络策略-NetworkPolicy"><a href="#第10题-网络策略-NetworkPolicy" class="headerlink" title="第10题 网络策略 NetworkPolicy"></a>第10题 网络策略 NetworkPolicy</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Task</span><br><span class="line">创建一个名为pod-restriction的NetworkPolicy来限制对在namespace dev-team中运行的Pod products-service的访问。</span><br><span class="line">只允许以下Pod连接到Pod products-service</span><br><span class="line">- namespace gaga中的Pod</span><br><span class="line">- 位于任何namespace,带有标签environment:testing的Pod</span><br><span class="line"></span><br><span class="line">注意：确保应用NetworkPolicy,.</span><br><span class="line"></span><br><span class="line">你可以在/cks/net/po.yaml找到一个模板清单文件，</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 准备环境</span></span><br><span class="line"><span class="comment"># kubectl create namespace dev-team</span></span><br><span class="line"><span class="comment"># kubectl label ns qaqa name=qaqa     #如果没有对命名空间打标签，则需要手动打标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># kubecrl get pod -n dev-team --show-label</span></span><br><span class="line"><span class="comment"># cat netpol.yaml </span></span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: NetworkPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-restriction</span><br><span class="line">  namespace: dev-team</span><br><span class="line">spec:</span><br><span class="line">  podSelector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      environment: testing</span><br><span class="line">  policyTypes:</span><br><span class="line">    - Ingress</span><br><span class="line">  ingress:</span><br><span class="line">    - from:</span><br><span class="line">        - namespaceSelector:</span><br><span class="line">            matchLabels:</span><br><span class="line">              name: qaqa</span><br><span class="line">    - from:</span><br><span class="line">       - namespaceSelector: &#123;&#125;</span><br><span class="line">         podSelector:</span><br><span class="line">           matchLabels:</span><br><span class="line">             environment: testing</span><br><span class="line">   </span><br><span class="line"><span class="comment"># kubectl create -f netpol.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl -n dev-team describe networkpolicies.networking.k8s.io pod-restriction </span></span><br><span class="line">Name:         pod-restriction</span><br><span class="line">Namespace:    dev-team</span><br><span class="line">Created on:   2022-12-29 19:56:59 +0800 CST</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Spec:</span><br><span class="line">  PodSelector:     environment=testing</span><br><span class="line">  Allowing ingress traffic:</span><br><span class="line">    To Port: &lt;any&gt; (traffic allowed to all ports)</span><br><span class="line">    From:</span><br><span class="line">      NamespaceSelector: name=qa</span><br><span class="line">    ----------</span><br><span class="line">    To Port: &lt;any&gt; (traffic allowed to all ports)</span><br><span class="line">    From:</span><br><span class="line">      NamespaceSelector: &lt;none&gt;</span><br><span class="line">      PodSelector: environment=testing</span><br><span class="line">  Not affecting egress traffic</span><br><span class="line">  Policy Types: Ingress</span><br></pre></td></tr></table></figure>

<h2 id="第11题-Trivy-扫描镜像安全漏洞"><a href="#第11题-Trivy-扫描镜像安全漏洞" class="headerlink" title="第11题 Trivy 扫描镜像安全漏洞"></a>第11题 Trivy 扫描镜像安全漏洞</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Task</span><br><span class="line">使用Triy开源容器扫描器检测namespace kamino中Pod使用的具有严重漏洞的镜像。</span><br><span class="line"></span><br><span class="line">查找具有High或Critical严重性漏闲的镜像，并测除使用这些镜像的Pod。</span><br><span class="line"></span><br><span class="line">注意：Triy仅安装在cluster的master节点上，</span><br><span class="line">在工作节点上不可使用。</span><br><span class="line">你必须切换到cluster的master节点才能使用Ty。</span><br></pre></td></tr></table></figure>

<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 环境准备</span></span><br><span class="line"><span class="comment"># kubectl create ns kamino</span></span><br><span class="line">安装trivy漏洞扫描工具</span><br><span class="line"><span class="comment"># rpm -ivh &lt;https://github.com/aquasecurity/trivy/releases/download/v0.22.0/trivy_0.22.0_Linux-64bit.rpm&gt;</span></span><br><span class="line"><span class="comment"># kubectl -n kamino run nginx-11-pod --image=nginx:1.13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 答题</span></span><br><span class="line"><span class="comment"># kubectl -n kamino get pod nginx-11-pod -o yaml|grep -i &quot;image:&quot;</span></span><br><span class="line">  - image: nginx:1.13</span><br><span class="line">    image: docker.io/library/nginx:1.13</span><br><span class="line"></span><br><span class="line"><span class="comment"># trivy image --severity HIGH,CRITICAL docker.io/library/nginx:1.13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl get pods --namespace default --output=custom-columns=&quot;NAME:.metadata.name,IMAGE:.spec.containers[*].image&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="第12题-AppArmor-（易错）"><a href="#第12题-AppArmor-（易错）" class="headerlink" title="第12题 AppArmor （易错）"></a>第12题 AppArmor （易错）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Context</span><br><span class="line">APPArmor 已在 cluster 的工作节点上被启用。一个 APPArmor 配置文件已存在，但尚未被实施</span><br><span class="line"></span><br><span class="line">Task</span><br><span class="line">在 cluster 的工作节点上，实施位于 /etc/apparmor.d/nginx_apparmor 的现有 APPArmor配置文件。 </span><br><span class="line">编辑位于 /home/candidate/KSSH00401/nginx-deploy.yaml 的现有清单文件以应用AppArmor 配置文件。 最后，应用清单文件并创建其中指定的 Pod 。</span><br></pre></td></tr></table></figure>

<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用apparmor_status 命令可以查看内核加载了哪些</span></span><br><span class="line">apparmor_status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.查看文件，并加载该文件</span></span><br><span class="line">cat /etc/apparmor.d/nginx_apparmor</span><br><span class="line"><span class="comment">#include &lt;tunables/global&gt;</span></span><br><span class="line">profile nginx-profile flags=(attach_disconnected) &#123;</span><br><span class="line">  <span class="comment">#include &lt;abstractions/base&gt;</span></span><br><span class="line">  file,</span><br><span class="line">  <span class="comment"># Deny all file writes.</span></span><br><span class="line">  <span class="comment"># 拒绝所有对文件写的操作</span></span><br><span class="line">  deny /** w,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssh node1</span><br><span class="line">apparmor_parser -q /etc/apparmor.d/nginx_apparmor</span><br><span class="line">apparmor_status | grep nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.修改pod文件增加注解,官网搜关键字apparmor，参考官网提示</span></span><br><span class="line">metadata:</span><br><span class="line">  name: hello-apparmor</span><br><span class="line">  annotations:</span><br><span class="line">    container.apparmor.security.beta.kubernetes.io/podx: localhost/nginx-profile</span><br><span class="line"><span class="comment"># 注意必须加入这一串：container.apparmor.security.beta.kubernetes.io/&lt;容器名&gt;: localhost/&lt;策略&gt;表示该容器启动时必须遵守配置的Apparmor策略规则。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.验证</span></span><br><span class="line"><span class="comment"># kubectl exec -it podx -- cat -- cat /proc/1/attr/current</span></span><br><span class="line"><span class="comment"># kubectl exec podx -- touch /tmp/test</span></span><br></pre></td></tr></table></figure>

<h2 id="第13题-Sysdig-amp-falco"><a href="#第13题-Sysdig-amp-falco" class="headerlink" title="第13题 Sysdig &amp; falco"></a>第13题 Sysdig &amp; falco</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Task： 使用运行时检测工具来检测 Pod tomcat123 单个容器中频发生成和执行的异常进程。 </span><br><span class="line"></span><br><span class="line">有两种工具可供使用： </span><br><span class="line">- sysdig</span><br><span class="line">- falco </span><br><span class="line">注： 这些工具只预装在 cluster 的工作节点node02，不在 master 节点。 </span><br><span class="line"></span><br><span class="line">使用工具至少分析 30 秒，使用过滤器检查生成和执行的进程，将事件写到 /opt/KSR00101/incidents/summary 文 件中，其中包含检测的事件， 格式如下： [timestamp],[uid],[processName] 保持工具的原始时间戳格式不变。 </span><br><span class="line">注：确保事件文件存储在集群的工作节点上。</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.环境准备</span></span><br><span class="line"><span class="comment"># 在工作节点上一键安装sysdig</span></span><br><span class="line"><span class="comment"># curl -s &lt;https://s3.amazonaws.com/download.draios.com/stable/install-sysdig&gt; | sudo bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.找到containerd 的socket</span></span><br><span class="line">crictl info | grep sock</span><br><span class="line"><span class="string">&quot;containerdEndpoint&quot;</span>: <span class="string">&quot;/run/containerd/containerd.sock&quot;</span>,</span><br><span class="line"><span class="comment"># 2.使用crictl命令找到容器tomcat123，这里注意是container 名字：tomcat123。</span></span><br><span class="line">crictl ps | grep tomcat123</span><br><span class="line"><span class="comment"># 3.通过 sysdig 扫描容器30s并输出到指定文件：</span></span><br><span class="line"><span class="comment"># sysdig -h 和-l 查看帮助</span></span><br><span class="line">sysdig -l | grep time</span><br><span class="line">sysdig -l | grep uid</span><br><span class="line">sysdig -l | grep proc</span><br><span class="line"><span class="comment"># 完整命令</span></span><br><span class="line">sysdig -M 30 -p <span class="string">&quot;%evt.time,%user.name,%proc.name&quot;</span> --cri /run/containerd/containerd.sock container.name=tomcat123 &gt;&gt; /opt/KSR00101/incidents/summary</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示：如果考试时执行sysdig报错“Unable to load the driver”，则执行下面一条命令：（模拟环境里不需要执行）</span></span><br><span class="line">sysdig-probe-loader</span><br></pre></td></tr></table></figure>

<h2 id="第14题-TLS通信加强（新题）"><a href="#第14题-TLS通信加强（新题）" class="headerlink" title="第14题 TLS通信加强（新题）"></a>第14题 TLS通信加强（新题）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Task</span><br><span class="line">通过TLS加强kube-apiserver安全配置，要求</span><br><span class="line">1、kube-apiserver除了VersionTLS13及以上的版本可以使用，其他版本都不允许使用。</span><br><span class="line">2、密码套件（Cipher suite）为TLS_AES_128_GCM_SHA256</span><br><span class="line"></span><br><span class="line">通过TLS加强ETCD安全配置，要求</span><br><span class="line">1、密码套件（Cipher suite）为TLS_AES_128_GCM_SHA256</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.加强apiserver安全配置，解题只需要官网搜索VersionTLS13 ，会查找到apiserver配置参数</span></span><br><span class="line"><span class="comment"># 1.1、--tls-min-version string 支持最低的TLS版本</span></span><br><span class="line">vim /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line">- --tls-min-version=VersionTLS13</span><br><span class="line"><span class="comment"># 1.2、--tls-cipher-suites strings 服务器的密码套件，搜索TLS_AES_128_GCM_SHA256</span></span><br><span class="line">- --tls-cipher-suites=TLS_AES_128_GCM_SHA256</span><br><span class="line"><span class="comment"># 2.TLS加强ETCD安全配置,类似apiserver 的服务加密套件配置,可以使用etcd帮助手册查找启动参数：etcd --help</span></span><br><span class="line">- --cipher-suites=TLS_AES_128_GCM_SHA256</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第15题-启用-API-server-认证"><a href="#第15题-启用-API-server-认证" class="headerlink" title="第15题 启用 API server 认证"></a>第15题 启用 API server 认证</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Context </span><br><span class="line">由 kubeadm 创建的 cluster 的 Kubernetes API 服务器，出于测试目的，临时配置允许未经身份验证和未经授权的访问，授予匿名用户 cluster-admin 的访问权限. </span><br><span class="line"></span><br><span class="line">Task </span><br><span class="line">重新配置 cluster 的Kubernetes APl 服务器，以确保只允许经过身份验证和授权的 REST 请求。 </span><br><span class="line">使用授权模式 Node,RBAC 和准入控制器NodeRestriction。 </span><br><span class="line">删除用户 system:anonymous 的 ClusterRoleBinding 来进行清理。</span><br><span class="line"></span><br><span class="line">注意：所有 kubectl 配置环境/文件也被配置使用未经身份验证和未经授权的访问。 你不必更改它，但请注意，一旦完成 cluster的安全加固， kubectl 的配置将无法工作。 您可以使用位于 cluster 的 master 节点上，cluster 原本的kubectl 配置文件 /etc/kubernetes/admin.conf ，以确保经过身份验证的授权的请求仍然被允许。</span><br></pre></td></tr></table></figure>

<p>解答：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.修改api-server配置，官方文档搜索：RBAC。配置参考：&lt;https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/&gt;</span></span><br><span class="line"><span class="comment"># 增加配置</span></span><br><span class="line">vim /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line">- --authorization-mode=Node,RBAC</span><br><span class="line"><span class="comment"># 2.官方文档搜索:准入控制器：配置参考：&lt;https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/&gt;</span></span><br><span class="line">- --enable-admission-plugins=NodeRestriction</span><br><span class="line"><span class="comment"># 重启一下 kubelet会重新认证</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br><span class="line"><span class="comment"># 3.删除system:anonymous</span></span><br><span class="line"><span class="comment"># kubectl delete clusterrolebinding system:anonymous</span></span><br><span class="line"><span class="comment"># kubectl get pod -A --kube-config=/etc/kubernetes/admin.conf</span></span><br></pre></td></tr></table></figure>

<h2 id="第16题-ImagePolicyWebhook容器镜像扫描"><a href="#第16题-ImagePolicyWebhook容器镜像扫描" class="headerlink" title="第16题 ImagePolicyWebhook容器镜像扫描"></a>第16题 ImagePolicyWebhook容器镜像扫描</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Context </span><br><span class="line">cluster 上设置了容器镜像扫描器，但尚未完全集成到 cluster 的配置中。</span><br><span class="line">完成后，容器镜像扫描器应扫描并拒绝易受攻击的镜像的使用。 </span><br><span class="line"></span><br><span class="line">Task </span><br><span class="line">注意：你必须在 cluster 的 master节点上完成整个考题，所有服务和文件都已被准备好并放置在该节点上。 </span><br><span class="line">给定一个目录 /etc/kubernetes/epconfig中不完整的配置以及具有 HTTPS 端点 &lt;https://acme.local:8082/image_policy&gt; 的功能性容器镜像扫描器：</span><br><span class="line">	1. 启用必要的插件来创建镜像策略 </span><br><span class="line">	2. 校验控制配置并将其更改为隐式拒绝（implicit deny） </span><br><span class="line">	3. 编辑配置以正确指向提供的 HTTPS 端点 </span><br><span class="line">最后，通过尝试部署易受攻击的资源 /cks/img/web1.yaml 来测试配置是否有效。 </span><br><span class="line">你可以在/var/<span class="built_in">log</span>/imagepolicy/roadrunner.log 找到容器镜像扫描仪的日志文件。</span><br></pre></td></tr></table></figure>

<p>解答</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该题目依旧是准入控制范畴，官方文档搜索：准入控制器或ImagePolicyWebhook，参考文档：&lt;https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/&gt;</span></span><br><span class="line"><span class="comment"># 2.修改控制配置文件，改为默认拒绝</span></span><br><span class="line"><span class="comment"># vim /etc/kubernetes/epconfig/admission_configuration.json</span></span><br><span class="line">   <span class="string">&quot;defaultAllow&quot;</span>: <span class="literal">false</span>     <span class="comment"># ture改为false</span></span><br><span class="line"><span class="comment"># 3. 编辑/etc/kubernetes/epconfig/kubeconfig.yml，添加 webhook server 地址</span></span><br><span class="line">  ...</span><br><span class="line">  cluster:</span><br><span class="line">    certificate-authority: /path/to/ca.pem   </span><br><span class="line">    server: &lt;https://acme.local:8082/image_policy&gt;   <span class="comment"># 增加该行</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份并修改kube-apiserver.yaml文件，修改如下内容</span></span><br><span class="line">cp /etc/kubernetes/manifests/kube-apiserver.yaml&#123;,.bak&#125;</span><br><span class="line"><span class="comment"># 1.kube-apiserver启用镜像策略</span></span><br><span class="line"><span class="comment"># vim /etc/kubernetes/manifests/kube-apiserver.yaml</span></span><br><span class="line"><span class="comment"># 官网搜索：ImagePolicyWebhook，可以找到配置api-server配置参数；搜索：volumes 、hostPath，可以找到文件目录挂载的方式</span></span><br><span class="line">    - --enable-admission-plugins=NodeRestriction,ImagePolicyWebhook</span><br><span class="line">    - --admission-control-config-file=/etc/kubernetes/epconfig/admission_configuration.json</span><br><span class="line">    - mountPath: /etc/kubernetes/epconfig</span><br><span class="line">      name: epconfig</span><br><span class="line">      readOnly: <span class="literal">true</span></span><br><span class="line">    - hostPath:</span><br><span class="line">      path: /etc/kubernetes/epconfig</span><br><span class="line">      <span class="built_in">type</span>: DirectoryOrCreate</span><br><span class="line">    name: epconfig</span><br><span class="line"><span class="comment"># 这里注意配置完api-server 需要重启kubelet 才可以进行接下来的验证工作</span></span><br><span class="line"><span class="comment"># systemctl daemon-reload </span></span><br><span class="line"><span class="comment"># systemctl restart kubelet</span></span><br></pre></td></tr></table></figure>

<p>验证</p>
<p><code># kubectl apply -f /cks/img/web1.yaml</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV18M411B71X/?spm_id_from=333.880.my_history.page.click&vd_source=54219cc5e238a20cf7dbddb083f415f7">新版PSI系统下CKS考试注意事项</a></p>
<p><a href="https://www.bilibili.com/video/BV1JG4y1772Y/?spm_id_from=pageDriver&vd_source=54219cc5e238a20cf7dbddb083f415f7">2022年12月CKS真题</a></p>
]]></content>
      <categories>
        <category>kubernet</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 使用crash分析vmcore dump文件</title>
    <url>/posts/76d974f3/</url>
    <content><![CDATA[<h2 id="vmcore是什么？"><a href="#vmcore是什么？" class="headerlink" title="vmcore是什么？"></a>vmcore是什么？</h2><p>vmcore是指操作系统在遇到致命错误（比如内核崩溃）时所生成的内存转储文件。这个文件包含了操作系统在崩溃前的内存状态，因此可以用于诊断崩溃的原因。</p>
<p>在 Linux 系统中，当内核崩溃时，通常会生成一个称为vmcore的文件。该文件位于/var/crash目录下，其命名类似于vmcore.&lt;时间戳&gt;。vmcore文件通常是非常大的，因为它包含了操作系统在崩溃前的全部内存内容。</p>
<p>一般情况下，vmcore文件可以通过分析工具进行分析，以确定崩溃的原因。例如，可以使用GNU Debugger（GDB）或crash工具来分析vmcore文件。</p>
<h2 id="手动触发vmcore的文件"><a href="#手动触发vmcore的文件" class="headerlink" title="手动触发vmcore的文件"></a>手动触发vmcore的文件</h2><p>vmcore文件通常是在系统遇到严重故障、例如操作系统崩溃或Panic时自动生成的，而无法手动触发。在一些情况下，我们可能需要手动触发一个vmcore文件的生成，例如在进行内核调试时。这时，可以使用kdump工具来手动触发vmcore文件的生成。</p>
<h3 id="安装kexec-tools和kernel-debuginfo包"><a href="#安装kexec-tools和kernel-debuginfo包" class="headerlink" title="安装kexec-tools和kernel-debuginfo包"></a>安装kexec-tools和kernel-debuginfo包</h3><p>这里系统采用的CentOS7.9</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum install yum-utils kexec-tools</span><br><span class="line"># debuginfo-install kernel</span><br></pre></td></tr></table></figure>

<p>如果 <code>kernel-debuginfo</code>安装不成功，直接下载CentOS官方下载：<a href="http://debuginfo.centos.org/7/x86_64/">http://debuginfo.centos.org/7/x86_64/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o kernel-debuginfo-$(uname -r).rpm http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-$(uname -r).rpm</span><br><span class="line">curl -o kernel-debuginfo-common-x86_64-$(uname -r).rpm http://debuginfo.centos.org/7/x86_64/kernel-debuginfo-common-x86_64-$(uname -r).rpm</span><br><span class="line">rpm -ivh kernel-debuginfo-common-x86_64-$(uname -r).rpm</span><br><span class="line">rpm -ivh kernel-debuginfo-$(uname -r).rpm</span><br></pre></td></tr></table></figure>

<p>在使用kdump之前，需要先安装kexec-tools和kernel-debuginfokernel-debuginf包，它们可以通过Linux发行版的软件包管理器来安装。</p>
<h3 id="配置kdump"><a href="#配置kdump" class="headerlink" title="配置kdump"></a>配置kdump</h3><p>可以使用命令 <code>systemctl status kdump</code>来检查kdump是否已经安装并启用。</p>
<p>如果没有启用，需要编辑/etc/default/grub文件并添加以下行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;crashkernel=auto rd.lvm.lv=&lt;rootvg&gt;/&lt;rootlv&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>&lt;rootvg&gt;</code>和 <code>&lt;rootlv&gt;</code>是根分区的名称。</p>
<p>保存并关闭文件后，执行以下命令以重新生成grub.cfg文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br></pre></td></tr></table></figure>

<h3 id="启用kdump服务"><a href="#启用kdump服务" class="headerlink" title="启用kdump服务"></a>启用kdump服务</h3><p>执行以下命令以启用kdump服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl enable kdump</span></span><br><span class="line"><span class="comment"># systemctl start kdump</span></span><br></pre></td></tr></table></figure>

<h3 id="手动生成vmcore文件"><a href="#手动生成vmcore文件" class="headerlink" title="手动生成vmcore文件"></a>手动生成vmcore文件</h3><p>要手动生成vmcore文件，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo 1 &gt; /proc/sys/kernel/sysrq</span></span><br><span class="line"><span class="comment"># echo c &gt; /proc/sysrq-trigger</span></span><br></pre></td></tr></table></figure>

<p>这将触发系统崩溃，并在/var/crash目录下生成一个vmcore文件。可以使用crash工具或其他工具来分析vmcore文件以诊断问题。</p>
<p>需要注意的是，生成vmcore文件需要一定的时间和系统资源，因此建议在空闲时段进行操作，并确保系统有足够的磁盘空间来存储生成的vmcore文件。</p>
<h3 id="配置core-dump大小限制"><a href="#配置core-dump大小限制" class="headerlink" title="配置core dump大小限制"></a>配置core dump大小限制</h3><p><code>ulimit -c unlimited</code> 命令用于设置当前用户在发生崩溃或者程序异常退出时所产生的 core dump 文件的最大大小限制。如果将其设置为 <code>unlimited</code>，则表示没有限制，即允许生成任意大小的 core dump 文件。</p>
<p>需要注意的是，<code>ulimit</code> 命令只会在当前的 shell 会话中生效。如果要在整个系统中永久性地修改 core dump 文件大小限制，可以将相应的配置写入 <code>/etc/security/limits.conf</code> 文件中。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* soft core unlimited</span><br><span class="line">* hard core unlimited</span><br></pre></td></tr></table></figure>

<h2 id="调试vmcore-dump文件"><a href="#调试vmcore-dump文件" class="headerlink" title="调试vmcore dump文件"></a>调试vmcore dump文件</h2><h3 id="使用crash工具分析vmcore文件"><a href="#使用crash工具分析vmcore文件" class="headerlink" title="使用crash工具分析vmcore文件"></a>使用crash工具分析vmcore文件</h3><p>crash是一个用于分析vmcore文件的强大工具，可以用来诊断操作系统故障和性能问题。可以使用以下命令安装crash：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install crash</span></span><br></pre></td></tr></table></figure>

<p>然后可以使用以下命令来打开vmcore文件并启动crash工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crash /path/to/vmcore /usr/lib/debug/lib/modules/$(uname -r)/vmlinux</span><br></pre></td></tr></table></figure>

<p>其中 <code>/path/to/vmcore</code>是vmcore文件的路径，<code>/usr/lib/debug/lib/modules/$(uname -r)/vmlinux</code>是当前正在运行的内核镜像的路径。</p>
<p>一旦打开了crash工具，就可以使用各种命令来分析vmcore文件，例如 <code>bt</code>命令可以显示进程的调用堆栈，<code>ps</code>命令可以显示进程列表，<code>mem</code>命令可以显示内存使用情况等等。</p>
<h3 id="使用gdb工具分析vmcore文件"><a href="#使用gdb工具分析vmcore文件" class="headerlink" title="使用gdb工具分析vmcore文件"></a>使用gdb工具分析vmcore文件</h3><p>除了crash工具外，还可以使用gdb工具来分析vmcore文件。gdb是一个用于调试和分析程序的强大工具，可以用于分析操作系统崩溃的原因和调用堆栈等信息。可以使用以下命令安装gdb：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gdb</span><br></pre></td></tr></table></figure>

<p>然后可以使用以下命令来打开vmcore文件并启动gdb工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb /usr/lib/debug/lib/modules/$(uname -r)/vmlinux /path/to/vmcore</span><br></pre></td></tr></table></figure>

<p>一旦打开了gdb工具，就可以使用各种命令来分析vmcore文件，例如 <code>bt</code>命令可以显示进程的调用堆栈，<code>info proc</code>命令可以显示进程列表，<code>info mem</code>命令可以显示内存使用情况等等。</p>
<h3 id="crash常用的命令"><a href="#crash常用的命令" class="headerlink" title="crash常用的命令"></a>crash常用的命令</h3><p>1、bt命令</p>
<p>backtrace打印内核栈回溯信息，bt pid 打印指定进程栈信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crash&gt; bt 832</span><br><span class="line">PID: 832    TASK: ffff974f77b63150  CPU: 0   COMMAND: <span class="string">&quot;vector&quot;</span></span><br><span class="line"> <span class="comment">#0 [ffff974f7367fc28] __schedule at ffffffffaad8057a</span></span><br><span class="line"> <span class="comment">#1 [ffff974f7367fcb0] schedule at ffffffffaad80a29</span></span><br><span class="line"> <span class="comment">#2 [ffff974f7367fcc0] futex_wait_queue_me at ffffffffaa712086</span></span><br><span class="line"> <span class="comment">#3 [ffff974f7367fd00] futex_wait at ffffffffaa712e2b</span></span><br><span class="line"> <span class="comment">#4 [ffff974f7367fe48] do_futex at ffffffffaa714b76</span></span><br><span class="line"> <span class="comment">#5 [ffff974f7367fed8] sys_futex at ffffffffaa715090</span></span><br><span class="line"> <span class="comment">#6 [ffff974f7367ff50] system_call_fastpath at ffffffffaad8dede</span></span><br><span class="line">    RIP: 00007fbc3d51cb43  RSP: 00007ffe3cede1f0  RFLAGS: 00010246</span><br><span class="line">    RAX: 00000000000000ca  RBX: 00007fbc3d51caa5  RCX: 0000000000000000</span><br><span class="line">    RDX: 0000000000000001  RSI: 0000000000000080  RDI: 00007fbc3df64930</span><br><span class="line">    RBP: 0000000000000080   R8: 0000000000000070   R9: 00007fbc3df64910</span><br><span class="line">    R10: 0000000000000000  R11: 0000000000000212  R12: 0000000000000001</span><br><span class="line">    R13: 00007fbc3df64930  R14: 00007fbc38002080  R15: 00007fbc38002000</span><br><span class="line">    ORIG_RAX: 00000000000000ca  CS: 0033  SS: 002b</span><br></pre></td></tr></table></figure>

<p>2、log命令</p>
<p>打印vmcore所在的系统内核dmesg日志信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crash&gt; <span class="built_in">log</span></span><br><span class="line">[    0.000000] Initializing cgroup subsys cpuset</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpu</span><br><span class="line">[    0.000000] Initializing cgroup subsys cpuacct</span><br><span class="line">[    0.000000] Linux version 3.10.0-1062.12.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) ) <span class="comment">#1 SMP Tue Feb 4 23:02:59 UTC 2020</span></span><br><span class="line">[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-3.10.0-1062.12.1.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet LANG=en_US.UTF-8</span><br><span class="line">[    0.000000] Disabled fast string operations</span><br><span class="line">[    0.000000] e820: BIOS-provided physical RAM map:</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009ebff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000000009ec00-0x000000000009ffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000000dc000-0x00000000000fffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000007fedffff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000007fee0000-0x000000007fefefff] ACPI data</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000007feff000-0x000000007fefffff] ACPI NVS</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x000000007ff00000-0x000000007fffffff] usable</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000f0000000-0x00000000f7ffffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000fec00000-0x00000000fec0ffff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000fee00000-0x00000000fee00fff] reserved</span><br><span class="line">[    0.000000] BIOS-e820: [mem 0x00000000fffe0000-0x00000000ffffffff] reserved</span><br><span class="line">[    0.000000] NX (Execute Disable) protection: active</span><br><span class="line">[    0.000000] SMBIOS 2.4 present.</span><br><span class="line">[    0.000000] DMI: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 12/12/2018</span><br><span class="line">[    0.000000] Hypervisor detected: VMware</span><br></pre></td></tr></table></figure>

<p>3、ps命令</p>
<p>ps 打印内核崩溃时，正常的进程信息，带 &gt; 标识代表是活跃的进程，ps pid打印某指定进程的状态信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crash&gt; bt 832</span><br><span class="line">PID: 832    TASK: ffff974f77b63150  CPU: 0   COMMAND: <span class="string">&quot;vector&quot;</span></span><br><span class="line"> <span class="comment">#0 [ffff974f7367fc28] __schedule at ffffffffaad8057a</span></span><br><span class="line"> <span class="comment">#1 [ffff974f7367fcb0] schedule at ffffffffaad80a29</span></span><br><span class="line"> <span class="comment">#2 [ffff974f7367fcc0] futex_wait_queue_me at ffffffffaa712086</span></span><br><span class="line"> <span class="comment">#3 [ffff974f7367fd00] futex_wait at ffffffffaa712e2b</span></span><br><span class="line"> <span class="comment">#4 [ffff974f7367fe48] do_futex at ffffffffaa714b76</span></span><br><span class="line"> <span class="comment">#5 [ffff974f7367fed8] sys_futex at ffffffffaa715090</span></span><br><span class="line"> <span class="comment">#6 [ffff974f7367ff50] system_call_fastpath at ffffffffaad8dede</span></span><br><span class="line">    RIP: 00007fbc3d51cb43  RSP: 00007ffe3cede1f0  RFLAGS: 00010246</span><br><span class="line">    RAX: 00000000000000ca  RBX: 00007fbc3d51caa5  RCX: 0000000000000000</span><br><span class="line">    RDX: 0000000000000001  RSI: 0000000000000080  RDI: 00007fbc3df64930</span><br><span class="line">    RBP: 0000000000000080   R8: 0000000000000070   R9: 00007fbc3df64910</span><br><span class="line">    R10: 0000000000000000  R11: 0000000000000212  R12: 0000000000000001</span><br><span class="line">    R13: 00007fbc3df64930  R14: 00007fbc38002080  R15: 00007fbc38002000</span><br><span class="line">    ORIG_RAX: 00000000000000ca  CS: 0033  SS: 002b</span><br></pre></td></tr></table></figure>

<p>4、file命令</p>
<p>files pid 打印指定进程所打开的文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crash&gt; files 832</span><br><span class="line">PID: 832    TASK: ffff974f77b63150  CPU: 0   COMMAND: <span class="string">&quot;vector&quot;</span></span><br><span class="line">ROOT: /    CWD: /</span><br><span class="line"> FD       FILE            DENTRY           INODE       TYPE PATH</span><br><span class="line">  0 ffff974f7761b300 ffff974f7950db00 ffff974f7a3b0850 CHR  /dev/null</span><br><span class="line">  1 ffff974f7761b100 ffff974f7957f740 ffff974f7954ad30 SOCK UNIX</span><br><span class="line">  2 ffff974f7761b100 ffff974f7957f740 ffff974f7954ad30 SOCK UNIX</span><br><span class="line">  3 ffff974f6dab5b00 ffff974f7582fec0 ffff974f7951b090 UNKN [eventpoll]</span><br><span class="line">  4 ffff974f6dab4900 ffff974f73a1fbc0 ffff974f7951b090 UNKN [eventfd]</span><br><span class="line">  5 ffff974f6dab5b00 ffff974f7582fec0 ffff974f7951b090 UNKN [eventpoll]</span><br><span class="line">  6 ffff974f6dab4500 ffff974f75856fc0 ffff974f35c1e6b0 SOCK UNIX</span><br><span class="line">  7 ffff974f6dab5d00 ffff974f758f9800 ffff974f35c18a30 SOCK UNIX</span><br><span class="line">  8 ffff974f6dab4500 ffff974f75856fc0 ffff974f35c1e6b0 SOCK UNIX</span><br><span class="line">  9 ffff974f6dab5400 ffff974f75ab1380 ffff974f75a8b9d0 FIFO</span><br><span class="line"> 10 ffff974f6dab7700 ffff974f75ab1380 ffff974f75a8b9d0 FIFO</span><br><span class="line"> 11 ffff974f6dab4700 ffff974f75ab1800 ffff974f75a8bc20 FIFO</span><br><span class="line"> 12 ffff974f6dab5200 ffff974f75ab1800 ffff974f75a8bc20 FIFO</span><br><span class="line"> 13 ffff974f6dab4100 ffff974f75ab18c0 ffff974f75a8be70 FIFO</span><br><span class="line"> 14 ffff974f6dab4200 ffff974f75ab18c0 ffff974f75a8be70 FIFO</span><br><span class="line"> 15 ffff974f6dab6000 ffff974f75ab1980 ffff974f75a8c0c0 FIFO</span><br><span class="line"> 16 ffff974f6dab5f00 ffff974f75ab1980 ffff974f75a8c0c0 FIFO</span><br><span class="line"> 17 ffff974f60b45e00 ffff974f61e6bd40 ffff974f61e99bb0 SOCK TCP</span><br><span class="line"> 18 ffff974f60b47f00 ffff974f61db6900 ffff974f61e99e30 SOCK TCP</span><br></pre></td></tr></table></figure>

<p>5、vm命令</p>
<p>vm pid 打印某指定进程当时虚拟内存基本信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crash&gt; vm 832</span><br><span class="line">PID: 832    TASK: ffff974f77b63150  CPU: 0   COMMAND: <span class="string">&quot;vector&quot;</span></span><br><span class="line">       MM               PGD          RSS    TOTAL_VM</span><br><span class="line">ffff974f3615abc0  ffff974f736b0000  73656k  206980k</span><br><span class="line">      VMA           START       END     FLAGS FILE</span><br><span class="line">ffff974f6356d518 7fbc31f38000 7fbc31f3a000 8000070</span><br><span class="line">ffff974f6356d6c8 7fbc31f3a000 7fbc32140000 8100073</span><br><span class="line">ffff974f6356d440 7fbc32140000 7fbc32142000 8000070</span><br><span class="line">ffff974f6356d878 7fbc32142000 7fbc32348000 8100073</span><br><span class="line">ffff974f6356d5f0 7fbc32348000 7fbc3234a000 8000070</span><br><span class="line">ffff974f6356da28 7fbc3234a000 7fbc32550000 8100073</span><br><span class="line">ffff974f6356d7a0 7fbc32550000 7fbc32552000 8000070</span><br><span class="line">ffff974f6356de60 7fbc32552000 7fbc32758000 8100073</span><br><span class="line">ffff974f6356d950 7fbc32758000 7fbc3275a000 8000070</span><br><span class="line">ffff974f6356dcb0 7fbc3275a000 7fbc32960000 8100073</span><br><span class="line">ffff974f6356db00 7fbc32960000 7fbc32962000 8000070</span><br><span class="line">ffff974f69324d80 7fbc32962000 7fbc32b68000 8100073</span><br><span class="line">ffff974f6356dd88 7fbc32b68000 7fbc32b6a000 8000070</span><br><span class="line">ffff974f69324ca8 7fbc32b6a000 7fbc32d70000 8100073</span><br><span class="line">ffff974f69324bd0 7fbc32d70000 7fbc32ff0000 8200073</span><br><span class="line">ffff974f69324510 7fbc32ff0000 7fbc32ff2000 8000070</span><br><span class="line">ffff974f69324360 7fbc32ff2000 7fbc331f8000 8100073</span><br></pre></td></tr></table></figure>

<p>6、task命令</p>
<p>task 查看当前进程或指定进程task_struct和thread_info的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crash&gt; task 832</span><br><span class="line">PID: 832    TASK: ffff974f77b63150  CPU: 0   COMMAND: <span class="string">&quot;vector&quot;</span></span><br><span class="line">struct task_struct &#123;</span><br><span class="line">  state = 1,</span><br><span class="line">  stack = 0xffff974f7367c000,</span><br><span class="line">  usage = &#123;</span><br><span class="line">    counter = 2</span><br><span class="line">  &#125;,</span><br><span class="line">  flags = 1077944320,</span><br><span class="line">  ptrace = 0,</span><br><span class="line">  wake_entry = &#123;</span><br><span class="line">    next = 0x0</span><br><span class="line">  &#125;,</span><br><span class="line">  on_cpu = 0,</span><br><span class="line">  last_wakee = 0xffff974f76cbe2a0,</span><br><span class="line">  wakee_flips = 100,</span><br><span class="line">  wakee_flip_decay_ts = 4294674675,</span><br><span class="line">  wake_cpu = 0,</span><br><span class="line">  on_rq = 0,</span><br><span class="line">  prio = 120,</span><br><span class="line">  static_prio = 120,</span><br><span class="line">  normal_prio = 120,</span><br><span class="line">  rt_priority = 0,</span><br><span class="line">  sched_class = 0xffffffffaae1e3c0,</span><br><span class="line">  se = &#123;</span><br><span class="line">    load = &#123;</span><br><span class="line">      weight = 1024,</span><br><span class="line">      inv_weight = 4194304</span><br><span class="line">    &#125;,</span><br><span class="line">    run_node = &#123;</span><br><span class="line">      __rb_parent_color = 1,</span><br><span class="line">      rb_right = 0x0,</span><br><span class="line">      rb_left = 0x0</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>内核</tag>
        <tag>linux</tag>
        <tag>vmcore</tag>
        <tag>crash</tag>
      </tags>
  </entry>
  <entry>
    <title>calico-node异常重启</title>
    <url>/posts/d62f787/</url>
    <content><![CDATA[<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>os 版本： centos7.9</li>
<li>kernel 版本：3.10.0-1160.59.1.el7.x86_64</li>
<li>k8s 版本：v1.19.4</li>
<li>calico-node 版本：v3.8.8-1</li>
</ul>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>calico异常重启导致容器网络异常超时，查看日志发现报错如下：<code>failed to create new OS thread</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取异常节点calico-node重启多次</span></span><br><span class="line">kubectl -n kube-system get pod -owide | grep calico-node-56bgm</span><br><span class="line">calico-node-56bgm                             1/1     Running   21         246d   10.165.6.26      10.165.6.26   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看calico-node历史日志如下：</span></span><br><span class="line">kubectl -n kube-system logs -p calico-node-56bgm | less</span><br><span class="line">runtime: failed to create new OS thread (have 41 already; errno=11)</span><br><span class="line">runtime: may need to increase max user processes (<span class="built_in">ulimit</span> -u)</span><br><span class="line">fatal error: newosproc</span><br><span class="line"></span><br><span class="line">runtime stack:</span><br><span class="line">runtime.throw(0x1aa0343, 0x9)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/panic.go:608 +0x72</span><br><span class="line">runtime.newosproc(0xc00062ea80)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/os_linux.go:166 +0x1c0</span><br><span class="line">runtime.newm1(0xc00062ea80)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:1940 +0xfe</span><br><span class="line">runtime.newm(0x1b62358, 0x0)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:1919 +0x9b</span><br><span class="line">runtime.startTheWorldWithSema(0xc0000b7501, 0x45b1b6)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:1209 +0x1ce</span><br><span class="line">runtime.gcMarkTermination.func3()</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/mgc.go:1644 +0x26</span><br><span class="line">runtime.systemstack(0x0)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:351 +0x66</span><br><span class="line">runtime.mstart()</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/proc.go:1229</span><br><span class="line"></span><br><span class="line">goroutine 35 [running]:</span><br><span class="line">runtime.systemstack_switch()</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:311 fp=0xc0000b7568 sp=0xc0000b7560 pc=0x4577d0</span><br><span class="line">runtime.gcMarkTermination(0x3fecb9f8bbbbdd6c)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/mgc.go:1644 +0x3f5 fp=0xc0000b7738 sp=0xc0000b7568 pc=0x41a695</span><br><span class="line">runtime.gcMarkDone()</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/mgc.go:1510 +0x21e fp=0xc0000b7760 sp=0xc0000b7738 pc=0x41a23e</span><br><span class="line">runtime.gcBgMarkWorker(0xc00005f900)</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/mgc.go:1909 +0x2b2 fp=0xc0000b77d8 sp=0xc0000b7760 pc=0x41b162</span><br><span class="line">runtime.goexit()</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/asm_amd64.s:1333 +0x1 fp=0xc0000b77e0 sp=0xc0000b77d8 pc=0x459731</span><br><span class="line">created by runtime.gcBgMarkStartWorkers</span><br><span class="line">        /usr/<span class="built_in">local</span>/go/src/runtime/mgc.go:1720 +0x77</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>dmesg 系统日志报错：<code>cgroup: fork rejected by pids controller in /kubepods/...</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 登录主机会发现如下报错</span><br><span class="line"># dmesg -xTL | tail</span><br><span class="line">kern  :info  : [Mon May 15 09:25:27 2023] cgroup: fork rejected by pids controller in /kubepods/burstable/pod22612ffb-4523-4958-b6dd-a80bd35fd325/8e8c5f52932538520f5b8042a2b602c1c5a07805ee073f1892ad27b0d818b584</span><br><span class="line">kern  :info  : [Mon May 15 09:25:27 2023] cgroup: fork rejected by pids controller in /kubepods/burstable/podd06203b5-9e78-4247-b80c-43ffaea99318/52177669439ab2d4a1253b2fa7daedf226bff37911841d846286e5c6fb015a55</span><br></pre></td></tr></table></figure>

<h1 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h1><p>查看系统ulimit限制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/security/limits.conf | tail -n 5</span><br><span class="line">*       soft    nofile  65535</span><br><span class="line">*       hard    nofile  65535</span><br><span class="line">*       soft    nproc   65535</span><br><span class="line">*       hard    nproc   65535</span><br></pre></td></tr></table></figure>

<p>查看用户进程限制，限制用户进程的数量 4096 太小，这里可以设当调整，调整后还是容易出现该异常。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/security/limits.d/20-nproc.conf</span><br><span class="line"><span class="comment"># Default limit for number of user&#x27;s processes to prevent</span></span><br><span class="line"><span class="comment"># accidental fork bombs.</span></span><br><span class="line"><span class="comment"># See rhbz #432903 for reasoning.</span></span><br><span class="line"></span><br><span class="line">*          soft    nproc     4096</span><br><span class="line">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure>

<p>可能是因为kubernetes kubepods cgroup 的pids.max 配置太小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看 kubepods cgroup 的pids.max</span><br><span class="line">cat /sys/fs/cgroup/pids/kubepods/pids.max</span><br><span class="line">49152</span><br><span class="line"># 再查看系统的pid_max值，这个值是修改过，但是没有重启过kubelet服务，所以k8s没识别到该该系统参数。</span><br><span class="line">cat /proc/sys/kernel/pid_max</span><br><span class="line">1000000</span><br><span class="line"># 这里只需要重启kubelet即可自动保持pids.max和kernel.pid_max值一致</span><br><span class="line">systemctl restart kubelet</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>/sys/fs/cgroup/pids/kubepods/pids.max 是一个控制 Linux 控制组（cgroup）中进程数量限制的文件路径。它的值表示在该 cgroup 中允许的最大进程数。</p>
<p>在 Kubernetes 中，pids.max 文件通常是由 kubelet 进程负责设置和管理的。kubelet 会创建和管理用于容器进程的 cgroup，并根据配置中指定的值设置 pids.max 文件的值。</p>
</blockquote>
]]></content>
      <categories>
        <category>calico</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
        <tag>calico</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu内核管理</title>
    <url>/posts/b97fcc87/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于公司目前开始全面开始推进ubuntu系统的使用，使用时发现内核更新太过频繁，对于ubuntu桌面版本内核升级可能会提升用户体验和安全性，但对于ubuntu server服务器，我们一般会采用固定版本。默认情况下ubuntu不管是桌面版还是server版本，执行 <code>apt update</code>会升级下载所有需要升级的包（包括内核包）。版本固定方便统一维护，如果某个版本的内核存在bug，可以安排统一更新。</p>
<h1 id="升级和卸载内核"><a href="#升级和卸载内核" class="headerlink" title="升级和卸载内核"></a>升级和卸载内核</h1><p>1、升级内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看当前内核</span><br><span class="line">uname -r</span><br><span class="line"># 升级软件包</span><br><span class="line">sudo apt update</span><br><span class="line"># 查看可用内核</span><br><span class="line">apt-cache search linux-image</span><br><span class="line"># 选择合适的内核进行安装</span><br><span class="line">sudo apt-get install linux-image-XXXX-generic</span><br><span class="line"></span><br><span class="line">or </span><br><span class="line">之前执行过 sudo apt update 更新过，执行如下</span><br><span class="line">dpkg --list | grep linux-image</span><br><span class="line"></span><br><span class="line">or </span><br><span class="line">另外，可以自行下载制定内核进行安装，下载地址如下：</span><br><span class="line">http://kernel.ubuntu.com/~kernel-ppa/mainline/ </span><br><span class="line">sudo dpkg -i *.deb</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、卸载内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看内核安装情况：</span><br><span class="line">dpkg --list | grep linux-image</span><br><span class="line">dpkg --list | grep linux-headers</span><br><span class="line"># 手动指定卸载内核：</span><br><span class="line">sudo apt purge linux-image-xx</span><br><span class="line">sudo apt purge linux-headers-xx</span><br><span class="line">sudo apt autoremove</span><br><span class="line"></span><br><span class="line"># 这里也可以选择卸载所有不在使用的内核版本(5.4.187为当前在使用版本)</span><br><span class="line">sudo apt-get autoremove --purge $(dpkg -l &#x27;linux-*&#x27; | awk &#x27;/^ii/&#123;print $2&#125;&#x27; | grep -E &#x27;linux-(image|headers|modules|modules-extra)-[0-9]+&#x27; | grep -v &quot;5.4.187&quot; | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"># 执行更新grub</span><br><span class="line">sudo update-grub </span><br></pre></td></tr></table></figure>

<p>3、修改默认启动的内核版本</p>
<p>如果已经更新了内核，主机上就会存在多个已安装版本，默认情况下重启会自动选择最新的，这个时候如何选择某个版本下次重启生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看已经在启动列表的内核</span><br><span class="line">cat /boot/grub/grub.cfg | grep &quot;menuentry &#x27;Ubuntu,&quot; | awk -F &#x27;--class&#x27; &#x27;&#123;print $1&#125;</span><br><span class="line">        menuentry &#x27;Ubuntu, with Linux 5.10.87-051087-generic&#x27;</span><br><span class="line">        menuentry &#x27;Ubuntu, with Linux 5.10.87-051087-generic (recovery mode)&#x27;</span><br><span class="line">        menuentry &#x27;Ubuntu, with Linux 5.4.187-0504187-generic&#x27;</span><br><span class="line">        menuentry &#x27;Ubuntu, with Linux 5.4.187-0504187-generic (recovery mode)&#x27;</span><br><span class="line">        menuentry &#x27;Ubuntu, with Linux 4.15.0-163-generic&#x27;</span><br><span class="line">        menuentry &#x27;Ubuntu, with Linux 4.15.0-163-generic (recovery mode)&#x27;</span><br><span class="line">        menuentry &#x27;Ubuntu, with Linux 4.15.0-162-generic&#x27;</span><br><span class="line">        menuentry &#x27;Ubuntu, with Linux 4.15.0-162-generic (recovery mode)&#x27;</span><br><span class="line"># 修改/etc/default/grub 找到 GRUB_DEFAULT 行，并将其值设置为所选择的内核版本的完整名称或索引号。</span><br><span class="line">vi /etc/default/grub</span><br><span class="line">GRUB_DEFAULT=&#x27;Ubuntu, with Linux 4.15.0-162-generic&#x27;</span><br><span class="line"># 更新grub，重启主机生效</span><br><span class="line">update-grub</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="关闭内核自动更新"><a href="#关闭内核自动更新" class="headerlink" title="关闭内核自动更新"></a>关闭内核自动更新</h1><p>1、固定某个版本的内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 固定hold某个软件包，以后执行update就不会升级和下载内核</span><br><span class="line">sudo apt-mark hold linux-image-generic linux-headers-generic</span><br><span class="line"># 查看hold状态包</span><br><span class="line">sudo dpkg --get-selections | grep hold </span><br><span class="line"># 如果要重新启用内核更新</span><br><span class="line">sudo apt-mark unhold linux-image-generic linux-headers-generic</span><br></pre></td></tr></table></figure>

<p>2、或，如下方式关闭软件包自动更新配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改如下配置，其中的值改成 &quot;0&quot;</span><br><span class="line">/etc/apt/apt.conf.d/10periodic</span><br><span class="line">/etc/apt/apt.conf.d/20auto-upgrades</span><br><span class="line"></span><br><span class="line">cat /etc/apt/apt.conf.d/20auto-upgrades</span><br><span class="line">APT::Periodic::Update-Package-Lists &quot;0&quot;;</span><br><span class="line">APT::Periodic::Unattended-Upgrade &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">cat /etc/apt/apt.conf.d/10periodic</span><br><span class="line">APT::Periodic::Update-Package-Lists &quot;0&quot;;</span><br><span class="line">APT::Periodic::Download-Upgradeable-Packages &quot;0&quot;;</span><br><span class="line">APT::Periodic::AutocleanInterval &quot;0&quot;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/open-skill/p/8295234.html">https://www.cnblogs.com/open-skill/p/8295234.html</a></p>
<p><a href="https://linux.cn/article-6245-1.html">https://linux.cn/article-6245-1.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>docker报错打开太多文件（too many open files）</title>
    <url>/posts/743c406f/</url>
    <content><![CDATA[<p>在Linux系统内默认对所有进程打开的文件数量有限制（也可以称为文件句柄，包含打开的文件，套接字，网络连接等都算是一个文件句柄）</p>
<h2 id="查看当前系统限制最大文件打开数量"><a href="#查看当前系统限制最大文件打开数量" class="headerlink" title="查看当前系统限制最大文件打开数量"></a>查看当前系统限制最大文件打开数量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max</span><br><span class="line">2000000</span><br></pre></td></tr></table></figure>

<h2 id="查询当前系统已打开文件数量"><a href="#查询当前系统已打开文件数量" class="headerlink" title="查询当前系统已打开文件数量"></a>查询当前系统已打开文件数量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/fs/file-nr</span><br><span class="line">8640    0       2000000    <span class="comment"># 左边的值为当前系统已打开文件数量，右侧表示当前系统限制最大文件打开数</span></span><br></pre></td></tr></table></figure>

<p>以上查询得知当前系统打开文件句柄数未达到上限，往下排查Docker进程的最大文件句柄数限制及已打开文件数</p>
<h2 id="查询当前Docker进程最大可打开文件数量及已打开文件数量"><a href="#查询当前Docker进程最大可打开文件数量及已打开文件数量" class="headerlink" title="查询当前Docker进程最大可打开文件数量及已打开文件数量"></a>查询当前Docker进程最大可打开文件数量及已打开文件数量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status docker | grep PID      <span class="comment">#获取Docker进程的PID号</span></span><br><span class="line">Main PID: 14644 (dockerd)</span><br><span class="line">cat /proc/`pidof dockerd`/limits</span><br><span class="line"><span class="comment"># 或者使用</span></span><br><span class="line">ls -l /proc/`pidof dockerd`/fd/* | wc -l    <span class="comment">## 获取当前Docker进程已打开的文件数量</span></span><br><span class="line">65342      <span class="comment">#报错时该值达到了最大限制65536</span></span><br></pre></td></tr></table></figure>

<h2 id="临时动态修改当前Docker进程的nofile限制，问题修复"><a href="#临时动态修改当前Docker进程的nofile限制，问题修复" class="headerlink" title="临时动态修改当前Docker进程的nofile限制，问题修复"></a>临时动态修改当前Docker进程的nofile限制，问题修复</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将Docker进程的nofile限制调整为655360</span></span><br><span class="line">prlimit --pid 14644 --nofile=655360:655360   </span><br><span class="line"><span class="comment">#再次查询Docker进程状态发现问题已修复</span></span><br><span class="line">systemctl status docker </span><br><span class="line"><span class="comment">#查看当前Docker进程最大可打开文件数量</span></span><br><span class="line">cat /proc/`pidof dockerd`/limits   </span><br><span class="line">Max cpu time              unlimited            unlimited            seconds</span><br><span class="line">Max file size             unlimited            unlimited            bytes</span><br><span class="line">Max data size             unlimited            unlimited            bytes</span><br><span class="line">Max stack size            8388608              unlimited            bytes</span><br><span class="line">Max core file size        unlimited            unlimited            bytes</span><br><span class="line">Max resident <span class="built_in">set</span>          unlimited            unlimited            bytes</span><br><span class="line">Max processes             unlimited            unlimited            processes</span><br><span class="line">Max open files            655360               655360               files</span><br><span class="line">Max locked memory         65536                65536        				bytes</span><br><span class="line">Max address space         unlimited            unlimited            bytes</span><br><span class="line">Max file locks            unlimited            unlimited            locks</span><br><span class="line">Max pending signals       61943                61943                signals</span><br><span class="line">Max msgqueue size         819200               819200               bytes</span><br><span class="line">Max nice priority         0                    0</span><br><span class="line">Max realtime priority     0                    0</span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br></pre></td></tr></table></figure>

<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p>Q、修改daoker systemd服务配置参数LimitNOFILE=<strong><strong>infinity，不生效问题。</strong></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat  /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.6.1810 (Core)</span><br><span class="line">$ rpm -qa | grep systemd-sysv</span><br><span class="line">systemd-sysv-219-62.el7.x86_64</span><br><span class="line">$ uname -a</span><br><span class="line">Linux HZPL004094053 3.10.0-1160.76.1.el7.x86_64 <span class="comment">#1 SMP Wed Aug 10 16:21:17 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">$ cat /etc/systemd/system/docker.service | grep LimitNOFILE</span><br><span class="line">LimitNOFILE=infinity </span><br><span class="line"><span class="comment">#最终却得到65536</span></span><br><span class="line">cat /proc/`pidof dockerd`/limits |grep files</span><br><span class="line">Max open files            65536                65536                files</span><br></pre></td></tr></table></figure>

<p>A、根治方案，修改systemd配置LimitNOFILE值</p>
<p>该问题应该是systemd服务<a href="https://github.com/systemd/systemd/issues/6559">bug issue</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/systemd/system/docker.service | grep LimitNOFILE</span><br><span class="line">LimitNOFILE=200000 <span class="comment"># 可以修改配置文件到20w以上。</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">cat /proc/`pidof dockerd`/limits |grep files</span><br><span class="line">Max open files            200000                200000                files</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet统计磁盘inode耗时导致负载升高问题</title>
    <url>/posts/b0f608c0/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>1、磁盘容量告警</p>
<p><img src="/posts/b0f608c0/1685575843966.png" alt="1685575843966"></p>
<p>2、对主机进行磁盘检查并尝试清理磁盘占用较高的pod，有5900多个文件描述符被打开没有关闭。</p>
<p><img src="/posts/b0f608c0/1685576103317.png" alt="1685576103317"></p>
<p><img src="/posts/b0f608c0/1685577904035.png" alt="1685577904035"></p>
<p>通过平台删除该pod: product-center-query-pro-remain-5bfb5f4c98-m2l55</p>
<p>3、主机负载冲高，触发告警</p>
<p><img src="/posts/b0f608c0/1685575658188.png" alt="1685575658188"></p>
<h1 id="根因排查"><a href="#根因排查" class="headerlink" title="根因排查"></a>根因排查</h1><p>1、根据系统日志发现磁盘最早在5月28日就出现了磁盘inode统计超时情况。</p>
<p><img src="/posts/b0f608c0/1685576358306.png" alt="1685576358306"></p>
<p>2、发现有个容器在/tmp目录创建了很多小文件，占用了大量的磁盘空间及Inode，可能是导致磁盘响应变慢的直接原因。</p>
<p><img src="/posts/b0f608c0/1685601543912.png" alt="1685601543912"></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li>立即对主机进行疏散，避免再次出现异常，导致主机负载升高，影响业务pod。</li>
<li>增加该kubelet日志告警（fs: disk usage and inodes count on following dirs took 1），提前发现及时人工介入进行处理。</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>pod容器内ping延迟大问题</title>
    <url>/posts/da179f53/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>1、根据业务方的反馈，有2个容器之前存在网络延迟，但同一集群并未有其他人反馈异常</p>
<p>pod1（10.165.74.252） —&gt; pod2（10.165.210.88） ping延迟稳定4个包出现一个包延迟200-400ms</p>
<p><img src="/posts/da179f53/1687840745062.png" alt="1687840745062"></p>
<h1 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h1><p>1、检查物理机管理控制台日志，排查是否存在异常日志，登录带外检查并未发现异常。</p>
<p>2、检查了容器网络，我们集群CNI用的是calico，检查主机上calico-node状态正常，并且日志并未发现异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 2个容器所在节点上calico-node状态正常，日志并未发现异常日志。</span><br><span class="line">calico-node-7np2p                             1/1     Running   0          322d    10.165.6.25      10.165.6.25   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">calico-node-gcn4c                             1/1     Running   0          11d     10.165.2.26      10.165.2.26   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>3、其他容器及该集群网络ping延迟测试，从下午可以看出，主机与主机、pod与pod之间都存在跳ping，问题依旧无法定位。</p>
<p><img src="/posts/da179f53/1687844409482.png" alt="1687844409482"></p>
<p>4、尝试对10.165.2.26主机进行网卡上联接口切换测试并验证pod1和pod2之间是否存在持续的4个包之后高延迟一次。</p>
<p>这里down 一个口之后，物理机网卡出现了主从切换，网络的延迟突然出现改善，从这里判断网卡的p1p1接口可能存在问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># p1p1上联接口down后如下</span><br><span class="line">ip a | grep bond0</span><br><span class="line">6: p1p1: &lt;NO-CARRIER,BROADCAST,MULTICAST,SLAVE,UP&gt; mtu 1500 qdisc mq master bond0 state DOWN group default qlen 1000</span><br><span class="line">7: p1p2: &lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&gt; mtu 1500 qdisc mq master bond0 state UP group default qlen 1000</span><br><span class="line">10: bond0: &lt;BROADCAST,MULTICAST,MASTER,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    inet 10.165.2.26/24 brd 10.165.2.255 scope global bond0</span><br><span class="line"># 延迟恢复</span><br><span class="line">64 bytes from 10.165.74.252: seq=1262 ttl=59 time=0.190 ms</span><br><span class="line">64 bytes from 10.165.74.252: seq=1263 ttl=59 time=0.225 ms</span><br><span class="line">64 bytes from 10.165.74.252: seq=1264 ttl=59 time=0.237 ms</span><br><span class="line">64 bytes from 10.165.74.252: seq=1265 ttl=59 time=0.214 ms</span><br><span class="line">...</span><br><span class="line">64 bytes from 10.165.210.88: seq=1707 ttl=59 time=0.180 ms</span><br><span class="line">64 bytes from 10.165.210.88: seq=1708 ttl=59 time=0.194 ms</span><br><span class="line">64 bytes from 10.165.210.88: seq=1709 ttl=59 time=0.207 ms</span><br><span class="line">64 bytes from 10.165.210.88: seq=1710 ttl=59 time=0.220 ms</span><br><span class="line">64 bytes from 10.165.210.88: seq=1711 ttl=59 time=0.208 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>检查网卡光模块是否存在光衰，判断是否存在光模块故障，或者光纤的问题。最终更换了p1p1的光模块和光纤线之后发现光衰均是正常的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@SHTL165002026 ~]# ethtool -m p1p2 | grep &quot;Receiver signal&quot; |  head -1 | awk -F &#x27;/&#x27; &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line"> -3.08 dBm</span><br><span class="line">[root@SHTL165002026 ~]# ethtool -m p1p1 | grep &quot;Receiver signal&quot; |  head -1 | awk -F &#x27;/&#x27; &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line"> -2.59 dBm</span><br><span class="line">[root@SHTL165002026 ~]# ethtool -m p1p1 | grep &quot;Laser output power&quot; |  head -1 | awk -F &#x27;/&#x27; &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line"> -2.65 dBm</span><br><span class="line">[root@SHTL165002026 ~]# ethtool -m p1p2 | grep &quot;Laser output power&quot; |  head -1 | awk -F &#x27;/&#x27; &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line"> -2.65 dBm</span><br></pre></td></tr></table></figure>

<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>1、首先尝试更换了光模块和光纤但未解决，先停止p1p1口，将主机的网卡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 切换网卡</span><br><span class="line">ifenslave -c bond0 p1p2</span><br><span class="line"># 查看网卡状态</span><br><span class="line">[root@SHTL165002026 ~]# cat /proc/net/bonding/bond0</span><br><span class="line">Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)</span><br><span class="line"></span><br><span class="line">Bonding Mode: fault-tolerance (active-backup)</span><br><span class="line">Primary Slave: None</span><br><span class="line">Currently Active Slave: p1p2</span><br><span class="line">MII Status: up</span><br><span class="line">MII Polling Interval (ms): 100</span><br><span class="line">Up Delay (ms): 0</span><br><span class="line">Down Delay (ms): 0</span><br><span class="line"></span><br><span class="line">Slave Interface: p1p1</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 10000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 2</span><br><span class="line">Permanent HW addr: 34:80:0d:a4:2c:e0</span><br><span class="line">Slave queue ID: 0</span><br><span class="line"></span><br><span class="line">Slave Interface: p1p2</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 10000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 1</span><br><span class="line">Permanent HW addr: 34:80:0d:a4:2c:e1</span><br><span class="line">Slave queue ID: 0</span><br></pre></td></tr></table></figure>

<p>2、联系硬件厂商保修该主机。</p>
<p>这里怀疑是因为网卡设备问题，</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>容器宿主机故障检测及节点自愈</title>
    <url>/posts/6ede5602/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 Kubernetes 集群运行时，节点有时会因为组件问题、内核死锁、资源不足等原因不可用。Kubelet 默认对节点的 PIDPressure、MemoryPressure、DiskPressure 等资源状态进行监控，但是存在当 Kubelet 上报状态时节点已处于不可用状态的情况，甚至 Kubelet 可能已开始驱逐 Pod。在此类场景下，原生 Kubernetes 对节点健康的检测机制是不完善的，为了提前发现节点的问题，需要添加更加细致化的指标来描述节点的健康状态并且采取相应的恢复策略，实现智能运维，以节省开发和减轻运维人员的负担。</p>
<h2 id="NPD-故障检测"><a href="#NPD-故障检测" class="headerlink" title="NPD 故障检测"></a>NPD 故障检测</h2><p>NPD（<a href="https://github.com/kubernetes/node-problem-detector">node-problem-detector</a>）是 Kubernetes 社区开源的集群节点的健康检测组件。NPD 提供了通过正则匹配系统日志或文件来发现节点异常的功能。用户可以通过运维经验，配置可能产生异常问题日志的正则表达式，选择不同的上报方式。NPD 会解析用户的配置文件，当有日志能匹配到用户配置的正则表达式时，可以通过 NodeCondition、Event 或 Promethues Metric 等方式将检测到的异常状态上报。除了日志匹配功能，NPD 还接受用户自行编写的自定义检测插件，用户可以开发自己的脚本或可执行文件集成到 NPD 的插件中，让 NPD 定期执行检测程序。</p>
<h2 id="Draino自动驱逐排空节点"><a href="#Draino自动驱逐排空节点" class="headerlink" title="Draino自动驱逐排空节点"></a>Draino自动驱逐排空节点</h2><p><a href="https://github.com/planetlabs/draino">Draino</a> 基于标签和 node conditions 自动排干 Kubernetes 节点。匹配了所有指定标签和任意指定 node condition 的节点会立即被禁用（cordon），并在等待 <code>drain-buffer</code> 时间后排干（drain）节点上的 pod。</p>
<p>Draino 通常是与 <a href="https://github.com/kubernetes/node-problem-detector">Node Problem Detector</a> 及 <a href="https://links.jianshu.com/go?to=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler">Cluster Autoscaler</a> 一起使用。NPD 通过监控节点日志或者执行某一脚本来探测节点健康状态，当 NPD 探测到某个节点上存在异常时，就会给该节点设置一个 node condition。Cluster Autoscaler 可以配置为删除未充分利用的节点。这两者搭配上 Draino 可以实现一些场景下的自动故障补救：</p>
<ol>
<li>NPD 探测到节点存在一个永久问题，并且给该节点设置相应的 node condition。</li>
<li>Draino 发现了这个 node condition，它会马上禁用该节点，从而避免有新的 pod 调度到这个故障节点，并开启定时任务来排干这个节点。</li>
<li>一旦该故障节点被排干，Cluster Autoscaler 会认为该节点未充分利用，Autoscaler 等待一段时间后将该节点缩容掉。</li>
</ol>
<h1 id="NPD部署"><a href="#NPD部署" class="headerlink" title="NPD部署"></a>NPD部署</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helm安装，这里参照官网</span></span><br><span class="line">helm repo add deliveryhero https://charts.deliveryhero.io/</span><br><span class="line">helm install --generate-name deliveryhero/node-problem-detector -n kube-system</span><br><span class="line"><span class="comment"># 查看demonset是否运行正常</span></span><br><span class="line">kubectl -n kube-system get pod | grep node-problem-detector</span><br><span class="line">node-problem-detector-bkbrl                  1/1     Running            0          23h</span><br><span class="line">node-problem-detector-prfqb                  1/1     Running            0          29h</span><br><span class="line">node-problem-detector-tdk47                  1/1     Running            0          22h</span><br><span class="line">node-problem-detector-xj86c                  1/1     Running            0          2d5h</span><br><span class="line">node-problem-detector-xm8ff                  1/1     Running            0          3d20h</span><br><span class="line"><span class="comment"># 这里也可以下载到本地自定修改一些配置，自定义增加一些检测的指标，不在这里赘述。</span></span><br><span class="line"><span class="comment"># 测试内核事件</span></span><br><span class="line"><span class="comment"># sudo sh -c &quot;echo &#x27;kernel: <span class="doctag">BUG:</span> unable to handle kernel NULL pointer dereference at TESTING&#x27; &gt;&gt; /dev/kmsg&quot;</span></span><br><span class="line"><span class="comment"># sudo sh -c &quot;echo &#x27;kernel: INFO: task docker:20744 blocked for more than 120 seconds.&#x27; &gt;&gt; /dev/kmsg&quot;</span></span><br><span class="line">kubectl describe node 10.4.83.25</span><br><span class="line">Conditions:</span><br><span class="line">  Type                 Status    LastHeartbeatTime                 LastTransitionTime                Reason                       Message</span><br><span class="line">  ----                 ------    -----------------                 ------------------                ------                       -------</span><br><span class="line">  KernelDeadlock       True      Tue, 25 Apr 2023 14:29:05 +0800   Tue, 25 Apr 2023 04:15:45 +0800   DockerHung                   kernel: INFO: task docker:20744 blocked <span class="keyword">for</span> more than 120 seconds.</span><br><span class="line"></span><br><span class="line">Events:</span><br><span class="line">  Type     Reason      Age   From            Message</span><br><span class="line">  ----     ------      ----  ----            -------</span><br><span class="line">  Warning  KernelOops  7s    kernel-monitor  kernel: BUG: unable to handle kernel NULL pointer dereference at TESTING</span><br><span class="line">  Warning  TaskHung    2s     kernel-monitor  kernel: INFO: task docker:20744 blocked <span class="keyword">for</span> more than 120 seconds.</span><br><span class="line">  Warning  DockerHung  2s     kernel-monitor  Node condition KernelDeadlock is now: True, reason: DockerHung, message: <span class="string">&quot;kernel: INFO: task docker:20744 blocked for more than 120 seconds.&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Draino部署及配置"><a href="#Draino部署及配置" class="headerlink" title="Draino部署及配置"></a>Draino部署及配置</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给节点添加label，这样节点就可以被draino自动排干</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">label</span> <span class="string">node</span> <span class="number">10.192</span><span class="number">.177</span><span class="number">.34</span> <span class="string">draino=node</span></span><br><span class="line"><span class="comment"># 部署deployment 配置</span></span><br><span class="line"><span class="string">cat</span> <span class="string">draino-deployment.yaml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span> &#123;<span class="attr">component:</span> <span class="string">draino</span>&#125;</span><br><span class="line">  <span class="attr">name:</span> <span class="string">draino</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span> &#123;<span class="attr">component:</span> <span class="string">draino</span>&#125;</span><br><span class="line">  <span class="attr">name:</span> <span class="string">draino</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span> &#123;<span class="attr">component:</span> <span class="string">draino</span>&#125;</span><br><span class="line">  <span class="attr">name:</span> <span class="string">draino</span></span><br><span class="line"><span class="attr">roleRef:</span> &#123;<span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span>, <span class="attr">kind:</span> <span class="string">ClusterRole</span>, <span class="attr">name:</span> <span class="string">draino</span>&#125;</span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> &#123;<span class="attr">kind:</span> <span class="string">ServiceAccount</span>, <span class="attr">name:</span> <span class="string">draino</span>, <span class="attr">namespace:</span> <span class="string">kube-system</span>&#125;</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span> &#123;<span class="attr">component:</span> <span class="string">draino</span>&#125;</span><br><span class="line">  <span class="attr">name:</span> <span class="string">draino</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># Draino does not currently support locking/master election, so you should</span></span><br><span class="line">  <span class="comment"># only run one draino at a time. Draino won&#x27;t start draining nodes immediately</span></span><br><span class="line">  <span class="comment"># so it&#x27;s usually safe for multiple drainos to exist for a brief period of</span></span><br><span class="line">  <span class="comment"># time.</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span> &#123;<span class="attr">component:</span> <span class="string">draino</span>&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span> &#123;<span class="attr">component:</span> <span class="string">draino</span>&#125;</span><br><span class="line">      <span class="attr">name:</span> <span class="string">draino</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pull-docker-image-secret</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="comment"># You&#x27;ll want to change these labels and conditions to suit your deployment.</span></span><br><span class="line">      <span class="comment">#- command: [/draino, --debug, --dry-run, --node-label=draino-enabled=true, BadCondition, ReallyBadCondition, KernelDeadlock, ReadonlyFilesystem]</span></span><br><span class="line">      <span class="comment"># --node-label-expr=&quot;metadata[&#x27;labels&#x27;][&#x27;draino&#x27;] in [&#x27;master&#x27;,&#x27;node&#x27;]&quot; --evict-unreplicated-pods --evict-emptydir-pods --evict-daemonset-pods KernelDeadlock ReadonlyFilesystem</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/draino</span></span><br><span class="line">        <span class="bullet">-</span>  <span class="string">--debug</span></span><br><span class="line">        <span class="comment">#-  --node-label=draino-enabled=true</span></span><br><span class="line">        <span class="comment">#- --dry-run</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--node-label-expr=metadata[&#x27;labels&#x27;][&#x27;draino&#x27;]</span> <span class="string">in</span> [<span class="string">&#x27;master&#x27;</span>,<span class="string">&#x27;node&#x27;</span>]</span><br><span class="line">        <span class="bullet">-</span> <span class="string">--max-grace-period=8m0s</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--eviction-headroom=30s</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--drain-buffer=10m0s</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--namespace=kube-system</span></span><br><span class="line">          <span class="comment">#- --evict-unreplicated-pods</span></span><br><span class="line">          <span class="comment">#- --evict-daemonset-pods</span></span><br><span class="line">          <span class="comment">#- --evict-emptydir-pods</span></span><br><span class="line">          <span class="comment"># - KernelDeadlock</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ReadonlyFilesystem</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.ljohn.cn/kgcr/draino:9d39b53</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span> &#123;<span class="attr">path:</span> <span class="string">/healthz</span>, <span class="attr">port:</span> <span class="number">10002</span>&#125;</span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">draino</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">draino</span></span><br><span class="line"><span class="comment"># 查看服务及日志</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">-n</span> <span class="string">kube-system</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">drain</span></span><br><span class="line"><span class="string">draino-5775bc9466-zvp4f</span>                      <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>            <span class="number">0</span>          <span class="string">10m</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">-n</span> <span class="string">kube-system</span> <span class="string">logs</span> <span class="string">-f</span> <span class="string">draino-5775bc9466-zvp4f</span></span><br><span class="line"><span class="number">2023-04-23T06:44:30.918Z</span>        <span class="string">INFO</span>    <span class="string">draino/draino.go:134</span>    <span class="string">web</span> <span class="string">server</span> <span class="string">is</span> <span class="string">running</span>   &#123;<span class="attr">&quot;listen&quot;:</span> <span class="string">&quot;:10002&quot;</span>&#125;</span><br><span class="line"><span class="number">2023-04-23T06:44:30.922Z</span>        <span class="string">DEBUG</span>   <span class="string">draino/draino.go:197</span>    <span class="string">label</span> <span class="string">expression</span>        &#123;<span class="attr">&quot;expr&quot;:</span> <span class="string">&quot;metadata[&#x27;labels&#x27;][&#x27;draino&#x27;] in [&#x27;master&#x27;,&#x27;node&#x27;]&quot;</span>&#125;</span><br><span class="line"><span class="string">I0423</span> <span class="number">06</span><span class="string">:44:30.922508</span>       <span class="number">1</span> <span class="string">leaderelection.go:235]</span> <span class="string">attempting</span> <span class="string">to</span> <span class="string">acquire</span> <span class="string">leader</span> <span class="string">lease</span>  <span class="string">kube-system/draino...</span></span><br><span class="line"><span class="string">I0423</span> <span class="number">06</span><span class="string">:44:48.346548</span>       <span class="number">1</span> <span class="string">leaderelection.go:245]</span> <span class="string">successfully</span> <span class="string">acquired</span> <span class="string">lease</span> <span class="string">kube-system/draino</span></span><br><span class="line"><span class="number">2023-04-23T06:44:48.346Z</span>        <span class="string">INFO</span>    <span class="string">draino/draino.go:236</span>    <span class="string">node</span> <span class="string">watcher</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看节点上服务 nettools-deploy</span></span><br><span class="line">kubectl get pod  -owide  | grep 10.192.177.34</span><br><span class="line">nettools-deploy-57c9465d74-29vqj   1/1     Running   1 (13d ago)   13d     10.194.82.131   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nettools-deploy-57c9465d74-jt7dg   1/1     Running   0             6h50m   10.194.82.144   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nettools-deploy-57c9465d74-kclmj   1/1     Running   0             5h30m   10.194.82.154   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nettools-deploy-57c9465d74-l7n24   1/1     Running   1 (13d ago)   13d     10.194.82.130   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nettools-deploy-57c9465d74-mz6mk   1/1     Running   0             5h30m   10.194.82.155   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">npd-node-problem-detector-7bllt    1/1     Running   0             26h     10.194.82.134   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="comment"># 主动给节点输入kernel异常,文件系统只读</span></span><br><span class="line">sudo sh -c <span class="string">&quot;echo &#x27;Remounting filesystem read-only&#x27; &gt;&gt; /dev/kmsg&quot;</span></span><br><span class="line"><span class="comment"># 查看node事件</span></span><br><span class="line">kubectl describe node 10.192.177.34</span><br><span class="line">...</span><br><span class="line">Conditions:</span><br><span class="line">  Type                    Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message</span><br><span class="line">  ----                    ------  -----------------                 ------------------                ------                       -------</span><br><span class="line">  CorruptDockerOverlay2   False   Mon, 24 Apr 2023 16:56:15 +0800   Sun, 23 Apr 2023 14:32:51 +0800   NoCorruptDockerOverlay2      docker overlay2 is functioning properly</span><br><span class="line">  KernelDeadlock          False   Mon, 24 Apr 2023 16:56:15 +0800   Sun, 23 Apr 2023 14:32:51 +0800   KernelHasNoDeadlock          kernel has no deadlock</span><br><span class="line">  ReadonlyFilesystem      True    Mon, 24 Apr 2023 16:56:15 +0800   Mon, 24 Apr 2023 16:56:15 +0800   FilesystemIsReadOnly         Remounting filesystem read-only</span><br><span class="line">  NetworkUnavailable      False   Tue, 11 Apr 2023 15:22:53 +0800   Tue, 11 Apr 2023 15:22:53 +0800   CalicoIsUp                   Calico is running on this node</span><br><span class="line">  MemoryPressure          False   Mon, 24 Apr 2023 16:58:06 +0800   Tue, 11 Apr 2023 15:22:48 +0800   KubeletHasSufficientMemory   kubelet has sufficient memory available</span><br><span class="line">  DiskPressure            False   Mon, 24 Apr 2023 16:58:06 +0800   Tue, 11 Apr 2023 15:22:48 +0800   KubeletHasNoDiskPressure     kubelet has no disk pressure</span><br><span class="line">  PIDPressure             False   Mon, 24 Apr 2023 16:58:06 +0800   Tue, 11 Apr 2023 15:22:48 +0800   KubeletHasSufficientPID      kubelet has sufficient PID available</span><br><span class="line">  Ready                   True    Mon, 24 Apr 2023 16:58:06 +0800   Tue, 11 Apr 2023 15:22:48 +0800   KubeletReady                 kubelet is posting ready status. AppArmor enabled                                    DrainScheduled          False   Mon, 24 Apr 2023 16:57:04 +0800   Mon, 24 Apr 2023 16:56:15 +0800   Draino                       Drain activity scheduled 2023-04-24T16:56:26+08:00 | Completed: 2023-04-24T16:57:04</span><br><span class="line">+08:00</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason              Age                     From            Message</span><br><span class="line">  ----     ------              ----                    ----            -------</span><br><span class="line">  Warning  CordonStarting      2m29s                   draino          Cordoning node</span><br><span class="line">  Warning  CordonSucceeded     2m29s                   draino          Cordoned node</span><br><span class="line">  Warning  DrainScheduled      2m29s                   draino          Will drain node after 2023-04-24T16:56:26.540741556+08:00</span><br><span class="line">  Normal   NodeNotSchedulable  2m28s (x2 over 6d23h)   kubelet         Node 10.192.177.34 status is now: NodeNotSchedulable</span><br><span class="line">  Warning  DrainStarting       2m18s                   draino          Draining node</span><br><span class="line">  Warning  DrainSucceeded      100s                    draino          Drained node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后查看节点已经被关闭调度，并且主机上pod，除了demonset的pod均已经被驱逐,刚部署的nettools-deploy也被调度到其他节点。</span></span><br><span class="line">kubectl get node 10.192.177.34</span><br><span class="line">NAME            STATUS                     ROLES   AGE   VERSION</span><br><span class="line">10.192.177.34   Ready,SchedulingDisabled   node    13d   v1.22.14</span><br><span class="line">kubectl get pod -owide -A | grep 10.192.177.34</span><br><span class="line">default                        npd-node-problem-detector-7bllt             1/1     Running     0              26h     10.194.82.134   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system                    calico-node-7dwv8                           1/1     Running     1 (13d ago)    13d     10.192.177.34   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-system                    node-local-dns-rdj24                        1/1     Running     1 (13d ago)    13d     10.192.177.34   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubesphere-monitoring-system   node-exporter-c8xkv                         2/2     Running     0              2d23h   10.192.177.34   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubesphere-system              node-shell-jzvcp                            1/1     Running     0              5d7h    10.192.177.34   10.192.177.34   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/planetlabs/draino">draino</a></p>
<p><a href="https://github.com/kubernetes/node-problem-detector">node-problem-detector</a></p>
<p><a href="https://www.jianshu.com/p/eeba98425307">https://www.jianshu.com/p/eeba98425307</a></p>
<p><a href="https://www.jianshu.com/p/cc6a45cf3208">https://www.jianshu.com/p/cc6a45cf3208</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
        <tag>npd</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet状态更新和自驱逐参数优化</title>
    <url>/posts/7f9c3178/</url>
    <content><![CDATA[<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul>
<li>kubelet： v1.19.10</li>
<li>os：centos7.9</li>
<li>deploy：<a href="https://github.com/easzlab/kubeasz">kubeasz</a></li>
</ul>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>当 Kubernetes 中 Node 节点出现状态异常的情况下，节点上的 Pod 会被重新调度到其他节点上去，但是有的时候我们会发现节点 Down 掉以后，Pod 并不会立即触发重新调度，这实际上就是和 Kubelet 的状态更新机制密切相关的，Kubernetes 提供了一些参数配置来触发重新调度的时间，为了简单起见，将跳过 HA 的部分，仅描述 Kubelet&lt;-&gt;Controller Manager 通信流程。</p>
<p>默认情况下，正常行为：</p>
<ul>
<li>kubelet 自身会定期更新状态到 apiserver，通过参数 –node-status-update-frequency 指定上报频率，默认是 10s 上报一次。</li>
<li>Kubernetes controller manager 每隔 –node-monitor-period 检查 Kubelet 的状态。默认值为 5 秒。</li>
<li>如果状态在 –node-monitor-grace-period 时间内更新，Kubernetes controller manager 认为 Kubelet 处于健康状态。默认值为 40 秒。</li>
</ul>
<blockquote>
<p>Kubernetes controller manager 和 kubelet 是异步工作。这意味着延迟可能包括任何网络延迟、API Server 延迟、etcd 延迟、由控制平面节点上的负载引起的延迟等。所以如果 –node-status-update-frequency 设置为 5s 实际上它可能会在 6-7 秒甚至更长的时间出现在 etcd 中，因为 etcd 无法将数据提交到仲裁节点。</p>
</blockquote>
<h2 id="节点故障时"><a href="#节点故障时" class="headerlink" title="节点故障时"></a>节点故障时</h2><p>Kubelet将尝试进行 <code>nodeStatusUpdateRetry</code> POST。目前在kubelet.go中，<code>nodeStatusUpdateRetry</code>经常设置为5。</p>
<p>Kubelet将尝试更新 tryUpdateNodeStatus函数中的状态。Kubelet使用 <code>http.Client() Golang</code>方法，但没有指定的超时时间。因此，在建立TCP连接时，当API服务器过载时可能会出现一些故障。</p>
<p>因此，将会有 <code>nodeStatusUpdateRetry*--node-status-update-furn</code>尝试设置节点的状态。</p>
<p>同时，Kubernetes控制器管理器将尝试每隔一段时间-node-monitor-period，检查节点状态更新nodeStatusUpdateRetry重试次数  。在节点监视器宽限期-node-monitor-grace-period之后，它将认为节点运行不正常。然后，将根据您单独设置的基于污染的逐出计时器或API服务器的全局计时器重新调度Pod：<code>--default-not-ready-toleration-seconds &amp; --default-unreachable-toleration-seconds</code></p>
<p>kube-proxy在API上有一个监视器。Pod被逐出后，kube-proxy会注意到并更新节点的iptable。它将从服务中删除端点，因此故障节点中的POD将不再可访问。</p>
<h1 id="基于不同场景配置"><a href="#基于不同场景配置" class="headerlink" title="基于不同场景配置"></a>基于不同场景配置</h1><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><table>
<thead>
<tr>
<th>组件</th>
<th>参数</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>kubelet</td>
<td>–node-status-update-frequency or nodeStatusUpdateFrequency</td>
<td>node状态更新频率</td>
<td>10s</td>
</tr>
<tr>
<td>kube-controller-manager</td>
<td>-node-monitor-period</td>
<td>在kube-controller中同步Node状态的时间</td>
<td>5s</td>
</tr>
<tr>
<td>kube-controller-manager</td>
<td>–node-monitor-grace-period</td>
<td>允许运行节点无响应的时间。（必须是kubelet的nodeStatusUpdateFrequency的N倍，其中N表示允许kubelet发布节点状态的重试次数）</td>
<td>40s</td>
</tr>
<tr>
<td>kube-controller-manager</td>
<td>–pod-eviction-timeout</td>
<td>删除失败节点上的pod的宽限期。</td>
<td>5m0s</td>
</tr>
<tr>
<td>kube-apiserver</td>
<td>–default-not-ready-toleration-seconds</td>
<td>指示notReady:NoExecute的容忍度的容忍度时间（秒）</td>
<td>300</td>
</tr>
<tr>
<td>kube-apiserver</td>
<td>–default-unreachable-toleration-seconds</td>
<td>指示对不可访问的容忍度的容忍时间（秒）</td>
<td>300</td>
</tr>
</tbody></table>
<h2 id="快速更新和快速反应"><a href="#快速更新和快速反应" class="headerlink" title="快速更新和快速反应"></a>快速更新和快速反应</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 kube-controller-manager启动参数或者配置文件新增如下配置</span></span><br><span class="line">--node-monitor-period: 2s (default 5s)</span><br><span class="line">--node-monitor-grace-period: 20s (default 40s)</span><br><span class="line">--pod-eviction-timeout: 30s (default 5m0s)</span><br><span class="line"><span class="comment"># 修改 kubelet配置参数</span></span><br><span class="line">--node-status-update-frequency: 4s （default 10s）</span><br><span class="line">或</span><br><span class="line">(nodeStatusUpdateFrequency: 4s default 10s)</span><br><span class="line"><span class="comment"># 修改 kube-apiserver配置参数</span></span><br><span class="line">--default-unreachable-toleration-seconds=60 (default 300) <span class="comment">#指示对不可访问的容忍度的容忍度秒数：NoExecute，默认情况下添加到尚未具有这种容忍度的每个pod</span></span><br><span class="line">--default-not-ready-toleration-seconds=60 (default 300) <span class="comment">#指示notReady:NoExecute的容忍度的容忍度秒数，默认情况下，该值会添加到尚未具有此类容忍度的每个pod中。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这种情况下，Pod 将在 50s 被驱逐，因为该节点在 20s 后被视为Down掉了，–pod-eviction-timeout 在 30s 之后发生，Kubelet将尝试每4秒更新一次状态。因此，在Kubernetes控制器管理器考虑节点的不健康状态之前，它将是 (20s / 4s * 5) = 25 次尝试，但是，这种情况会给 etcd 产生很大的开销，因为每个节点都会尝试每 2s 更新一次状态。</p>
<p>如果环境有1000个节点，那么每分钟将有(60s / 4s * 1000) = 15000次节点更新操作，这可能需要大型 etcd 容器甚至是 etcd 的专用节点。</p>
</blockquote>
<h2 id="中等更新和平均反应"><a href="#中等更新和平均反应" class="headerlink" title="中等更新和平均反应"></a>中等更新和平均反应</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 kube-controller-manager 启动参数或者配置文件新增如下配置</span></span><br><span class="line">--node-monitor-period: 5s (default 5s)</span><br><span class="line">--node-monitor-grace-period: 1m0s (default 40s)</span><br><span class="line">--pod-eviction-timeout: 1m0s (default 5m0s)</span><br><span class="line"><span class="comment"># 修改 kubelet配置参数</span></span><br><span class="line">--node-status-update-frequency: 10s （default 10s）</span><br><span class="line">或</span><br><span class="line">(nodeStatusUpdateFrequency: 10s (default 10s)</span><br><span class="line"><span class="comment"># 修改 kube-apiserver配置参数</span></span><br><span class="line">--default-unreachable-toleration-seconds=60 (default 300) <span class="comment">#指示对不可访问的容忍度的容忍度秒数：NoExecute，默认情况下添加到尚未具有这种容忍度的每个pod</span></span><br><span class="line">--default-not-ready-toleration-seconds=60 (default 300) <span class="comment">#指示notReady:NoExecute的容忍度的容忍度秒数，默认情况下，该值会添加到尚未具有此类容忍度的每个pod中。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种场景下会，Kubelet将尝试每10秒更新一次状态。因此，在Kubernetes控制器管理器检查节点的不健康状态之前，它将是 (1m / 10s *5) = 30 次尝试，节点异常后Pod将在 3m以内被驱逐。目前我们生产就采用该配置。</p>
</blockquote>
<h2 id="低更新和慢反应"><a href="#低更新和慢反应" class="headerlink" title="低更新和慢反应"></a>低更新和慢反应</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 kube-controller-manager 启动参数或者配置文件新增如下配置</span></span><br><span class="line">--node-monitor-period: 5s (default 5s)</span><br><span class="line">--node-monitor-grace-period: 5m0s (default 40s)</span><br><span class="line">--pod-eviction-timeout: 1m0s (default 5m0s)</span><br><span class="line"><span class="comment"># 修改 kubelet配置参数</span></span><br><span class="line">--node-status-update-frequency: 60s （default 10s）</span><br><span class="line">或</span><br><span class="line">(nodeStatusUpdateFrequency: 60s (default 10s)</span><br><span class="line"><span class="comment"># 修改 kube-apiserver配置参数</span></span><br><span class="line">--default-unreachable-toleration-seconds=60 (default 300) <span class="comment">#指示对不可访问的容忍度的容忍度秒数：NoExecute，默认情况下添加到尚未具有这种容忍度的每个pod</span></span><br><span class="line">--default-not-ready-toleration-seconds=60 (default 300) <span class="comment">#指示notReady:NoExecute的容忍度的容忍度秒数，默认情况下，该值会添加到尚未具有此类容忍度的每个pod中。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种场景下会，Kubelet将尝试每10秒更新一次状态。因此，在Kubernetes控制器管理器检查节点的不健康状态之前，它将是 (5m / 1m *5) = 20 次尝试。节点被标记为不健康状态之后，Pod 将在 1m以内被驱逐。（总计6分钟左右）</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md?spm=a2c6h.12873639.article-detail.148.5575136eM59wC5&file=kubernetes-reliability.md">https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md?spm=a2c6h.12873639.article-detail.148.5575136eM59wC5&amp;file=kubernetes-reliability.md</a></p>
<p><a href="http://team.jiunile.com/blog/2019/08/k8s-kubelet-sync-node-status.html">http://team.jiunile.com/blog/2019/08/k8s-kubelet-sync-node-status.html</a></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
</search>
