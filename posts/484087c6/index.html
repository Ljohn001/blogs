<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Kubernetes容器网络 | Ljohn's Blog</title><meta name="author" content="Ljohn"><meta name="copyright" content="Ljohn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="容器是什么容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬到任何地方运行。对于大多数如Docker、RKT，等Linux容器，其实就是利用Linux Namespace技术创建隔离的进程空间、文件系统、网络命名空间、用户空间、主机名的一组进程。 所以说，容器，其实">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes容器网络">
<meta property="og:url" content="https://www.ljohn.cn/posts/484087c6/">
<meta property="og:site_name" content="Ljohn&#39;s Blog">
<meta property="og:description" content="容器是什么容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬到任何地方运行。对于大多数如Docker、RKT，等Linux容器，其实就是利用Linux Namespace技术创建隔离的进程空间、文件系统、网络命名空间、用户空间、主机名的一组进程。 所以说，容器，其实">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.ljohn.cn/img/head.png">
<meta property="article:published_time" content="2021-07-15T01:14:37.000Z">
<meta property="article:modified_time" content="2024-03-14T07:48:33.700Z">
<meta property="article:author" content="Ljohn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.ljohn.cn/img/head.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.ljohn.cn/posts/484087c6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes容器网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-14 15:48:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Ljohn's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://run.ljohn.cn"><span> 跑步</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-graduation-cap"></i><span> 外链</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/favorite/"><i class="fa-fw fa fa-link"></i><span> 宝藏链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 自述</span></a></div><div class="menus_item"><a class="site-page" href="https://www.ljohn.cn/atom.xml"><span> RSS</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Ljohn's Blog"><span class="site-name">Ljohn's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://run.ljohn.cn"><span> 跑步</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-graduation-cap"></i><span> 外链</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/favorite/"><i class="fa-fw fa fa-link"></i><span> 宝藏链接</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 自述</span></a></div><div class="menus_item"><a class="site-page" href="https://www.ljohn.cn/atom.xml"><span> RSS</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Kubernetes容器网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-15T01:14:37.000Z" title="发表于 2021-07-15 09:14:37">2021-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-14T07:48:33.700Z" title="更新于 2024-03-14 15:48:33">2024-03-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Kubernetes容器网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="容器是什么"><a href="#容器是什么" class="headerlink" title="容器是什么"></a>容器是什么</h2><p>容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬到任何地方运行。对于大多数如Docker、RKT，等Linux容器，其实就是利用Linux Namespace技术创建隔离的进程空间、文件系统、网络命名空间、用户空间、主机名的一组进程。</p>
<p>所以说，容器，其实是一种特殊的进程而已。</p>
<p>一个“容器”，实际上是一个由 Linux Namespace、Linux Cgroups 和 rootfs 三种技术构建出来的进程的隔离环境。</p>
<h3 id="容器优势"><a href="#容器优势" class="headerlink" title="容器优势"></a>容器优势</h3><ul>
<li>开销更少，无需像虚拟化一样虚拟完整的内核以及初始化环境，和启动一些多余的系统进程。</li>
<li>可移植性强，容器可以轻松在不同平台移植，如直接运行<code>docker run -d --name nginx -p 80:80 nginx</code></li>
<li>高效率，开发打完包构建容器后，可以更快部署，发布</li>
<li>敏捷开发，更快的移植，无需担心依赖的环境不一致的问题</li>
<li>….</li>
</ul>
<h3 id="Kebernetes"><a href="#Kebernetes" class="headerlink" title="Kebernetes"></a>Kebernetes</h3><p>k8s 是什么？为什么要引入 k8s，kubernetes 其实是google公司开源，和Redhat公司一起开发的一个容器编排项目。</p>
<ul>
<li><p>k8s 是什么，为什么要引入k8s：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/">https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/</a></p>
</li>
<li><p>k8s 组件有哪些：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://kubernetes.io/zh/docs/concepts/overview/components/">https://kubernetes.io/zh/docs/concepts/overview/components/</a> </p>
</li>
</ul>
<h2 id="容器网络模型"><a href="#容器网络模型" class="headerlink" title="容器网络模型"></a>容器网络模型</h2><h3 id="docker-的三种网络模式"><a href="#docker-的三种网络模式" class="headerlink" title="docker 的三种网络模式"></a>docker 的三种网络模式</h3><p>在将容器网络之前先讲一下docker 的网络模式，<code>docker network ls</code>  可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">7152832275d0        bridge              bridge              local</span><br><span class="line">bfc2647e9b0b        host                host                local</span><br><span class="line">00ed57db3efb        none                null                local</span><br></pre></td></tr></table></figure>

<ul>
<li><p>bridge 借助虚拟网桥设备为容器建立网络连接</p>
</li>
<li><p>host 设置容器直接共享当前节点主机的网络名称空间</p>
</li>
<li><p>none 对于此容器，禁用所有网络。通常与自定义网络驱动程序结合使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个容器都有自己的独立的&#x27;网络栈&#x27;，如果你想要实现两台主机之间的通信，最直接的办法，就是把它们用一根网线连接起来；而如果你想要实现多台主机之间的通信，那就需要用网线，把它们连接在一台交换机上，即网桥（Bridge）。它是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上</span></span><br><span class="line"><span class="comment"># 在容器中，Docker安装完成时会创建一个名为docker0的linux bridge，不指定网络时，创建的网络默认为桥接网络，都会桥接到docker0上。</span></span><br><span class="line"><span class="comment"># 如何把容器连接到这个docker0 网桥上呢？这个时候就需要 Veth Pair 的虚拟设备了，该设备一般是成对的出现，并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242f2caa77e       no</span><br><span class="line">pan1            8000.000000000000       no</span><br><span class="line">$ docker run -d -u daemon  --name <span class="string">&#x27;net-bridge&#x27;</span> busybox top </span><br><span class="line">$ docker <span class="built_in">exec</span> -ti net-bridge  /bin/sh</span><br><span class="line"><span class="comment"># Veth Pair虚拟网卡设备eth0@if62</span></span><br><span class="line">/ $ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">61: eth0@if62: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">/ $ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"><span class="comment"># 宿主机上查看接口信息,启动了一个虚拟网卡设备 vethaf3497b@if61</span></span><br><span class="line">$ ip a | tail -4</span><br><span class="line">62: vethaf3497b@if61: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link/ether ca:2f:b0:6a:a1:28 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::c82f:b0ff:fe6a:a128/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># brctl show 可以看到docker0 设备上多了一个接口 vethf29b81e 即刚才启动容器的虚拟网卡</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242f2caa77e       no              vethaf3497b</span><br><span class="line">pan1            8000.000000000000       no</span><br><span class="line"></span><br><span class="line"><span class="comment"># host网络，就是和host主机共享网络，会和host使用一样的网络，host网络的性能比较高，但也会不可避免地引入共享网络资源的问题，比如端口冲突，比如隔离性问题。</span></span><br><span class="line"></span><br><span class="line">$ docker run --net=host busybox ifconfig</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:F2:CA:A7:7E</span><br><span class="line">          inet addr:172.17.0.1  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:f2ff:feca:a77e/64 Scope:Link</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:274096 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:323190 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:13525456 (12.8 MiB)  TX bytes:1664281006 (1.5 GiB)</span><br><span class="line"></span><br><span class="line">enp0s31f6 Link encap:Ethernet  HWaddr 54:E1:AD:08:B4:21</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line">          Interrupt:16 Memory:f2200000-f2220000</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1850471 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1850471 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:1186483790 (1.1 GiB)  TX bytes:1186483790 (1.1 GiB)</span><br><span class="line"></span><br><span class="line">pan1      Link encap:Ethernet  HWaddr 12:AA:30:13:D7:A4</span><br><span class="line">          inet addr:10.6.207.1  Bcast:10.6.207.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::10aa:30ff:fe13:d7a4/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:14194 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:2916067 (2.7 MiB)</span><br><span class="line">wlp3s0    Link encap:Ethernet  HWaddr F8:59:71:8E:3F:55</span><br><span class="line">          inet addr:10.10.134.147  Bcast:10.10.143.255  Mask:255.255.240.0</span><br><span class="line">          inet6 addr: fe80::54ce:44cc:368:d288/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:16914279 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4101535 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:7919534294 (7.3 GiB)  TX bytes:2673781183 (2.4 GiB)          </span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment"># none网络，在该网络下的容器仅有lo网卡，属于封闭式网络，通常用于对安全性要求较高并且不需要联网的应用</span></span><br><span class="line">docker run --rm -it --network=none busybox ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ul>
<p>接下来以docker 两种通信方式来介绍容器通信模式：</p>
<h3 id="单机容器通信"><a href="#单机容器通信" class="headerlink" title="单机容器通信"></a>单机容器通信</h3><p>同一个宿主机上的不同容器通过 docker0 网桥进行通信的流程如图：</p>
<p><img src="https://i.loli.net/2021/07/14/VutyxR1TczBPSpv.png" alt="image-20210713104524840"></p>
<p>如图说所示，在容器中，通过docker0网桥，凡是连接到docker0的容器，就可以通过它来进行通信。要想容器能够连接到docker0网桥，我们需要类似网线的虚拟设备Veth Pair来把容器连接到网桥上。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动一个container1 </span></span><br><span class="line">$ docker run -d --name <span class="string">&#x27;container1&#x27;</span> nginx</span><br><span class="line">$ dockrer <span class="built_in">exec</span> -ti container1  /bin/sh</span><br><span class="line">$ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">65: eth0@if66: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">$ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个container2</span></span><br><span class="line">$ docker run -d --name <span class="string">&#x27;container2&#x27;</span> nginx</span><br><span class="line">$ dockrer <span class="built_in">exec</span> -ti container2  /bin/sh</span><br><span class="line">$ ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">63: eth0@if64: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="comment"># route -n</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看宿主机上的虚拟设备Veth Pair, veth182b3a5@if63 和 container2 的eth0@if64 是一对，container1 同理。</span></span><br><span class="line">$ ip a | tail -8</span><br><span class="line">64: veth182b3a5@if63: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link/ether 76:97:8e:fe:a9:c7 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::7497:8eff:fefe:a9c7/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">66: veth877c7d8@if65: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default</span><br><span class="line">    link/ether 12:7e:d0:0f:ae:99 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet6 fe80::107e:d0ff:fe0f:ae99/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># container1 ping container2 测试</span></span><br><span class="line"><span class="comment"># ping 172.17.0.3</span></span><br><span class="line">PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.091 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.034 ms</span><br><span class="line"><span class="comment"># 可以看到同一宿主机容器默认都是通的，是因为他们默认网关都是docker0 这块网卡。 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="跨主机容器通信"><a href="#跨主机容器通信" class="headerlink" title="跨主机容器通信"></a>跨主机容器通信</h3><p>跨主机通信方案有以下几种方案：</p>
<ul>
<li>NAT方式<br>NAT就是传统的docker网络，利用宿主机的IP和Iptables来达到容器，主机之间的通信。容器对外IP都是宿主机的IP，NAT的性能损耗比较大。但只要宿主机之间三层IP可达，容器之间就可以通信，比较普适。</li>
<li>Tunnel（overlay）方式，VPN，ipip，VXLAN等都是tunnel技术，简单讲就是在容器的数据包间封装一层或多层其他的数据协议头，达到连通的效果。这种方式一般也是只需要三层可达，容器就能互通，比较普适。</li>
<li>Routing方式<br>路由方案主要是通过路由设置的方式让容器对容器，容器对宿主机之间相通信。例如：calico的BGP路由方案（非IPIP）。这种方式一般适用于单个数据中心，最常见的是同一个vlan中使用，如果不是，需要设置路由规则。路由方案性能损耗少，和主机网络性能比较接近。</li>
</ul>
<p>先介绍下NAT方式，所有接入到该桥接设备上的容器都会被NAT隐藏，它们发往Docker主机外部的所有流量都会经过源地址转换后发出(SNAT)，并且默认是无法直接接受节点之外的其他主机发来的请求。当需要接入Docker主机外部流量，就需要进行目标地址转换(DNAT)甚至端口转换将其暴露在外部网络当中。大致的流程图：</p>
<p><img src="https://i.loli.net/2021/07/14/scPfALv6ibqEMWI.png" alt="image-20210713111835432"></p>
<p>容器内的属于私有地址，需要在左侧的主机上的eth0上进行源地址转换，而右侧的地址需要被访问，就需要将eth0的地址进行NAT转换。SNAT—-&gt;DNAT。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#具体方案在2个主机上通过主机路由和iptables 地址伪装来实现跨主机容器的互通，这里就不做过多解释</span><br></pre></td></tr></table></figure>

<h2 id="Kubernetes-容器网络CNI插件"><a href="#Kubernetes-容器网络CNI插件" class="headerlink" title="Kubernetes 容器网络CNI插件"></a>Kubernetes 容器网络CNI插件</h2><p>这里介绍完docker的网络方案之后，我们来聊聊kubernetes的容器间网络的通信方案。</p>
<p>官网中文doc：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/">https://kubernetes.io/zh/docs/concepts/cluster-administration/networking/</a></p>
<p>那么什么是CNI（container network interface）容器网络接口，k8s为了更好的控制网络的接入，推出了CNI即容器网络的API接口。CNI维护了一个单独的网桥来代替 docker0。这个网桥的名字就叫作：CNI 网桥，它在宿主机上的设备名称默认是：cni0。</p>
<p>CNI主要解决Pod间的通信，目前流行的CNI插件如：calico, cilium, flannel, kube-ovn, kube-router</p>
<h2 id="Flannel-插件跨主机通信原理"><a href="#Flannel-插件跨主机通信原理" class="headerlink" title="Flannel 插件跨主机通信原理"></a>Flannel 插件跨主机通信原理</h2><p>Flannel 项目是 CoreOS 公司主推的容器网络方案。事实上，Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现。目前，Flannel 支持三种后端实现，分别是：</p>
<ul>
<li>UDP</li>
<li>VXLAN</li>
<li>host-gw</li>
</ul>
<h3 id="udp模式"><a href="#udp模式" class="headerlink" title="udp模式"></a>udp模式</h3><p><img src="https://i.loli.net/2021/07/14/zSH467pZwVF1LBg.png" alt="image-20210713190907679"></p>
<p>可以看到，Flannel UDP 模式提供的其实是一个三层的 Overlay 网络，即：它首先对发出端的 IP 包进行 UDP 封装，然后在接收端进行解封装拿到原始的 IP 包，进而把这个 IP 包转发给目标容器。这就好比，Flannel 在不同宿主机上的两个容器之间打通了一条“隧道”，使得这两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况。</p>
<p>但是UDP 模式有严重的性能问题，基本已经上被废弃了。</p>
<p>基于 Flannel UDP 模式的容器通信多了一个额外的步骤，即 flanneld 的处理过程。而这个过程，由于使用到了 flannel0 这个 TUN 设备，仅在发出 IP 包的过程中，就需要经过三次用户态与内核态之间的数据拷贝，其性能可想而知。</p>
<h3 id="VXLAN模式"><a href="#VXLAN模式" class="headerlink" title="VXLAN模式"></a>VXLAN模式</h3><p>VXLAN，即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络虚似化技术。所以说，VXLAN 可以完全在内核态实现上述封装和解封装的工作，从而通过与前面相似的“隧道”机制，构建出覆盖网络（Overlay Network）</p>
<p><img src="https://i.loli.net/2021/07/14/Kqv7ULZscznIGFC.png" alt="image-20210713191114467"></p>
<p>VXLAN 模式组建的覆盖网络，其实就是一个由不同宿主机上的 VTEP 设备，也就是 flannel.1 设备组成的虚拟二层网络。对于 VTEP 设备来说，它发出的“内部数据帧”就仿佛是一直在这个虚拟的二层网络上流动。这，也正是覆盖网络的含义,具体就不展开了。</p>
<h2 id="Kubernetes-三层网络方案"><a href="#Kubernetes-三层网络方案" class="headerlink" title="Kubernetes 三层网络方案"></a>Kubernetes 三层网络方案</h2><p>讲了以上flannel 的以上2种方案，我们接下来讲一下纯三层的网络方案，如于 Flannel 的 host-gw 模式和 Calico BGP</p>
<h3 id="Flannel-的-host-gw-模式"><a href="#Flannel-的-host-gw-模式" class="headerlink" title="Flannel 的 host-gw 模式"></a>Flannel 的 host-gw 模式</h3><p><img src="https://i.loli.net/2021/07/14/xp64BmUif5PMXsl.png" alt="image-20210714221235728"></p>
<p>假设现在，Node 1 上的 Infra-container-1，要访问 Node 2 上的 Infra-container-2。</p>
<p>当你设置 Flannel 使用 host-gw 模式之后，flanneld 会在宿主机上创建这样一条规则，以 Node 1 为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip route</span><br><span class="line">...</span><br><span class="line">10.244.1.0/24 via 10.168.0.3 dev eth0</span><br></pre></td></tr></table></figure>

<p>这条路由规则的含义是：目的 IP 地址属于 10.244.1.0/24 网段的 IP 包，应该经过本机的 eth0 设备发出去（即：dev eth0）；并且，它下一跳地址（next-hop）是 10.168.0.3（即：via 10.168.0.3）。</p>
<p>如图所示这个下一跳地址对应的，正是我们的目的宿主机 Node 2。</p>
<p>一旦配置了下一跳地址，那么接下来，当 IP 包从网络层进入链路层封装成帧的时候，eth0 设备就会使用下一跳地址对应的 MAC 地址，作为该数据帧的目的 MAC 地址。显然，这个 MAC 地址，正是 Node 2 的 MAC 地址。这样，这个数据帧就会从 Node 1 通过宿主机的二层网络顺利到达 Node 2 上。</p>
<p>而 Node 2 的内核网络栈从二层数据帧里拿到 IP 包后，会“看到”这个 IP 包的目的 IP 地址是 10.244.1.3，即 Infra-container-2 的 IP 地址。这时候，根据 Node 2 上的路由表，该目的地址会匹配到第二条路由规则（也就是 10.244.1.0 对应的路由规则），从而进入 cni0 网桥，进而进入到 Infra-container-2 当中。</p>
<p>host-gw 模式的工作原理，其实就是将每个 Flannel 子网（Flannel Subnet，比如：10.244.1.0/24）的“下一跳”，设置成了该子网对应的宿主机的 IP 地址。所以宿主机充当了“网关”的角色，即顾名思义“host-gw”</p>
<h3 id="Calico"><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h3><p>Calico 是一套开源的网络和网络安全方案，用于容器、虚拟机、宿主机之前的网络连接，可以用在kubernetes、OpenShift、DockerEE、OpenStrack等PaaS或IaaS平台上。</p>
<p>首先看下calico 架构图</p>
<p><img src="https://i.loli.net/2021/07/14/t4dhz5sQkFiPWcl.png" alt="image-20210713170229021"></p>
<ul>
<li><code>Felix</code>：<code>calico</code>的核心组件，运行在每个节点上。主要的功能有接口管理、路由规则、ACL规则和状态报告</li>
<li><code>Etcd</code>：保证数据一致性的数据库，存储集群中节点的所有路由信息。为保证数据的可靠和容错建议至少三个以上etcd节点。</li>
<li><code>Bird</code>：BGP客户端，<code>Calico</code>在每个节点上的都会部署一个BGP客户端（利用Daemonset方式部署），它的作用是将Felix的路由信息读入内核，并通过BGP协议在集群中分发。当Felix将路由插入到Linux内核FIB中时，BGP客户端将获取这些路由并将它们分发到部署中的其他节点。这可以确保在部署时有效地路由流量。</li>
<li><code>BGP Router Reflector</code>：使用 BGP client 形成 mesh 全网互联的方案就会导致规模限制，所有节点需要 N^2 个连接，为了解决这个规模问题，BGP 的 <code>Router Reflector</code>的方法，使所有 BGP Client 仅与特定 RR 节点互联并做路由同步，从而大大减少连接数。</li>
</ul>
<h4 id="Calico-网络模式"><a href="#Calico-网络模式" class="headerlink" title="Calico 网络模式"></a>Calico 网络模式</h4><ul>
<li> IPIP模式，把 IP 层封装到 IP 层的一个 tunnel。作用其实基本上就相当于一个基于IP层的网桥！一般来说，普通的网桥是基于mac层的，根本不需 IP，而这个 ipip 则是通过两端的路由做一个 tunnel，把两个本来不通的网络通过点对点连接起来。</li>
<li>Router Reflector 模式（RR），Calico 维护的网络在默认是（Node-to-Node Mesh）全互联模式，Calico集群中的节点之间都会相互建立连接，用于路由交换。但是随着集群规模的扩大，mesh模式将形成一个巨大服务网格，连接数成倍增加。这时就需要使用 Route Reflector（路由器反射）模式解决这个问题。</li>
</ul>
<h4 id="BGP-协议"><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h4><p><code>BGP（border gateway protocol）是外部路由协议（边界网关路由协议）</code>，用来在AS之间传递路由信息是一种增强的距离矢量路由协议（应用场景），基本功能是在自治系统间自动交换无环路的路由信息，通过交换带有自治系统号序列属性的路径可达信息，来构造自治系统的拓扑图，从而消除路由环路并实施用户配置的路由策略。<strong>只要记住BGP简单理解其实就是实现大规模网络中节点路由信息同步共享的一种协议</strong>。</p>
<blockquote>
<p>实际上，Calico 项目提供的 <code>BGP</code> 网络解决方案，与 <code>Flannel</code> 的 <code>host-gw</code> 模式几乎一样。也就是说，Calico也是基于路由表实现容器数据包转发，但不同于Flannel使用flanneld进程来维护路由信息的做法，而Calico项目使用BGP协议来自动维护整个集群的路由信息。</p>
</blockquote>
<p>BGP模式</p>
<ul>
<li><code>全互联模式</code>（node-to-node mesh） 每一个BGP Speaker都需要和其他BGP Speaker建立BGP连接，这样BGP连接总数就是N^2，如果数量过大会消耗大量连接。如果集群数量超过100台官方不建议使用此种模式。</li>
<li>RR模式（Router Reflection），会指定一个或多个BGP Speaker为RouterReflection，它与网络中其他Speaker建立连接，每个Speaker只要与Router Reflection建立BGP就可以获得全网的路由信息。在calico中可以通过<code>Global Peer</code>实现RR模式。</li>
</ul>
<h4 id="Calico-IPIP"><a href="#Calico-IPIP" class="headerlink" title="Calico IPIP"></a>Calico IPIP</h4><p><img src="https://i.loli.net/2021/07/14/dtF9w1YTnsIZ4Ek.png" alt="image-20210714210320203"></p>
<p>IPIP 是linux内核的驱动程序，可以对数据包进行隧道，上图可以看到两个不同的网络 vlan1 和 vlan2。基于现有的以太网将原始包中的原始IP进行一次封装，通过tunl0解包，这个tunl0类似于ipip模块，和Flannel vxlan的veth很类似。</p>
<p>Pod1 访问 Pod2 流程如下：</p>
<ol>
<li><p>数据包从 Pod1 出到达Veth Pair另一端（宿主机上，以cali前缀开头）。</p>
</li>
<li><p>进入IP隧道设备（tunl0），由Linux内核IPIP驱动封装，把源容器ip换成源宿主机ip，目的容器ip换成目的主机ip，这样就封装成 Node1 到 Node2 的数据包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">此时包的类型：</span><br><span class="line">  原始IP包：</span><br><span class="line">  源IP：10.244.1.10</span><br><span class="line">  目的IP：10.244.2.10</span><br><span class="line"></span><br><span class="line">   TCP：</span><br><span class="line">   源IP: 192.168.31.62</span><br><span class="line">   目的iP：192.168.32.63</span><br></pre></td></tr></table></figure></li>
<li><p>数据包经过路由器三层转发到 Node2</p>
</li>
<li><p>Node2 收到数据包后，网络协议栈会使用IPIP驱动进行解包，从中拿到原始IP包。</p>
</li>
<li><p>然后根据路由规则，将数据包转发给cali设备，从而到达 Pod2。</p>
</li>
</ol>
<p>通过如上步骤可以看出，当 Calico 使用 IPIP 模式的时候，集群的网络性能会因为额外的封包和解包工作而下降。所以建议你将所有宿主机节点放在一个子网里，避免使用 IPIP。<strong>不过这里可以利用IPIP模式的CrossSubnet来突破node不能跨VALN的问题，这个目前已经测试通过。</strong></p>
<h4 id="Calico-BGP-RR"><a href="#Calico-BGP-RR" class="headerlink" title="Calico BGP RR"></a>Calico BGP RR</h4><p>calico还和flannel host-gw不同之处在于，它不会创建网桥设备，而是通过路由表来维护每个pod的通信，如下图：</p>
<p><img src="https://i.loli.net/2021/07/14/2nKSBwmRChpUqgD.png" alt="image-20210714200920896"></p>
<p>Pod1 访问 Pod2大致流程如下：</p>
<ul>
<li>数据包从Pod1出到达Veth Pair另一端（宿主机上，以cali前缀开头）</li>
<li>宿主机根据路由规则，将数据包转发给下一跳（网关）</li>
<li>到达Node2，根据路由规则将数据包转发给cali设备，从而到达Pod2</li>
</ul>
<p>实际例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">1.启动2个容器</span><br><span class="line">kubectl create -f -&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: apps/v1</span></span><br><span class="line"><span class="string">kind: Deployment</span></span><br><span class="line"><span class="string">metadata:</span></span><br><span class="line"><span class="string">  name: nettools-deploy</span></span><br><span class="line"><span class="string">spec:</span></span><br><span class="line"><span class="string">  replicas: 2</span></span><br><span class="line"><span class="string">  selector:</span></span><br><span class="line"><span class="string">    matchLabels:</span></span><br><span class="line"><span class="string">      app: nettools-deploy</span></span><br><span class="line"><span class="string">  template:</span></span><br><span class="line"><span class="string">    metadata:</span></span><br><span class="line"><span class="string">      labels:</span></span><br><span class="line"><span class="string">        app: nettools-deploy</span></span><br><span class="line"><span class="string">    spec:</span></span><br><span class="line"><span class="string">      containers:</span></span><br><span class="line"><span class="string">        - name: nettools-deploy</span></span><br><span class="line"><span class="string">          image: registry.XXX.com/base/network-multitool:lastet</span></span><br><span class="line"><span class="string">          imagePullPolicy: IfNotPresent     </span></span><br><span class="line"><span class="string">          ports:</span></span><br><span class="line"><span class="string">            - containerPort: 80</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">2.查看2个pod 目前所在的node节点</span><br><span class="line">kubectl get pod -owide</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE    IP             NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nettools-deploy-68b646bdfb-2ckgt   1/1     Running   0          113s   10.5.231.54    10.4.83.14   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nettools-deploy-68b646bdfb-xbpwd   1/1     Running   0          113s   10.5.228.128   10.4.83.11   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">3.查看pod中的路由和网卡信息，可以看到路由指向的是一个不存在的网关地址169.254.1.1，这个主要利用了ARP代理欺骗的技术来把pod 所有数据流导到宿主机的 cali70d877f367d@if3 网卡上</span><br><span class="line">kubectl <span class="built_in">exec</span> -ti nettools-deploy-68b646bdfb-2ckgt  /bin/sh</span><br><span class="line">ip r</span><br><span class="line">default via 169.254.1.1 dev eth0</span><br><span class="line">169.254.1.1 dev eth0 scope link</span><br><span class="line">/ <span class="comment"># ip a</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth0@if9431: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether be:11:81:9a:9b:d4 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.5.231.54/32 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4.可以登录node 查看Veth Pair 设备和路由信息，这里可以看到网卡的编号和pod 中的网卡名是一样的。所以称之为虚拟网卡对(Veth Pair)，有了这个cali70d877f367d@if3 设备那么容器发出的IP包就会通过veth pair设备到达宿主机</span><br><span class="line">ip r  | grep 10.5.231.54</span><br><span class="line">10.5.231.54 dev cali70d877f367d scope link</span><br><span class="line"></span><br><span class="line">ip a | grep -A 4  9431</span><br><span class="line">9431: cali70d877f367d@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 7</span><br><span class="line">    inet6 fe80::ecee:eeff:feee:eeee/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">5.pod1要想跟其他主机pod2通信那么检查node上是否存在相应的路由，然后到达目标宿主机，再到达目标容器</span><br><span class="line">ip r | grep 10.5.228.128</span><br><span class="line">10.5.228.128/26 via 10.4.83.11 dev bond0 proto bird</span><br></pre></td></tr></table></figure>

<p>其中，这里最核心的 下一跳 路由规则，就是由 Calico 的 Felix 进程负责维护的。这些路由规则信息，则是通过 BGP Client 中 BIRD 组件，使用 BGP 协议来传输。</p>
<p>不难发现，Calico 项目实际上将集群里的所有节点，都当作是边界路由器来处理，它们一起组成了一个全连通的网络，互相之间通过 BGP 协议交换路由规则。这些节点，我们称为 BGP Peer。</p>
<p>需要注意的是calico 维护网络的默认模式是 node-to-node mesh ,这种模式下，每台宿主机的BGP client都会跟集群所有的节点BGP client进行通信交换路由。这样一来，随着节点规模数量N的增加，连接会以N的2次方增长，会集群网络本身带来巨大压力，在集群规模比较大时，官方建议是使用BGP-RR 如下是我们使用网络硬件设备作为RR</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">calicoctl node status</span><br><span class="line">Calico process is running.</span><br><span class="line"></span><br><span class="line">IPv4 BGP status</span><br><span class="line">+--------------+-----------+-------+------------+-------------+</span><br><span class="line">| PEER ADDRESS | PEER TYPE | STATE |   SINCE    |    INFO     |</span><br><span class="line">+--------------+-----------+-------+------------+-------------+</span><br><span class="line">| 10.4.36.250  | global    | up    | 2021-05-11 | Established |</span><br><span class="line">| 10.4.36.251  | global    | up    | 2021-05-11 | Established |</span><br><span class="line">+--------------+-----------+-------+------------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="目前calico架构图"><a href="#目前calico架构图" class="headerlink" title="目前calico架构图"></a>目前calico架构图</h4><p><img src="https://i.loli.net/2021/07/14/cOREUpCYqS5omPI.png" alt="image-20210714205042267"></p>
<p>现在的架构考虑到了冗余，隔离，性能</p>
<ul>
<li>网络隔离，所有的bgp 学习在一组交换机内，不向上通报，避免容器的bgp 影响到我们sdn 的bgp，带来的排障的麻烦，这是隔离。</li>
<li>性能方面，现在集群 bgp 关闭full mesh，改为global，降低因容器集群规模变大，导致路由过多的问题。</li>
<li>冗余方面，现在每台机器2条线，接2个交换机，bgp 跟2个交换机互联，实现了冗余，所有流量通过 交换机交换，满足了性能跟冗余的要求。</li>
</ul>
<h4 id="Calico-优劣势"><a href="#Calico-优劣势" class="headerlink" title="Calico 优劣势"></a>Calico 优劣势</h4><p>优势</p>
<ul>
<li>BGP RR没有封包和解包过程，完全基于两端宿主机的路由表进行转发</li>
<li>可以配合使用 <code>Network Policy</code> 做 pod 和 pod 之前的访问控制</li>
</ul>
<p>劣势</p>
<ul>
<li>要求宿主机处于同一个2层网络下，也就是连在一台交换机上，但也可以突破</li>
<li>每个node上会设置大量（大量)的iptables规则、路由，运维、排障难度大</li>
<li>安全策略隔离上也略显不足</li>
</ul>
<h3 id="CNI插件性能比较"><a href="#CNI插件性能比较" class="headerlink" title="CNI插件性能比较"></a>CNI插件性能比较</h3><p>基于flannel解包包的路由和转发的操作都是在CPU上进行的，这样就造成了计算资源的浪费。下图是从网上找的各种开源网络组件的性能对比。可以看出，无论是带宽还是网络延迟，性能都和calico主机差不多。</p>
<p><img src="https://i.loli.net/2021/07/14/5r1QBLDSUpcR7Hk.png" alt="image-20210714212457115"></p>
<h2 id="Kubernetes-Service-NodePort-和Ingress"><a href="#Kubernetes-Service-NodePort-和Ingress" class="headerlink" title="Kubernetes Service NodePort 和Ingress"></a>Kubernetes Service NodePort 和Ingress</h2><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>Service 这个 Kubernetes 里重要的服务对象。而 Kubernetes 之所以需要 Service，</p>
<ul>
<li><p>一方面是因为 Pod 的 IP 不是固定的</p>
</li>
<li><p>另一方面则是因为一组 Pod 实例之间总会有负载均衡的需求</p>
</li>
</ul>
<p>实际上，Service 是由 kube-proxy 组件，加上 iptables 来共同实现的。</p>
<blockquote>
<p>并且现在还支持IPVS的模式，kube-proxy 通过 iptables 处理 Service 的过程，其实需要在宿主机上设置相当多的 iptables 规则。而且，kube-proxy 还需要在控制循环里不断地刷新这些规则来确保它们始终是正确的。当pod数量巨大时，成百上千条 iptables 规则不断地被刷新，会大量占用该宿主机的 CPU 资源，甚至会让宿主机“卡”在这个过程中。所以说，一直以来，基于 iptables 的 Service 实现，都是制约 Kubernetes 项目承载更多量级的 Pod 的主要障碍。我们知道IPVS跟IPtables都是工作基于内核的Netfilter 的 NAT 模式工作的，IPVS 并不需要在宿主机上为每个 Pod 设置 iptables 规则，而是把对这些“规则”的处理放到了内核态，从而极大地降低了维护这些规则的代价。所以当集群规模比较大的时候，可以使用ipvs 来提高性能。</p>
</blockquote>
<p>ClusterIP 服务是默认的 Kubernetes Service。它为您提供集群内的服务，集群内的其他应用程序可以访问该服务,默认外部无法访问改地址。如图所示</p>
<p><img src="https://i.loli.net/2021/07/14/5VXtAYkF86OxiNH.png" alt="image-20210714223846542"></p>
<h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><p> NodePort服务是将外部流量直接发送到您的服务的最原始方式。NodePort，顾名思义，在所有节点（VM）上打开一个特定的端口，发送到这个端口的任何流量都会转发到服务，如图所示。</p>
<p><img src="https://i.loli.net/2021/07/14/w8H4RvuPsiJnDzN.png" alt="image-20210714224044599"></p>
<h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><p>Ingress 实际上不是一种服务。相反，它位于多个服务的前面，充当“智能路由器”或集群的入口点。</p>
<p>Ingress 的功能其实很容易理解：所谓 Ingress，就是 Service 的“Service”，如图所示：</p>
<p><img src="https://i.loli.net/2021/07/14/hgznYwIPp87KHJF.png" alt="image-20210714224239095"></p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol>
<li>为什么要用calico </li>
<li>cilium 取代calico</li>
<li>….</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.ljohn.cn">Ljohn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.ljohn.cn/posts/484087c6/">https://www.ljohn.cn/posts/484087c6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.ljohn.cn" target="_blank">Ljohn's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/dccf6045/" title="Hexo 分类和标签"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hexo 分类和标签</div></div></a></div><div class="next-post pull-right"><a href="/posts/2ad2e944/" title="Go语言基础之接口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go语言基础之接口</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ljohn</div><div class="author-info__description">知行合一，止于至善</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Ljohn001"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ljohn001" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ljohnmail@foxmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.ljohn.cn/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Ljohn的个人博客，如果阅读过程中遇到了问题，请及时评论或者留言，看到了会在第一时间给出回复。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">容器是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8A%BF"><span class="toc-number">1.1.</span> <span class="toc-text">容器优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kebernetes"><span class="toc-number">1.2.</span> <span class="toc-text">Kebernetes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">容器网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">docker 的三种网络模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E5%AE%B9%E5%99%A8%E9%80%9A%E4%BF%A1"><span class="toc-number">2.2.</span> <span class="toc-text">单机容器通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E4%B8%BB%E6%9C%BA%E5%AE%B9%E5%99%A8%E9%80%9A%E4%BF%A1"><span class="toc-number">2.3.</span> <span class="toc-text">跨主机容器通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9CCNI%E6%8F%92%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">Kubernetes 容器网络CNI插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flannel-%E6%8F%92%E4%BB%B6%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">Flannel 插件跨主机通信原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#udp%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">udp模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VXLAN%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">VXLAN模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes-%E4%B8%89%E5%B1%82%E7%BD%91%E7%BB%9C%E6%96%B9%E6%A1%88"><span class="toc-number">5.</span> <span class="toc-text">Kubernetes 三层网络方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flannel-%E7%9A%84-host-gw-%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">Flannel 的 host-gw 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calico"><span class="toc-number">5.2.</span> <span class="toc-text">Calico</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Calico-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">Calico 网络模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.2.2.</span> <span class="toc-text">BGP 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calico-IPIP"><span class="toc-number">5.2.3.</span> <span class="toc-text">Calico IPIP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calico-BGP-RR"><span class="toc-number">5.2.4.</span> <span class="toc-text">Calico BGP RR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%89%8Dcalico%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">5.2.5.</span> <span class="toc-text">目前calico架构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calico-%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="toc-number">5.2.6.</span> <span class="toc-text">Calico 优劣势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CNI%E6%8F%92%E4%BB%B6%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">5.3.</span> <span class="toc-text">CNI插件性能比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes-Service-NodePort-%E5%92%8CIngress"><span class="toc-number">6.</span> <span class="toc-text">Kubernetes Service NodePort 和Ingress</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Service"><span class="toc-number">6.0.1.</span> <span class="toc-text">Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NodePort"><span class="toc-number">6.0.2.</span> <span class="toc-text">NodePort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ingress"><span class="toc-number">6.0.3.</span> <span class="toc-text">Ingress</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FAQ"><span class="toc-number">7.</span> <span class="toc-text">FAQ</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/66cd6d39/" title="顺利成为Kubestronaut成员">顺利成为Kubestronaut成员</a><time datetime="2025-03-13T12:51:26.086Z" title="发表于 2025-03-13 20:51:26">2025-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/25154b6c/" title="UDEMY-KCSA练习错题集">UDEMY-KCSA练习错题集</a><time datetime="2025-03-13T12:48:52.759Z" title="发表于 2025-03-13 20:48:52">2025-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b6e3b579/" title="KCSA错题集">KCSA错题集</a><time datetime="2025-03-13T12:36:37.831Z" title="发表于 2025-03-13 20:36:37">2025-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/61bd4278/" title="CKAD模拟题2024">CKAD模拟题2024</a><time datetime="2024-03-24T20:14:41.000Z" title="发表于 2024-03-25 04:14:41">2024-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/6fd8cc9b/" title="2024CKAD考试心得">2024CKAD考试心得</a><time datetime="2024-03-24T18:35:21.000Z" title="发表于 2024-03-25 02:35:21">2024-03-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Ljohn</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '09095629e7d96304805d',
      clientSecret: 'f7e635330c322cdc1478de533f9aa89c4f89d0d7',
      repo: 'blogs',
      owner: 'Ljohn001',
      admin: ['Ljohn001'],
      id: '6f69065ea0584f182524b2097e10fedd',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('/pluginsSrc/gitalk/dist/gitalk.css')
    getScript('/pluginsSrc/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script src="/js/jquery.min.js"></script><script src="/js/fishes.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>